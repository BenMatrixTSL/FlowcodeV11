<!-- CRC: 0796FC1E6A776AF9156B257209C35258EBA815F6EB61C8A7384099907008E1143AA50E87FDA2D1DA6AABF1E55FB41EB62B702871DF5ADABCC487AA0E0C74ACDB424A1FC7A5E75492778F6B0DA6FA05B9A4BAF1B34E38B68E0C3CAEE8E7DA6987F64B170EC6322EE57D8C0802FF00976D124800333670F00BC6446FB280DEF87F2528B27C872C96C70D701D462E27C83088B8EF49A659B3F2326A774BC5C807BE759B4016EE8B6E123F84D4A1FBCE5461263FC0FA7616C8DE086944AE325796A6A5E41A8D665B9CB9DDA04D7C36E98C0D0455A1AF81E951606DAE80F1ED87A78E40144AF09ADB914F -->
<!-- REVISION: 10.0 -->
<!-- GUID: CBEA7CAC-7AEE-451E-B9C4-209F5CB7E1F4 -->
<!-- DATE: 22\10\2025 -->
<!-- DIR: FCD\ESP\M5Stack_AtomS3.fcdx -->

<root>

<build>
<compiler   exe="$(fcddir)ESP\Batch\esp32_build.bat" params="&quot;$(compileresp)&quot; &quot;$(target)&quot; &quot;$(outdir)&quot; esp32_s3_sdkconfig  esp32s3 " />
<linker     exe="$(appdir)tools\DoNothing\DoNothing.exe" params="" />
<programmer exe="$(fcddir)ESP\Batch\esp32_prog.bat"  params="&quot;$(compileresp)&quot; &quot;$(target)&quot; &quot;$(outdir)&quot; $(comport) 115200 esp32_s3_sdkconfig  esp32s3 " UsesComm="1" />
</build>


<device name='M5Stack_AtomS3'
		namealt='esp32s3'
		product='ESP' 
		cal='ESP' 
		family='ESP32'
		bits='32' >

	<comminfo />
	
    <clock max_speed='240000000' master_divider='1' default='240000000' />
    
    <memory >
        <flash bytes='2097152' />
        <ram bytes='327680' />
    </memory>

    <pins sides='2' smd='0' alt_pin_refs="1" >
		<pin name='IO4 / IR LED' port='0' bit='4' adc='3' rpreg='4' rpnum='4' caption="GPIO4" />	
		<pin name='IO5 / Expansion' port='0' bit='5' adc='4' rpreg='5' rpnum='5' caption="GPIO5" />
		<pin name='IO6 / Expansion' port='0' bit='6' adc='5' rpreg='6' rpnum='6' caption="GPIO6" />
		<pin name='IO7 / Expansion' port='0' bit='7' adc='6' rpreg='7' rpnum='7' caption="GPIO7" />
		<pin name='IO15 / ST7789 CS' port='0' bit='15' adc='36' rpreg='15' rpnum='15' caption="GPIO15" />
		<pin name='IO16 / ST7789 BL' port='0' bit='16' adc='37' rpreg='16' rpnum='16' caption="GPIO16" />
		<pin name='IO17 / ST7789 SCK' port='0' bit='17' adc='38' rpreg='17' rpnum='17' caption="GPIO17" />
		<pin name='IO8 / Expansion' port='0' bit='8' adc='7' rpreg='8' rpnum='8' caption="GPIO8" />
		<pin name='IO33 / ST7789 RS' port='1' bit='1' rpreg='33' rpnum='33' caption="GPIO33" />	
		<pin name='IO34 / ST7789 RST' port='1' bit='2' rpreg='34' rpnum='34' caption="GPIO34" />
		<pin name='IO21 / ST7789 MOSI' port='0' bit='21' rpreg='21' rpnum='21' caption="GPIO21" />
		<pin name='IO38 / Expansion / MPU6886 SDA' port='1' bit='6' rpreg='38' rpnum='38' caption="GPIO38" />
		<pin name='IO39 / Expansion / MPU6886 SCL' port='1' bit='7' rpreg='39' rpnum='39' caption="GPIO39" />
		<pin name='IO41 / Button' port='1' bit='9' rpreg='41' rpnum='41' caption="GPIO41" />
		<pin name='IO2 / GroveA' port='0' bit='2' adc='1' rpreg='2' rpnum='2' caption="GPIO2" />
		<pin name='IO1 / GroveB' port='0' bit='1' adc='0' rpreg='1' rpnum='1' caption="GPIO1" />
    </pins>
    
    <biasresistors allpins='1' mode='3' >
    	<code>
	    <pullup code='gpio_set_pull_mode(xxx, GPIO_PULLUP_ONLY);' />
	    <pulldown code='gpio_set_pull_mode(xxx, GPIO_PULLDOWN_ONLY);' />
	    <disable code='gpio_set_pull_mode(xxx, GPIO_FLOATING);' />
    	</code>
    </biasresistors>
    
    <adc type='1' bits='12' >
        <speed >
            <option name='Fixed' value='3' />
        </speed>
        <vref>
            <option name='2450mV' value='0' />
            <option name='1750mV' value='1' />
            <option name='1250mV' value='2' />
            <option name='950mV' value='3' />
        </vref>
    </adc>

    <dac type='1' bits='8' >
        <vref>
            <option name='VDD' value='0' />
        </vref>
        <out port='0' pin='17' />
	<out port='0' pin='18' />
    </dac>
	
    <eeprom type='1' bytes='128' address='0' />
	
    <spi remappable='1' >
        <clk  rpnum='1' caption="GPIO39" />
        <miso rpreg='SPI1' />
        <mosi rpnum='1' caption="GPIO39" />
    </spi>

    <spi remappable='1' >
        <clk  rpnum='1' caption="GPIO39" />
        <miso rpreg='SPI2' />
        <mosi rpnum='1' caption="GPIO39" />
    </spi>

    <i2c remappable='1' >
        <sda rpnum='1' caption="GPIO39" rpreg='I2C1' />
        <scl rpreg='I2C2' />
    </i2c>

    <i2c remappable='1' >
        <sda rpnum='1' caption="GPIO39" rpreg='I2C3' />
        <scl rpreg='I2C4' />
    </i2c>

    <i2s type='1' remappable='1' >
        <ck rpnum='1' caption="GPIO39" rpreg='I2S1' />
	<ws rpnum='1' caption="GPIO39" rpreg='I2S2' />
	<do rpnum='1' caption="GPIO39" rpreg='I2S3' />
	<di rpreg='I2S4' />
    </i2s>
    
    <uart remappable='0' >
        <tx port='1' pin='11' />
        <rx port='1' pin='12' />
    </uart>   
    
    <uart remappable='1' >
        <tx rpnum='1' caption="GPIO39" />
        <rx rpreg='U2' />
    </uart>   
    
    <pwm remappable='1' >
    	<timer />
        <prescaler />
        <out rpnum='1' />
        <out rpnum='2' />
        <out rpnum='3' />
        <out rpnum='4' />
        <out rpnum='5' />
        <out rpnum='6' />
        <out rpnum='7' />
        <out rpnum='8' />
    </pwm>
    
    <sd remappable='1' />
    
    <interrupts >
        <interrupt ident='RXINT0' type='comms' name='UART0 RX' 
			global='\n#define MX_UART0_INT\n'
			handler='#ifndef MX_INTHANDLER_RXINT0\n#define MX_INTHANDLER_RXINT0\nMX_UART_INT_CH1_FUNC FCM_%n();\nMX_UART_INT_FUNC_END\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='uart0_interrupt_enabled = 1;\n' 
			disable='uart0_interrupt_enabled = 0;\n' />
        <interrupt ident='RXINT1' type='comms' name='UART1 RX' 
			global='\n#define MX_UART1_INT\n'
			handler='#ifndef MX_INTHANDLER_RXINT1\n#define MX_INTHANDLER_RXINT1\nMX_UART_INT_CH2_FUNC FCM_%n();\nMX_UART_INT_FUNC_END\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='uart1_interrupt_enabled = 1;\n' 
			disable='uart1_interrupt_enabled = 0;\n' />

        <interrupt ident='TMR0' name='Timer 0' regl='TMR0' regh='' type='timer8'
			handler='#ifndef MX_INTHANDLER_TIMER0\n#define MX_INTHANDLER_TIMER0\nvoid FC_CAL_Timer_0_ISR(void* p)\n{\n\tFCM_%n();\n\tFC_CAL_Timer_Rearm(0);\n}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='FC_CAL_Timer_Init(0, FC_CAL_Timer_Period * FC_CAL_Timer_Multiplier, FC_CAL_Timer_0_ISR);\n' 
			disable='FC_CAL_Timer_Deinit(0);\n' >
            <timer overflow='4294967295' extrange='0' />
            <options >
				<rollover name='Timer Period (integer)' >
                    <entry name='1000' min='1' max='4294967295' value='FC_CAL_Timer_Period = %d;\n' />
                </rollover>
			    <option name='Timer Resolution' >
			    		<entry name='microseconds (experimental)' value='FC_CAL_Timer_Multiplier = 1;\n' />
					<entry name='milliseconds' value='FC_CAL_Timer_Multiplier = 1000;\n' />
					<entry name='seconds'      value='FC_CAL_Timer_Multiplier = 1000000;\n' />
                </option>
            </options>
        </interrupt>
        <interrupt ident='TMR1' name='Timer 1' regl='TMR1' regh='' type='timer8'
			handler='#ifndef MX_INTHANDLER_TIMER1\n#define MX_INTHANDLER_TIMER1\nvoid FC_CAL_Timer_1_ISR(void* p)\n{\n\tFCM_%n();\n\tFC_CAL_Timer_Rearm(1);\n}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='FC_CAL_Timer_Init(1, FC_CAL_Timer_Period * FC_CAL_Timer_Multiplier, FC_CAL_Timer_1_ISR);\n' 
			disable='FC_CAL_Timer_Deinit(1);\n' >
            <timer overflow='4294967295' extrange='0' />
            <options >
				<rollover name='Timer Period (integer)' >
                    <entry name='1000' min='1' max='4294967295' value='FC_CAL_Timer_Period = %d;\n' />
                </rollover>
			    <option name='Timer Resolution' >
			    		<entry name='microseconds (experimental)' value='FC_CAL_Timer_Multiplier = 1;\n' />
					<entry name='milliseconds' value='FC_CAL_Timer_Multiplier = 1000;\n' />
					<entry name='seconds'      value='FC_CAL_Timer_Multiplier = 1000000;\n' />
                </option>
            </options>
        </interrupt>
        <interrupt ident='TMR2' name='Timer 2' regl='TMR2' regh='' type='timer8'
			handler='#ifndef MX_INTHANDLER_TIMER2\n#define MX_INTHANDLER_TIMER2\nvoid FC_CAL_Timer_2_ISR(void* p)\n{\n\tFCM_%n();\n\tFC_CAL_Timer_Rearm(2);\n}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='FC_CAL_Timer_Init(2, FC_CAL_Timer_Period * FC_CAL_Timer_Multiplier, FC_CAL_Timer_2_ISR);\n' 
			disable='FC_CAL_Timer_Deinit(2);\n' >
            <timer overflow='4294967295' extrange='0' />
            <options >
				<rollover name='Timer Period (integer)' >
                    <entry name='1000' min='1' max='4294967295' value='FC_CAL_Timer_Period = %d;\n' />
                </rollover>
			    <option name='Timer Resolution' >
			    		<entry name='microseconds (experimental)' value='FC_CAL_Timer_Multiplier = 1;\n' />
					<entry name='milliseconds' value='FC_CAL_Timer_Multiplier = 1000;\n' />
					<entry name='seconds'      value='FC_CAL_Timer_Multiplier = 1000000;\n' />
                </option>
            </options>
        </interrupt>
        <interrupt ident='TMR3' name='Timer 3' regl='TMR3' regh='' type='timer8'
			handler='#ifndef MX_INTHANDLER_TIMER3\n#define MX_INTHANDLER_TIMER3\nvoid FC_CAL_Timer_3_ISR(void* p)\n{\n\tFCM_%n();\n\tFC_CAL_Timer_Rearm(3);\n}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='FC_CAL_Timer_Init(3, FC_CAL_Timer_Period * FC_CAL_Timer_Multiplier, FC_CAL_Timer_3_ISR);\n' 
			disable='FC_CAL_Timer_Deinit(3);\n' >
            <timer overflow='4294967295' extrange='0' />
            <options >
				<rollover name='Timer Period (integer)' >
                    <entry name='1000' min='1' max='4294967295' value='FC_CAL_Timer_Period = %d;\n' />
                </rollover>
			    <option name='Timer Resolution' >
			    		<entry name='microseconds (experimental)' value='FC_CAL_Timer_Multiplier = 1;\n' />
					<entry name='milliseconds' value='FC_CAL_Timer_Multiplier = 1000;\n' />
					<entry name='seconds'      value='FC_CAL_Timer_Multiplier = 1000000;\n' />
                </option>
            </options>
        </interrupt>

        <interrupt ident='GPIO1' type='pin' name='GPIO1' 
			global='\nvoid MX_ISR_GPIO1(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO1_DEF\n#define MX_ISR_GPIO1_DEF\nvoid MX_ISR_GPIO1(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_1);\ngpio_set_direction(GPIO_NUM_1, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_1, MX_ISR_GPIO1, (void*) GPIO_NUM_1);\ngpio_intr_enable(GPIO_NUM_1);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_1);\n' >
            <ioc config='3' >
                <rising port='0' mask='0x2' />
                <falling port='0' mask='0x2' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_1, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_1, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_1, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>
		
        <interrupt ident='GPIO2' type='pin' name='GPIO2' 
			global='\nvoid MX_ISR_GPIO2(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO2_DEF\n#define MX_ISR_GPIO2_DEF\nvoid MX_ISR_GPIO2(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_2);\ngpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_2, MX_ISR_GPIO2, (void*) GPIO_NUM_2);\ngpio_intr_enable(GPIO_NUM_2);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_2);\n' >
            <ioc config='3' >
                <rising port='0' mask='0x4' />
                <falling port='0' mask='0x4' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_2, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_2, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_2, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>
		
        <interrupt ident='GPIO5' type='pin' name='GPIO5' 
			global='\nvoid MX_ISR_GPIO5(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO5_DEF\n#define MX_ISR_GPIO5_DEF\nvoid MX_ISR_GPIO5(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_5);\ngpio_set_direction(GPIO_NUM_5, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_5, MX_ISR_GPIO5, (void*) GPIO_NUM_5);\ngpio_intr_enable(GPIO_NUM_5);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_5);\n' >
            <ioc config='3' >
                <rising port='0' mask='0x20' />
                <falling port='0' mask='0x20' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_5, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_5, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_5, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>
        
        <interrupt ident='GPIO6' type='pin' name='GPIO6' 
			global='\nvoid MX_ISR_GPIO6(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO6_DEF\n#define MX_ISR_GPIO6_DEF\nvoid MX_ISR_GPIO6(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_6);\ngpio_set_direction(GPIO_NUM_6, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_6, MX_ISR_GPIO6, (void*) GPIO_NUM_6);\ngpio_intr_enable(GPIO_NUM_6);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_6);\n' >
            <ioc config='3' >
                <rising port='0' mask='0x40' />
                <falling port='0' mask='0x40' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_6, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_6, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_6, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>
		
       <interrupt ident='GPIO7' type='pin' name='GPIO7' 
			global='\nvoid MX_ISR_GPIO7(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO7_DEF\n#define MX_ISR_GPIO7_DEF\nvoid MX_ISR_GPIO7(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_7);\ngpio_set_direction(GPIO_NUM_7, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_7, MX_ISR_GPIO7, (void*) GPIO_NUM_7);\ngpio_intr_enable(GPIO_NUM_7);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_7);\n' >
            <ioc config='3' >
                <rising port='0' mask='0x80' />
                <falling port='0' mask='0x80' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_7, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_7, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_7, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>


       <interrupt ident='GPIO8' type='pin' name='GPIO8' 
			global='\nvoid MX_ISR_GPIO8(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO8_DEF\n#define MX_ISR_GPIO8_DEF\nvoid MX_ISR_GPIO8(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_8);\ngpio_set_direction(GPIO_NUM_8, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_8, MX_ISR_GPIO8, (void*) GPIO_NUM_8);\ngpio_intr_enable(GPIO_NUM_8);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_8);\n' >
            <ioc config='3' >
                <rising port='0' mask='0x100' />
                <falling port='0' mask='0x100' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_8, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_8, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_8, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>

		<interrupt ident='GPIO38' type='pin' name='GPIO38' 
			global='\nvoid MX_ISR_GPIO38(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO38_DEF\n#define MX_ISR_GPIO38_DEF\nvoid MX_ISR_GPIO38(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_38);\ngpio_set_direction(GPIO_NUM_38, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_38, MX_ISR_GPIO38, (void*) GPIO_NUM_38);\ngpio_intr_enable(GPIO_NUM_38);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_38);\n' >
            <ioc config='3' >
                <rising port='1' mask='0x40' />
                <falling port='1' mask='0x40' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_38, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_38, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_38, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>

		<interrupt ident='GPIO39' type='pin' name='GPIO39' 
			global='\nvoid MX_ISR_GPIO39(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO39_DEF\n#define MX_ISR_GPIO39_DEF\nvoid MX_ISR_GPIO39(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_39);\ngpio_set_direction(GPIO_NUM_39, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_39, MX_ISR_GPIO39, (void*) GPIO_NUM_39);\ngpio_intr_enable(GPIO_NUM_39);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_39);\n' >
            <ioc config='3' >
                <rising port='1' mask='0x80' />
                <falling port='1' mask='0x80' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_39, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_39, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_39, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>
	
       <interrupt ident='GPIO41' type='pin' name='GPIO41' 
			global='\nvoid MX_ISR_GPIO41(void*);\n'
			handler='\n#ifndef MX_ISR_GPIO41_DEF\n#define MX_ISR_GPIO41_DEF\nvoid MX_ISR_GPIO41(void* arg){FCM_%n();}\n#else\n#warning &quot;This interrupt has previously been enabled, so the macro &lt;%n&gt; may never get called.&quot;\n#endif\n' 
			enable='\ngpio_pad_select_gpio(GPIO_NUM_41);\ngpio_set_direction(GPIO_NUM_41, GPIO_MODE_INPUT);\ngpio_install_isr_service(ESP_INTR_FLAG_LOWMED);\ngpio_isr_handler_add(GPIO_NUM_41, MX_ISR_GPIO41, (void*) GPIO_NUM_41);\ngpio_intr_enable(GPIO_NUM_41);\n'
			disable='\ngpio_intr_disable(GPIO_NUM_41);\n' >
            <ioc config='3' >
                <rising port='1' mask='0x200' />
                <falling port='1' mask='0x200' />
            </ioc>
	    <options >
                <edge name='Interrupt Edge Select' >
                    <entry name='Rising edge' value='\ngpio_set_intr_type(GPIO_NUM_41, GPIO_INTR_POSEDGE);' />
                    <entry name='Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_41, GPIO_INTR_NEGEDGE);' />
                    <entry name='Rising and Falling edge' value='\ngpio_set_intr_type(GPIO_NUM_41, GPIO_INTR_ANYEDGE);' />
                </edge>
            </options>
        </interrupt>
	
    </interrupts>
    
</device>
<inline >
    <defines code='\n#define MX_CAL_ESP32\n#define MX_CAL_ESP32S3\n#define MX_ESP32_TYPE ESP32S3\n' />
    <directives code='#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &quot;freertos/FreeRTOS.h&quot;\n#include &quot;freertos/event_groups.h&quot;\n#include &quot;freertos/task.h&quot;\n#include &quot;driver/gpio.h&quot;\n#include &quot;esp_wifi.h&quot;\n#include &quot;esp_log.h&quot;\n#include &quot;esp_event_loop.h&quot;\n#include &quot;nvs_flash.h&quot;\n#include &quot;lwip/err.h&quot;\n#include &quot;lwip/sys.h&quot;\n#include &quot;sdkconfig.h&quot;' />
    <main >
        <start code='\nvoid app_main()\n{
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );
	ESP_ERROR_CHECK(esp_event_loop_create_default());\n' />
        <end code='\tmainendloop: goto mainendloop;\n}\n\n' />
        <init code='' />
    </main>
    <interrupt >
        <enable code='' />
        <start code='' />
        <end code='' />
        <init code='' />
    </interrupt>
    <config >
        <start code='//Configuration Start\n' />
        <body code='' />
        <end code='//Configuration End\n\n' />
    </config>
</inline>
<test >
    <icd >
        <clock port0='1' pin0='1' />
        <data port0='1' pin0='0' />
    </icd>
</test>
</root>
