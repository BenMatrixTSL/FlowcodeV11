// CRC: C09139DD0A75D64CECB6A655701556EC04E7A0BAAEC1407B0F4C89EF6364E65A25403FAB33447FAB66D2C71EAC4D3E5A920BE72345EF4485BD63C62E7661FB35FFB85386900EA5FE3557084443D810B26D1F95C708D07462464D59A39C9F4F55B3277527469C5BEA5CDE1F8D43685DD5B320FFFB2B1F58F1BC383A35532066CC5FA0E62B037F1A5CAEF80DBA3F4D0A50472C62FDE82D2F75439B1C68AA2CCD51ABC2C2431F6C4065B2B59391F7DFE3FBA4BAF1B34E38B68E0C3CAEE8E7DA6987995842DA2438949F0AC374B9CCC2B541EBBE994099FE5FB3A41F75714759526B30D91A0E9EEE5FC56019D4E05A0FCF128AA0F41D24B5806AFCD8C1CE9352280CCE51571FB63F56CD944F436E1E9DEC8D00A8FF7CFF8D36B4549D34A0D5AD11F3E12F304DE4C21006CA8194D3AD2A47D80FE02F4833AD1C69FFF40AFCB70232C7C058EE1ADCF61339
// REVISION: 1.0
// GUID: B6CB6266-200A-4788-A458-15BF9959A021
// DATE: 15\12\2025
// DIR: Misc\Templates\Sensors|and|microcontrollers\PIC\BL0144|dig|temp|sensor|-|PIC.c
//************************************************************************************
//**  
//**  Source name:   \\IRONMAN-PC2\Dev\Flowcode V11\Examples\Templates\Sensors and microcontrollers\PIC\BL0144 dig temp sensor - PIC.fcfx
//**  Title:         BL0144 dig temp sensor - PIC
//**  Description:   
//**  Device:        PIC.18F.E-blocks3 8-bit PIC
//**  
//**  Generated by:  Flowcode v11.0.0.8
//**  Date:          Monday, December 15, 2025 14:48:16
//**  Users:         1
//**  Registered to: JohnD (65060919)
//**  Licence key: MNBNUH
//**  
//**  
//**  https://www.flowcode.co.uk
//**  
//************************************************************************************


#include "\\IRONMAN-PC2\Dev\Flowcode V11\Examples\Templates\Sensors and microcontrollers\PIC\BL0144 dig temp sensor - PIC.h"


/*========================================================================*\
   Use :RXCB
       :GUID: c34f9b8a-a915-4f75-ad0c-87f2ad670a8a
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\CircularBuffer.fcpx
       :Version: 7.0 (0x100628)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_01211_RXCB__DATA 32
MX_GLOBAL MX_UINT16 FCV_01211_RXCB__DATAEND = (0x0);
MX_GLOBAL MX_UINT8 FCV_01211_RXCB__LOOKFORCOUNTER = (0x0);
MX_GLOBAL MX_UINT8 FCV_01211_RXCB__DATA[FCVsz_01211_RXCB__DATA];
MX_GLOBAL MX_UINT16 FCV_01211_RXCB__DATASTART = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Scans the buffer for an array of specific values.
       :Returns 0 if the value is not found.
       :Returns 1 if the value is found.
       :
       :Parameters for macro LookForValue:
       :  Value[20] : Value to look for, can be a string or byte array,
       :  NumChars : The number of characters you wish to try and match
       :  RemoveContent : 0=Leave data alone, 1=Remove data from buffer
       :  ResetFind : 0=Continue the find from the last operation, 1=Start again
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__LookForValue(MX_CHAR *FCL_VALUE, MX_UINT16 FCLsz_VALUE, MX_UINT8 FCL_NUMCHARS, MX_UINT8 FCL_REMOVECONTENT, MX_UINT8 FCL_RESETFIND)
{
  //Local variable definitions
  MX_UINT8 FCL_COMPAREDATA;
  MX_UINT8 FCL_NUMBYTES;
  MX_UINT16 FCL_DATAINDEX;
  MX_UINT16 FCL_SEARCHINDEX;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_RESETFIND == 1)
  {  

    FCV_01211_RXCB__LOOKFORCOUNTER = 0;

  // } else {

  }

  FCL_SEARCHINDEX = FCV_01211_RXCB__LOOKFORCOUNTER;

  FCL_NUMBYTES = FCD_01211_RXCB__GetNumberBytes();

  while (FCL_NUMCHARS > FCV_01211_RXCB__LOOKFORCOUNTER)
  {
    if (FCL_NUMBYTES > 0)
    {    

      if (FCL_REMOVECONTENT == 1)
      {      

        FCL_COMPAREDATA = FCD_01211_RXCB__GetByte();

      } else {

        FCL_DATAINDEX = FCV_01211_RXCB__DATASTART + FCL_SEARCHINDEX;

        if (FCL_DATAINDEX >= 32)
        {        

          FCL_DATAINDEX = FCL_DATAINDEX - 32;

        // } else {

        }

        FCL_COMPAREDATA = FCV_01211_RXCB__DATA[FCL_DATAINDEX];

        FCL_SEARCHINDEX = FCL_SEARCHINDEX + 1;

      }

      if (FCL_COMPAREDATA == FCL_VALUE[FCV_01211_RXCB__LOOKFORCOUNTER])
      {      

        FCV_01211_RXCB__LOOKFORCOUNTER = FCV_01211_RXCB__LOOKFORCOUNTER + 1;

        if (FCV_01211_RXCB__LOOKFORCOUNTER == FCL_NUMCHARS)
        {        

          FCV_01211_RXCB__LOOKFORCOUNTER = 0;

          FCL_NUMCHARS = 0;
          FCR_RETVAL = 1;

        // } else {

        }

      } else {

        if (FCV_01211_RXCB__LOOKFORCOUNTER > 0)
        {        

          FCV_01211_RXCB__LOOKFORCOUNTER = 0;

          if (FCL_COMPAREDATA == FCL_VALUE[FCV_01211_RXCB__LOOKFORCOUNTER])
          {          

            FCV_01211_RXCB__LOOKFORCOUNTER = FCV_01211_RXCB__LOOKFORCOUNTER + 1;

          // } else {

          }

        // } else {

        }

      }

      FCL_NUMBYTES = FCL_NUMBYTES - 1;

    } else {

      FCL_NUMCHARS = 0;

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads an array of Bytes from the circular buffer.
       :
       :Parameters for macro GetArray:
       :  Data[1000] : Data array to store the data into
       :  NumBytes : Number of bytes to read from the buffer
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__GetArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);


  while (FCL_IDX < FCL_NUMBYTES)
  {
    FCL_DATA[FCL_IDX] = FCD_01211_RXCB__GetByte();

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Reads a string of characters from the circular buffer.
       :
       :Parameters for macro GetString:
       :  MaxLength : Max number of bytes the string can store including the null byte
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT16 FCL_MAXLENGTH)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);


  if (FCL_MAXLENGTH > 1)
  {  

    FCL_MAXLENGTH = FCL_MAXLENGTH - 1;

  // } else {

  }

  while (FCL_IDX < FCL_MAXLENGTH)
  {
    FCR_RETVAL[FCL_IDX] = FCD_01211_RXCB__GetByte();

    if ((FCR_RETVAL[FCL_IDX] == 0) || (FCR_RETVAL[FCL_IDX] == 255))
    {    

      goto FCC_GetString_A;

    } else {

      FCL_IDX = FCL_IDX + 1;

    }

  }

FCC_GetString_A:
  ;

  FCR_RETVAL[FCL_IDX] = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :Writes an array of bytes into the circular buffer.
       :
       :Parameters for macro PutArray:
       :  Data[1000] : Byte array to write into the buffer
       :  NumBytes : Number of bytes to write into the buffer
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__PutArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);


  while (FCL_IDX < FCL_NUMBYTES)
  {
    FCD_01211_RXCB__PutByte(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the value of a single byte at a known location in the buffer.
       :Leaves the buffer contents and pointers untouched.
       :
       :Parameters for macro GetIndexedByte:
       :  address : MX_UINT16
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__GetIndexedByte(MX_UINT16 FCL_ADDRESS)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_ADDRESS < 32)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATA[FCL_ADDRESS];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits for an array of values to appear in the circular buffer.
       :Returns 0 to indicate a timeout.
       :Returns 1 to indicate the data has been found.
       :
       :Parameters for macro WaitForValue:
       :  Value[20] : MX_CHAR (by-ref)
       :  NumChars : Number of characters to try and look for
       :  RemoveContent : 0=Leave the buffer contents untouched, 1=Remove values as you go
       :  Timeout : Max amount of time to wait in milliseconds before returning 0=WaitForever
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__WaitForValue(MX_CHAR *FCL_VALUE, MX_UINT16 FCLsz_VALUE, MX_UINT8 FCL_NUMCHARS, MX_UINT8 FCL_REMOVECONTENT, MX_UINT16 FCL_TIMEOUT)
{
  //Local variable definitions
  MX_UINT8 FCL_WAITFOREVER = (0x0);
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_TIMEOUT == 0)
  {  

    FCL_WAITFOREVER = 1;
    FCL_TIMEOUT = 0xFFFF;

  // } else {

  }

  while ((FCL_TIMEOUT > 0) && (FCR_RETVAL == 0))
  {
    FCI_DELAYBYTE_MS(1);

    if (FCL_WAITFOREVER == 0)
    {    

      FCL_TIMEOUT = FCL_TIMEOUT - 1;

    // } else {

    }

    FCR_RETVAL = FCD_01211_RXCB__LookForValue(FCL_VALUE, FCLsz_VALUE, FCL_NUMCHARS, FCL_REMOVECONTENT, 0);

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the number of valid data bytes currently inside the buffer.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__GetNumberBytes()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  //Comment:
  //Jump directly to the answer

  if (FCV_01211_RXCB__DATAEND > FCV_01211_RXCB__DATASTART)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATAEND - FCV_01211_RXCB__DATASTART;

  } else {

    if (FCV_01211_RXCB__DATAEND < FCV_01211_RXCB__DATASTART)
    {    

      FCR_RETVAL = (32 - FCV_01211_RXCB__DATASTART) + FCV_01211_RXCB__DATAEND;

    } else {

      FCR_RETVAL = 0;

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the next available byte from the circular buffer without advancing the current index,
       :Returns 255/512 if the buffer is empty.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__PeekByte()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT16 FCR_RETVAL;


  if (FCV_01211_RXCB__DATASTART != FCV_01211_RXCB__DATAEND)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATA[FCV_01211_RXCB__DATASTART];

  } else {

    #if (0) // 0 == 1
    //Code has been optimised out by the pre-processor
    #else
      FCR_RETVAL = 255;

    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Writes a string of characters into the circular buffer.
       :
       :Parameters for macro PutString:
       :  Data[20] : String data array to write into the buffer
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__PutString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_LEN;


  FCL_LEN = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);

  while (FCL_IDX < FCL_LEN)
  {
    FCD_01211_RXCB__PutByte(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Add byte to the next free location inside the circular buffer.
       :If the data goes into the buffer correctly then return 1.
       :Otherwise the buffer is full and the return value will equal 0.
       :
       :Parameters for macro PutByte:
       :  Data : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__PutByte(MX_UINT8 FCL_DATA)
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT16 FCL_TEMP2;
  MX_UINT8 FCR_RETVAL;


  FCL_TEMP = FCV_01211_RXCB__DATAEND + 1;

  if (FCL_TEMP >= 32)
  {  

    FCL_TEMP = 0;

  // } else {

  }

  if (FCL_TEMP != FCV_01211_RXCB__DATASTART)
  {  

    FCV_01211_RXCB__DATA[FCV_01211_RXCB__DATAEND] = FCL_DATA;

    FCV_01211_RXCB__DATAEND = FCL_TEMP;

    FCR_RETVAL = 1;

  } else {

    #if (0) // 0 == 1
    //Code has been optimised out by the pre-processor
    #else
      FCR_RETVAL = 0;

    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the next available byte from the circular buffer,
       :Returns 255 if the buffer is empty.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__GetByte()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT16 FCR_RETVAL;


  if (FCV_01211_RXCB__DATASTART != FCV_01211_RXCB__DATAEND)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATA[FCV_01211_RXCB__DATASTART];

    FCL_TEMP = FCV_01211_RXCB__DATASTART + 1;

    if (FCL_TEMP >= 32)
    {    

      FCL_TEMP = 0;

    // } else {

    }

    FCV_01211_RXCB__DATASTART = FCL_TEMP;

  } else {

    #if (0) // 0 == 1
    //Code has been optimised out by the pre-processor
    #else
      FCR_RETVAL = 255;

    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the number of bytes that can be stored in the buffer.
       :Either in total or the number of bytes remaining based on Mode.
       :
       :Parameters for macro GetSize:
       :  Mode : 0=TotalBufferSize, 1=BufferFreeSpace
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__GetSize(MX_BOOL FCL_MODE)
{
  //Local variable definitions
  MX_UINT16 FCL_NUMBYTES;
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 32 - 1;

  if (FCL_MODE)
  {  

    FCL_NUMBYTES = FCD_01211_RXCB__GetNumberBytes();

    FCR_RETVAL = FCR_RETVAL - FCL_NUMBYTES;

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Clears the contents of the buffer and re-initialises the index locations.
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__FlushBuffer()
{

  FCV_01211_RXCB__DATAEND = 0;
  FCV_01211_RXCB__DATASTART = 0;

}


/*========================================================================*\
   Use :TypeConversionsFree1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets a single 16-bit INT value.
       :Index is in little endian, 0 is the LSW and 1 is the MSW
       :
       :Parameters for macro SetInt:
       :  Index : Range: 0-1
       :  Value : Range: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetInt(MX_UINT8 FCL_INDEX, MX_UINT16 FCL_VALUE)
{

  if (FCL_INDEX < 2)
  {  

    // C Code
    MX_Conv_Var.AsInt[FCL_INDEX] = FCL_VALUE;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 32-bit LONG value
       :
       :Parameters for macro SetLong:
       :  Value : Range: 0-4294967295
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetLong(MX_UINT32 FCL_VALUE)
{

  // C Code
  MX_Conv_Var.AsLong = FCL_VALUE;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 32-bit FLOAT value
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_02571_TypeConversionsFree1__GetFloat()
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  // C Code
  FCR_RETVAL = MX_Conv_Var.AsFloat;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 32-bit LONG value
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_02571_TypeConversionsFree1__GetLong()
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  // C Code
  FCR_RETVAL = MX_Conv_Var.AsLong;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 16-bit INT value
       :Index is in little endian, 0 is the LSW and 1 is the MSW
       :
       :Parameters for macro GetInt:
       :  Index : Range: 0-1
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_02571_TypeConversionsFree1__GetInt(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  if (FCL_INDEX < 2)
  {  

    // C Code
    FCR_RETVAL = MX_Conv_Var.AsInt[FCL_INDEX];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 8-bit BYTE value
       :Index is in little endian, 0 is the LSB and 3 is the MSB
       :
       :Parameters for macro SetByte:
       :  Index : Range: 0-3
       :  Value : Range: 0-255
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetByte(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_VALUE)
{

  if (FCL_INDEX < 4)
  {  

    // C Code
    MX_Conv_Var.AsByte[FCL_INDEX] = FCL_VALUE;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 8-bit BYTE value.
       :Index is in little endian, 0 is the LSB and 3 is the MSB
       :
       :Parameters for macro GetByte:
       :  Index : Range: 0-3
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02571_TypeConversionsFree1__GetByte(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX < 4)
  {  

    // C Code
    FCR_RETVAL = MX_Conv_Var.AsByte[FCL_INDEX];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 32-bit FLOAT value
       :
       :Parameters for macro SetFloat:
       :  Value : Range: 0-4294967295
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetFloat(MX_FLOAT FCL_VALUE)
{

  // C Code
  MX_Conv_Var.AsFloat = FCL_VALUE;

}


/*========================================================================*\
   Use :UART1
       :GUID: 91b64b1d-b8b2-40f1-b073-e953a91fa234
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\cal_uart.fcpx
       :Version: 25.0 (0x1300328)
       :Timestamp: 19\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_BOOL FCV_05481_UART1__RS485_STATE;
MX_GLOBAL MX_UINT32 FCV_05481_UART1__CONSOLE;

/*=----------------------------------------------------------------------=*\
   Use :Allows direct control over the TX and RTS pins
       :Also allows for reading of the state of the RX and CTS pins.
       :Only available when the UART is uninitialised.
       :
       :Parameters for macro ControlPin:
       :  Pin : 0=TX, 1=RX, 2=RTS, 3=CTS
       :  State : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__ControlPin(MX_UINT8 FCL_PIN, MX_UINT8 FCL_STATE)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  switch (FCL_PIN)
  {
    case 1:
    {

      #if (1)
        FCR_RETVAL = GET_PORT_PIN(G, 1);

      // #else
      //Code has been optimised out by the pre-processor
      #endif

      break;
    }
    case 2:
    {

      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 3:
    {

      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    default:
    {
      #if (1)
        if (FCL_STATE)
        {        

          SET_PORT_PIN(G, 0, 1);

        } else {

          SET_PORT_PIN(G, 0, 0);

        }

      // #else
      //Code has been optimised out by the pre-processor
      #endif

    }
  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Transmits a string of bytes via the UART peripheral
       :
       :Parameters for macro SendString:
       :  Data[200] : Data String to transmit
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_LEN;


  FCL_LEN = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);
  FCL_IDX = 0;

  while (FCL_IDX < FCL_LEN)
  {
    FC_CAL_UART_Send_1(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_TextConsole:
       :  Str[20] : MX_CHAR (by-ref)
       :  colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_COLOUR)
{

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :A simple macro to allow us to test the value of a single property during runtime.
       :
       :Parameters for macro TestProperty:
       :  Property : 0=UseTX, 1=UseRX, 2=UseFlowControl
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__TestProperty(MX_UINT8 FCL_PROPERTY)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_PROPERTY == 0)
  {  

    #if (1)
      FCR_RETVAL = 1;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // } else {

  }

  if (FCL_PROPERTY == 1)
  {  

    #if (1)
      FCR_RETVAL = 1;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // } else {

  }

  if (FCL_PROPERTY == 2)
  {  

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Transmits a numeric value as an ASCII string
       :
       :Parameters for macro SendNumber:
       :  Number : Numeric value to send
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__SendNumber(MX_SINT32 FCL_NUMBER)
{
  //Local variable definitions
  #define FCLsz_NUMSTR 20
  MX_CHAR FCL_NUMSTR[FCLsz_NUMSTR];


  FCI_TOSTRING(FCL_NUMBER, FCL_NUMSTR,20);

  FCD_05481_UART1__SendString(FCL_NUMSTR, FCLsz_NUMSTR);

  //Local variable definitions
  #undef FCLsz_NUMSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_SimShowWaveform:
       :  TXRX : MX_UINT8
       :  Data : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__Prv_SimShowWaveform(MX_UINT8 FCL_TXRX, MX_UINT16 FCL_DATA)
{

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Transmits an array of bytes via the UART peripheral
       :
       :Parameters for macro SendByteArray:
       :  Data[32768] : Data to transmit
       :  NumBytes : Number of bytes to send from the array
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__SendByteArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;


  FCL_IDX = 0;

  while (FCL_IDX < FCL_NUMBYTES)
  {
    FC_CAL_UART_Send_1(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Receives an array of bytes and returns the number of bytes received.
       :
       :Parameters for macro ReceiveByteArray:
       :  Data[32768] : MX_UINT8
       :  NumBytes : Maximum number of bytes to try and receive
       :  Timeout : Max amount of time in ms to wait between bytes
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__ReceiveByteArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES, MX_UINT8 FCL_TIMEOUT)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_IN;
  MX_UINT16 FCL_TOUT;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    FCL_TOUT = 256;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  FCR_RETVAL = 0;

  while (FCR_RETVAL < FCL_NUMBYTES)
  {
    FCL_IN = FC_CAL_UART_Receive_1(FCL_TIMEOUT);

    if (FCL_IN < FCL_TOUT)
    {    

      FCL_DATA[FCR_RETVAL] = FCL_IN;

      FCR_RETVAL = FCR_RETVAL + 1;

    } else {

      goto FCC_ReceiveByteArray_A;

    }

  }

FCC_ReceiveByteArray_A:
  ;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Receives a string of bytes and returns the number of bytes received.
       :
       :Parameters for macro ReceiveString:
       :  StringData[20] : MX_CHAR (by-ref)
       :  NumBytes : Maximum number of bytes to try and receive
       :  Timeout : Max amount of time in ms to wait between bytes
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__ReceiveString(MX_CHAR *FCL_STRINGDATA, MX_UINT16 FCLsz_STRINGDATA, MX_UINT16 FCL_NUMBYTES, MX_UINT8 FCL_TIMEOUT)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_IN;
  MX_UINT16 FCL_TOUT;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    FCL_TOUT = 256;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  FCR_RETVAL = 0;

  while (FCR_RETVAL < FCL_NUMBYTES)
  {
    FCL_IN = FC_CAL_UART_Receive_1(FCL_TIMEOUT);

    if (FCL_IN < FCL_TOUT)
    {    

      FCL_STRINGDATA[FCR_RETVAL] = FCL_IN;

      FCR_RETVAL = FCR_RETVAL + 1;

    } else {

      goto FCC_ReceiveString_A;

    }

  }

FCC_ReceiveString_A:
  ;

  FCL_STRINGDATA[FCR_RETVAL] = 0;

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :WidthData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb8_WidthData__FLOATFIXEDLIST 200000
#define FCVsz_00fb8_WidthData__INTFIXEDLIST 144
#define FCD_00fb8_WidthData__INTFIXEDLIST(ix) FCD_00fb8_WidthData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_WidthData__INTFIXEDLIST_LUT ROMARRAY_E =
{
7,22,45,39,64,49,7,19,19,28,39,7,23,7,23,38,22,39,38,41,38,40,38,38,38,7,7,38,39,38,38,77,55,44,52,49,44,40,56,46,8,32,49,36,57,46,57,44,57,50,47,48,46,55,81,55,54,47,15,23,15,34,48,14,40,37,38,37,40,24,37,34,7,17,36,7,59,34,40,37,37,23,36,21,34,39,59,40,37,37,23,6,23,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb8_WidthData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 144;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :ASCIIData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb7_ASCIIData__FLOATFIXEDLIST 200000
#define FCVsz_00fb7_ASCIIData__INTFIXEDLIST 34190
#define FCD_00fb7_ASCIIData__INTFIXEDLIST(ix) 0

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb7_ASCIIData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 34190;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_Font4
       :GUID: 1b08885c-807e-4631-930e-a4fef06159dc
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_Font.fcpx
       :Version: 37.0 (0x1400028)
       :Timestamp: 12\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_09e54_gLCD_Font4__OLDCHAR = (0x0);
MX_GLOBAL MX_UINT32 FCV_09e54_gLCD_Font4__OLDPOSITION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Adds up all the pixels widths before the selected character to get to the start of the pixel data
       :
       :Parameters for macro SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_09e54_gLCD_Font4__SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH;
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (1)
    #if (1) // 0 == 0
      while (FCL_CHARACTER > 0)
      {
        FCL_CHARACTER = FCL_CHARACTER - 1;

        FCL_WIDTH = FCD_00fb8_WidthData__INTFIXEDLIST(FCL_CHARACTER);

        FCR_RETVAL = FCR_RETVAL + FCL_WIDTH;

      }

      FCR_RETVAL = FCR_RETVAL * 10;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the width of the ASCII character font data
       :
       :Parameters for macro ReadWidth:
       :  Character : ASCII position so A = 'A'
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e54_gLCD_Font4__ReadWidth(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCL_PWIDTH;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 176 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0)
    //Code has been optimised out by the pre-processor
    #else
      if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 144)))
      {      

        if (FCL_CHARACTER == 32)
        {        

          FCR_RETVAL = 17;

        } else {

          //Comment:
          //Out of range,return 5 character to show the character out of range pattern

          FCR_RETVAL = 5;

        }

      } else {

        FCL_CHARACTER = FCL_CHARACTER - 33;

        FCR_RETVAL = FCD_00fb8_WidthData__INTFIXEDLIST(FCL_CHARACTER);

      }

    #endif

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Collects a stat about the selected font
       :
       :Parameters for macro ReadFontStat:
       :  Index : 0=SpaceColumns, 1=CharacterHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e54_gLCD_Font4__ReadFontStat(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX == 1)
  {  

    FCR_RETVAL = 80;

  } else {

    FCR_RETVAL = 001;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single pixel column byte from the selected ASCII character font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  Character : ASCII position so A = 'A'
       :  ByteIndex : Range: 0 to ((PixelWidth - 1) * BytesPerColumn)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e54_gLCD_Font4__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 176 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 144)))
    {    

      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 0;

      } else {

        //Comment:
        //Out of range

        FCR_RETVAL = 0xAA;

      }

    } else {

      FCL_CHARACTER = FCL_CHARACTER - 33;

      #if (0) // 0 == 1
      //Code has been optimised out by the pre-processor
      #else
        if (FCL_CHARACTER == FCV_09e54_gLCD_Font4__OLDCHAR)
        {        

          FCL_POSITION = FCV_09e54_gLCD_Font4__OLDPOSITION;

        } else {

          FCL_POSITION = FCD_09e54_gLCD_Font4__SumWidths(FCL_CHARACTER);

          FCV_09e54_gLCD_Font4__OLDPOSITION = FCL_POSITION;
          FCV_09e54_gLCD_Font4__OLDCHAR = FCL_CHARACTER;

        }

      #endif

      FCL_POSITION = FCL_POSITION + FCL_BYTEINDEX;

      FCR_RETVAL = FCD_00fb7_ASCIIData__INTFIXEDLIST(FCL_POSITION);

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :WidthData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb6_WidthData__FLOATFIXEDLIST 200000
#define FCVsz_00fb6_WidthData__INTFIXEDLIST 144
#define FCD_00fb6_WidthData__INTFIXEDLIST(ix) FCD_00fb6_WidthData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_WidthData__INTFIXEDLIST_LUT ROMARRAY_E =
{
5,16,34,29,47,37,5,14,14,20,29,5,16,5,18,28,16,29,28,30,28,29,28,28,28,5,5,29,29,29,28,56,41,33,38,36,33,29,40,34,6,24,36,27,43,34,41,33,41,37,35,34,34,41,59,39,40,34,11,18,11,25,35,11,30,28,29,28,30,18,28,26,5,12,26,5,43,26,30,28,28,17,27,16,26,29,43,30,27,28,17,5,17,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb6_WidthData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 144;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :ASCIIData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb5_ASCIIData__FLOATFIXEDLIST 200000
#define FCVsz_00fb5_ASCIIData__INTFIXEDLIST 20240
#define FCD_00fb5_ASCIIData__INTFIXEDLIST(ix) 0

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb5_ASCIIData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 20240;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_Font3
       :GUID: 1b08885c-807e-4631-930e-a4fef06159dc
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_Font.fcpx
       :Version: 37.0 (0x1400028)
       :Timestamp: 12\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_09e53_gLCD_Font3__OLDCHAR = (0x0);
MX_GLOBAL MX_UINT32 FCV_09e53_gLCD_Font3__OLDPOSITION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Adds up all the pixels widths before the selected character to get to the start of the pixel data
       :
       :Parameters for macro SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_09e53_gLCD_Font3__SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH;
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (1)
    #if (1) // 0 == 0
      while (FCL_CHARACTER > 0)
      {
        FCL_CHARACTER = FCL_CHARACTER - 1;

        FCL_WIDTH = FCD_00fb6_WidthData__INTFIXEDLIST(FCL_CHARACTER);

        FCR_RETVAL = FCR_RETVAL + FCL_WIDTH;

      }

      FCR_RETVAL = FCR_RETVAL * 8;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the width of the ASCII character font data
       :
       :Parameters for macro ReadWidth:
       :  Character : ASCII position so A = 'A'
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e53_gLCD_Font3__ReadWidth(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCL_PWIDTH;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 176 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0)
    //Code has been optimised out by the pre-processor
    #else
      if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 144)))
      {      

        if (FCL_CHARACTER == 32)
        {        

          FCR_RETVAL = 10;

        } else {

          //Comment:
          //Out of range,return 5 character to show the character out of range pattern

          FCR_RETVAL = 5;

        }

      } else {

        FCL_CHARACTER = FCL_CHARACTER - 33;

        FCR_RETVAL = FCD_00fb6_WidthData__INTFIXEDLIST(FCL_CHARACTER);

      }

    #endif

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Collects a stat about the selected font
       :
       :Parameters for macro ReadFontStat:
       :  Index : 0=SpaceColumns, 1=CharacterHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e53_gLCD_Font3__ReadFontStat(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX == 1)
  {  

    FCR_RETVAL = 59;

  } else {

    FCR_RETVAL = 2;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single pixel column byte from the selected ASCII character font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  Character : ASCII position so A = 'A'
       :  ByteIndex : Range: 0 to ((PixelWidth - 1) * BytesPerColumn)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e53_gLCD_Font3__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 176 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 144)))
    {    

      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 0;

      } else {

        //Comment:
        //Out of range

        FCR_RETVAL = 0xAA;

      }

    } else {

      FCL_CHARACTER = FCL_CHARACTER - 33;

      #if (0) // 0 == 1
      //Code has been optimised out by the pre-processor
      #else
        if (FCL_CHARACTER == FCV_09e53_gLCD_Font3__OLDCHAR)
        {        

          FCL_POSITION = FCV_09e53_gLCD_Font3__OLDPOSITION;

        } else {

          FCL_POSITION = FCD_09e53_gLCD_Font3__SumWidths(FCL_CHARACTER);

          FCV_09e53_gLCD_Font3__OLDPOSITION = FCL_POSITION;
          FCV_09e53_gLCD_Font3__OLDCHAR = FCL_CHARACTER;

        }

      #endif

      FCL_POSITION = FCL_POSITION + FCL_BYTEINDEX;

      FCR_RETVAL = FCD_00fb5_ASCIIData__INTFIXEDLIST(FCL_POSITION);

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :WidthData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb4_WidthData__FLOATFIXEDLIST 200000
#define FCVsz_00fb4_WidthData__INTFIXEDLIST 94
#define FCD_00fb4_WidthData__INTFIXEDLIST(ix) FCD_00fb4_WidthData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_WidthData__INTFIXEDLIST_LUT ROMARRAY_E =
{
3,9,17,16,25,19,3,8,8,10,15,3,9,3,9,16,8,16,16,17,16,16,16,16,16,3,3,15,15,15,16,30,21,17,20,19,17,15,22,18,3,13,20,14,23,18,22,17,22,19,18,19,18,21,33,21,21,19,6,9,6,12,19,6,15,15,15,15,15,10,15,14,3,6,14,3,23,14,15,15,15,9,15,8,14,15,23,15,15,15,9,2,9,16
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb4_WidthData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 94;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :ASCIIData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb3_ASCIIData__FLOATFIXEDLIST 200000
#define FCVsz_00fb3_ASCIIData__INTFIXEDLIST 5368
#define FCD_00fb3_ASCIIData__INTFIXEDLIST(ix) 0

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb3_ASCIIData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 5368;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_Font2
       :GUID: 1b08885c-807e-4631-930e-a4fef06159dc
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_Font.fcpx
       :Version: 37.0 (0x1400028)
       :Timestamp: 12\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_09e52_gLCD_Font2__OLDCHAR = (0x0);
MX_GLOBAL MX_UINT32 FCV_09e52_gLCD_Font2__OLDPOSITION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Adds up all the pixels widths before the selected character to get to the start of the pixel data
       :
       :Parameters for macro SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_09e52_gLCD_Font2__SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH;
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (1)
    #if (1) // 0 == 0
      while (FCL_CHARACTER > 0)
      {
        FCL_CHARACTER = FCL_CHARACTER - 1;

        FCL_WIDTH = FCD_00fb4_WidthData__INTFIXEDLIST(FCL_CHARACTER);

        FCR_RETVAL = FCR_RETVAL + FCL_WIDTH;

      }

      FCR_RETVAL = FCR_RETVAL * 4;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the width of the ASCII character font data
       :
       :Parameters for macro ReadWidth:
       :  Character : ASCII position so A = 'A'
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e52_gLCD_Font2__ReadWidth(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCL_PWIDTH;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (0) // 255 < 255
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0)
    //Code has been optimised out by the pre-processor
    #else
      if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 94)))
      {      

        if (FCL_CHARACTER == 32)
        {        

          FCR_RETVAL = 6;

        } else {

          //Comment:
          //Out of range,return 5 character to show the character out of range pattern

          FCR_RETVAL = 5;

        }

      } else {

        FCL_CHARACTER = FCL_CHARACTER - 33;

        FCR_RETVAL = FCD_00fb4_WidthData__INTFIXEDLIST(FCL_CHARACTER);

      }

    #endif

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Collects a stat about the selected font
       :
       :Parameters for macro ReadFontStat:
       :  Index : 0=SpaceColumns, 1=CharacterHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e52_gLCD_Font2__ReadFontStat(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX == 1)
  {  

    FCR_RETVAL = 32;

  } else {

    FCR_RETVAL = 001;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single pixel column byte from the selected ASCII character font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  Character : ASCII position so A = 'A'
       :  ByteIndex : Range: 0 to ((PixelWidth - 1) * BytesPerColumn)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e52_gLCD_Font2__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (0) // 255 < 255
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 94)))
    {    

      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 0;

      } else {

        //Comment:
        //Out of range

        FCR_RETVAL = 0xAA;

      }

    } else {

      FCL_CHARACTER = FCL_CHARACTER - 33;

      #if (0) // 0 == 1
      //Code has been optimised out by the pre-processor
      #else
        if (FCL_CHARACTER == FCV_09e52_gLCD_Font2__OLDCHAR)
        {        

          FCL_POSITION = FCV_09e52_gLCD_Font2__OLDPOSITION;

        } else {

          FCL_POSITION = FCD_09e52_gLCD_Font2__SumWidths(FCL_CHARACTER);

          FCV_09e52_gLCD_Font2__OLDPOSITION = FCL_POSITION;
          FCV_09e52_gLCD_Font2__OLDCHAR = FCL_CHARACTER;

        }

      #endif

      FCL_POSITION = FCL_POSITION + FCL_BYTEINDEX;

      FCR_RETVAL = FCD_00fb3_ASCIIData__INTFIXEDLIST(FCL_POSITION);

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :WidthData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb2_WidthData__FLOATFIXEDLIST 200000
#define FCVsz_00fb2_WidthData__INTFIXEDLIST 95
#define FCD_00fb2_WidthData__INTFIXEDLIST(ix) FCD_00fb2_WidthData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_WidthData__INTFIXEDLIST_LUT ROMARRAY_E =
{
1,3,8,7,10,8,1,3,3,5,7,1,4,1,4,6,3,6,6,7,6,6,6,6,6,1,1,6,6,6,6,13,9,7,8,8,7,7,9,7,1,5,8,7,9,7,9,7,9,8,7,7,7,9,13,8,9,8,2,4,2,5,8,2,6,6,5,6,6,4,6,6,1,2,6,1,9,6,6,6,6,4,5,4,6,7,9,6,7,6,3,1,3,7,7
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb2_WidthData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 95;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :ASCIIData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1_ASCIIData__FLOATFIXEDLIST 200000
#define FCVsz_00fb1_ASCIIData__INTFIXEDLIST 1098
#define FCD_00fb1_ASCIIData__INTFIXEDLIST(ix) FCD_00fb1_ASCIIData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCIIData__INTFIXEDLIST_LUT ROMARRAY_E =
{
0xFE,0x14,0x1E,0x00,0x1E,0x00,0x00,0x00,0x90,0x90,0xF8,0x96,0x90,0xF8,0x96,0x90,0x00,0x1C,0x00,0x00,0x1C,0x00,0x00,0x00,0x18,0x24,0x22,0xFF,0x42,0x42,0x84,0x08,0x10,0x10,0x3C,0x10,0x08,0x04,0x1C,0x22,0x22,0x1C,0xC0,0x30,0x8C,0x42,0x40,0x80,0x00,0x00,0x10,0x0C,0x00,0x00,0x0C,0x10,0x10,0x0C,0x80,0x5C,0x22,0x62,0x92,0x0C,0x80,0x00,0x0C,0x10,0x10,0x10,0x10,0x0C,0x08,0x10,0x1E,0x00,0xF0,0x0C,0x02,0x1C,0x60,0x80,0x02,0x0C,0xF0,0x80,0x60,0x1C,0x04,0x14,0x0E,0x14,0x04,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0xF8,0x40,0x40,0x40,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,0x70,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0xC0,0x38,0x06,0x18,0x04,0x00,0x00,0xFC,0x02,0x02,0x02,0x02,0xFC,0x0C,0x10,0x10,0x10,0x10,0x0C,0x08,0x04,0xFE,0x00,0x00,0x1C,0x0C,0x02,0x02,0x82,0x42,0x3C,0x10,0x18,0x14,0x10,0x10,0x10,0x0C,0x02,0x22,0x22,0x22,0xDC,0x0C,0x10,0x10,0x10,0x10,0x0C,0x80,0x40,0x30,0x08,0x04,0xFE,0x00,0x04,0x04,0x04,0x04,0x04,0x1C,0x04,0x38,0x16,0x12,0x12,0x12,0xE2,0x0C,0x10,0x10,0x10,0x18,0x04,0xF8,0x44,0x22,0x22,0x22,0xC4,0x0C,0x10,0x10,0x10,0x10,0x0C,0x02,0x02,0x02,0xE2,0x1A,0x06,0x00,0x00,0x1C,0x00,0x00,0x00,0xDC,0x22,0x22,0x22,0x22,0xDC,0x0C,0x10,0x10,0x10,0x10,0x0C,0x3C,0x42,0x42,0x42,0x22,0xFC,0x08,0x10,0x10,0x10,0x08,0x04,0x08,0x10,0x08,0x70,0x40,0xA0,0xA0,0x10,0x10,0x08,0x00,0x00,0x00,0x04,0x04,0x08,0x90,0x90,0x90,0x90,0x90,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x10,0x10,0xA0,0xA0,0x40,0x08,0x04,0x04,0x00,0x00,0x00,0x0C,0x02,0x82,0x42,0x22,0x1C,0x00,0x00,0x14,0x00,0x00,0x00,0xE0,0x18,0x04,0xC4,0x22,0x12,0x12,0x12,0xA2,0x72,0x04,0x08,0xF0,0x0C,0x30,0x40,0x4C,0x90,0x90,0x90,0x88,0x9C,0x90,0x50,0x4C,0x20,0x00,0x80,0xE0,0x9C,0x82,0x9C,0xE0,0x80,0x00,0x18,0x04,0x00,0x00,0x00,0x00,0x00,0x04,0x18,0xFE,0x22,0x22,0x22,0x22,0x22,0xDC,0x1C,0x10,0x10,0x10,0x10,0x10,0x0C,0xF8,0x04,0x02,0x02,0x02,0x02,0x04,0x08,0x04,0x08,0x10,0x10,0x10,0x10,0x08,0x04,0xFE,0x02,0x02,0x02,0x02,0x02,0x04,0xF8,0x1C,0x10,0x10,0x10,0x10,0x10,0x08,0x04,0xFE,0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x10,0x10,0x10,0x10,0x10,0x10,0xFE,0x22,0x22,0x22,0x22,0x22,0x02,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x04,0x02,0x02,0x02,0x42,0x42,0x44,0xC8,0x04,0x08,0x10,0x10,0x10,0x10,0x10,0x08,0x04,0xFE,0x20,0x20,0x20,0x20,0x20,0xFE,0x1C,0x00,0x00,0x00,0x00,0x00,0x1C,0xFE,0x1C,0x00,0x00,0x00,0x00,0xFE,0x0C,0x10,0x10,0x10,0x0C,0xFE,0x80,0x40,0x20,0x50,0x88,0x04,0x02,0x1C,0x00,0x00,0x00,0x00,0x04,0x08,0x10,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x10,0x10,0x10,0x10,0x10,0x10,0xFE,0x0C,0x30,0xC0,0x00,0xC0,0x30,0x0C,0xFE,0x1C,0x00,0x00,0x04,0x18,0x04,0x00,0x00,0x1C,0xFE,0x04,0x18,0x60,0x80,0x00,0xFE,0x1C,0x00,0x00,0x00,0x04,0x08,0x1C,0xF8,0x04,0x02,0x02,0x02,0x02,0x02,0x04,0xF8,0x04,0x08,0x10,0x10,0x10,0x10,0x10,0x08,0x04,0xFE,0x42,0x42,0x42,0x42,0x42,0x3C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x04,0x02,0x02,0x02,0x02,0x02,0x04,0xF8,0x04,0x08,0x10,0x10,0x10,0x14,0x08,0x1C,0x10,0xFE,0x42,0x42,0x42,0xC2,0x42,0x42,0x3C,0x1C,0x00,0x00,0x00,0x00,0x04,0x08,0x10,0x1C,0x22,0x22,0x22,0x42,0x42,0x8C,0x0C,0x10,0x10,0x10,0x10,0x10,0x0C,0x02,0x02,0x02,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0xFE,0x04,0x08,0x10,0x10,0x10,0x08,0x04,0x06,0x18,0x60,0x80,0x00,0x80,0x60,0x18,0x06,0x00,0x00,0x00,0x04,0x18,0x04,0x00,0x00,0x00,0x06,0x38,0xC0,0x00,0xC0,0x3C,0x02,0x3C,0xC0,0x00,0xC0,0x38,0x06,0x00,0x00,0x04,0x18,0x04,0x00,0x00,0x00,0x04,0x18,0x04,0x00,0x00,0x02,0x0C,0x90,0x60,0x60,0x90,0x0C,0x02,0x10,0x0C,0x00,0x00,0x00,0x04,0x0C,0x10,0x02,0x04,0x18,0x20,0xC0,0x20,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x02,0x82,0x42,0x22,0x1A,0x06,0x02,0x10,0x18,0x14,0x10,0x10,0x10,0x10,0x10,0xFE,0x02,0xFC,0x80,0x06,0x38,0xC0,0x00,0x00,0x00,0x04,0x18,0x02,0xFE,0x80,0xFC,0x20,0x1C,0x02,0x1C,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x02,0x04,0x00,0x00,0x10,0x88,0x48,0x48,0x48,0xF0,0x0C,0x10,0x10,0x10,0x08,0x1C,0xFE,0x10,0x08,0x08,0x08,0xF0,0x1C,0x08,0x10,0x10,0x10,0x0C,0xF0,0x08,0x08,0x08,0x10,0x0C,0x10,0x10,0x10,0x08,0xF0,0x08,0x08,0x08,0x10,0xFE,0x0C,0x10,0x10,0x10,0x08,0x1C,0xF0,0x48,0x48,0x48,0x48,0x70,0x0C,0x10,0x10,0x10,0x10,0x08,0x08,0xFC,0x0A,0x0A,0x00,0x1C,0x00,0x00,0xF0,0x08,0x08,0x08,0x10,0xF8,0x4C,0x90,0x90,0x90,0x88,0x7C,0xFE,0x10,0x08,0x08,0x08,0xF0,0x1C,0x00,0x00,0x00,0x00,0x1C,0xFA,0x1C,0x00,0xFA,0x80,0x7C,0xFE,0x80,0x40,0xA0,0x10,0x08,0x1C,0x00,0x00,0x00,0x0C,0x10,0xFE,0x1C,0xF8,0x10,0x08,0x08,0xF0,0x10,0x08,0x08,0xF0,0x1C,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x1C,0xF8,0x10,0x08,0x08,0x08,0xF0,0x1C,0x00,0x00,0x00,0x00,0x1C,0xF0,0x08,0x08,0x08,0x08,0xF0,0x0C,0x10,0x10,0x10,0x10,0x0C,0xF8,0x10,0x08,0x08,0x08,0xF0,0xFC,0x08,0x10,0x10,0x10,0x0C,0xF0,0x08,0x08,0x08,0x10,0xF8,0x0C,0x10,0x10,0x10,0x08,0xFC,0xF8,0x10,0x08,0x08,0x1C,0x00,0x00,0x00,0x30,0x48,0x48,0x48,0x90,0x08,0x10,0x10,0x10,0x0C,0x08,0xFE,0x08,0x08,0x00,0x1C,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0xF8,0x0C,0x10,0x10,0x10,0x08,0x1C,0x18,0x60,0x80,0x00,0x80,0x60,0x18,0x00,0x00,0x04,0x18,0x04,0x00,0x00,0x18,0xE0,0x00,0xE0,0x18,0xE0,0x00,0xE0,0x18,0x00,0x04,0x18,0x04,0x00,0x04,0x18,0x04,0x00,0x08,0x30,0xC0,0xC0,0x30,0x08,0x10,0x0C,0x00,0x00,0x0C,0x10,0x18,0x60,0x80,0x00,0x80,0x60,0x18,0x00,0x80,0x8C,0x70,0x0C,0x00,0x00,0x08,0x08,0x88,0x68,0x18,0x08,0x10,0x18,0x14,0x10,0x10,0x10,0x80,0x7C,0x02,0x00,0x7C,0x80,0xFE,0xFC,0x02,0x7C,0x80,0x80,0x7C,0x00,0x40,0x20,0x20,0x60,0x40,0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x04,0x04,0x04,0x04,0x04,0xFC,0x1C,0x10,0x10,0x10,0x10,0x10,0x1C
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 1098;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_Font1
       :GUID: 1b08885c-807e-4631-930e-a4fef06159dc
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_Font.fcpx
       :Version: 37.0 (0x1400028)
       :Timestamp: 12\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_09e51_gLCD_Font1__OLDCHAR = (0x0);
MX_GLOBAL MX_UINT32 FCV_09e51_gLCD_Font1__OLDPOSITION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Adds up all the pixels widths before the selected character to get to the start of the pixel data
       :
       :Parameters for macro SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_09e51_gLCD_Font1__SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH;
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (1)
    #if (1) // 0 == 0
      while (FCL_CHARACTER > 0)
      {
        FCL_CHARACTER = FCL_CHARACTER - 1;

        FCL_WIDTH = FCD_00fb2_WidthData__INTFIXEDLIST(FCL_CHARACTER);

        FCR_RETVAL = FCR_RETVAL + FCL_WIDTH;

      }

      FCR_RETVAL = FCR_RETVAL * 2;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the width of the ASCII character font data
       :
       :Parameters for macro ReadWidth:
       :  Character : ASCII position so A = 'A'
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadWidth(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCL_PWIDTH;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (0) // 255 < 255
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0)
    //Code has been optimised out by the pre-processor
    #else
      if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 95)))
      {      

        if (FCL_CHARACTER == 32)
        {        

          FCR_RETVAL = 5;

        } else {

          //Comment:
          //Out of range,return 5 character to show the character out of range pattern

          FCR_RETVAL = 5;

        }

      } else {

        FCL_CHARACTER = FCL_CHARACTER - 33;

        FCR_RETVAL = FCD_00fb2_WidthData__INTFIXEDLIST(FCL_CHARACTER);

      }

    #endif

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Collects a stat about the selected font
       :
       :Parameters for macro ReadFontStat:
       :  Index : 0=SpaceColumns, 1=CharacterHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadFontStat(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX == 1)
  {  

    FCR_RETVAL = 14;

  } else {

    FCR_RETVAL = 001;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single pixel column byte from the selected ASCII character font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  Character : ASCII position so A = 'A'
       :  ByteIndex : Range: 0 to ((PixelWidth - 1) * BytesPerColumn)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (0) // 255 < 255
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 95)))
    {    

      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 0;

      } else {

        //Comment:
        //Out of range

        FCR_RETVAL = 0xAA;

      }

    } else {

      FCL_CHARACTER = FCL_CHARACTER - 33;

      #if (0) // 0 == 1
      //Code has been optimised out by the pre-processor
      #else
        if (FCL_CHARACTER == FCV_09e51_gLCD_Font1__OLDCHAR)
        {        

          FCL_POSITION = FCV_09e51_gLCD_Font1__OLDPOSITION;

        } else {

          FCL_POSITION = FCD_09e51_gLCD_Font1__SumWidths(FCL_CHARACTER);

          FCV_09e51_gLCD_Font1__OLDPOSITION = FCL_POSITION;
          FCV_09e51_gLCD_Font1__OLDCHAR = FCL_CHARACTER;

        }

      #endif

      FCL_POSITION = FCL_POSITION + FCL_BYTEINDEX;

      FCR_RETVAL = FCD_00fb1_ASCIIData__INTFIXEDLIST(FCL_POSITION);

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :Base_GLCD
       :GUID: 4384cba9-0bea-4359-8c5b-dcd046aa7778
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Base_GLCD.fcpx
       :Version: 53.0 (0x2300028)
       :Timestamp: 08\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME2 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME1 13
#define FCVsz_0ba71_Base_GLCD__SPACEWIDTH 4
#define FCVsz_0ba71_Base_GLCD__FONTHEADER 16
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME8 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME7 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME6 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME5 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME4 13
#define FCVsz_0ba71_Base_GLCD__CHARSPACING 4
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME3 13

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0ba71_Base_GLCD__Prv_SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH = (0x0);
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the number of pixel columns used in the selected font
       :
       :Parameters for macro ReadFontWidth:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character to get the pixel width e.g. 'A' or 65
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadFontWidth(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 4)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadWidth(FCL_CHARACTER);

    // } else {

    }

    #if (1) // 4 > 1
      if (FCL_FONT == 1)
      {      

        FCR_RETVAL = FCD_09e52_gLCD_Font2__ReadWidth(FCL_CHARACTER);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (1) // 4 > 2
      if (FCL_FONT == 2)
      {      

        FCR_RETVAL = FCD_09e53_gLCD_Font3__ReadWidth(FCL_CHARACTER);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (1) // 4 > 3
      if (FCL_FONT == 3)
      {      

        FCR_RETVAL = FCD_09e54_gLCD_Font4__ReadWidth(FCL_CHARACTER);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 4 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_ReadFontFileHeader:
       :  Font : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Prv_ReadFontFileHeader(MX_UINT8 FCL_FONT)
{
  //Local variable definitions
  MX_UINT8 FCL_RETVAL = (0x0);
  MX_UINT8 FCL_IDX = (0x0);
  #define FCLsz_TEST 20
  MX_CHAR FCL_TEST[FCLsz_TEST] = "";


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_TEST
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a stat from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontStat:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Index : 0=SpaceWidth, 1=PixelHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadFontStat(MX_UINT8 FCL_FONT, MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 4)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    //Comment:
    //Character Spacing comes from font component properties
    //specified by the user and independent of the font file.

    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadFontStat(FCL_INDEX);

    // } else {

    }

    #if (1) // 4 > 1
      if (FCL_FONT == 1)
      {      

        FCR_RETVAL = FCD_09e52_gLCD_Font2__ReadFontStat(FCL_INDEX);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (1) // 4 > 2
      if (FCL_FONT == 2)
      {      

        FCR_RETVAL = FCD_09e53_gLCD_Font3__ReadFontStat(FCL_INDEX);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (1) // 4 > 3
      if (FCL_FONT == 3)
      {      

        FCR_RETVAL = FCD_09e54_gLCD_Font4__ReadFontStat(FCL_INDEX);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 4 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows one of the default external font files to be switched out for a different font file.
       :
       :Parameters for macro SetExternalFont:
       :  Font : Range: 0 to (FontCount - 1)
       :  Filename[20] : New font filename
       :  CharacterSpacing : Number of pixel columns to use between each character
       :  SpaceWidth : Number of pixel columns to use for a space character
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetExternalFont(MX_UINT8 FCL_FONT, MX_CHAR *PFCL_FILENAME, MX_UINT8 FCL_CHARACTERSPACING, MX_UINT8 FCL_SPACEWIDTH)
{
  #define FCLsz_FILENAME 20
  MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
  FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontByte:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character for example 'A' or 65
       :  ByteIndex : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadFontByte(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 4)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0) // (0) && (FCL_CHARACTER != ' ')
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadASCIILUT(FCL_CHARACTER, FCL_BYTEINDEX);

    // } else {

    }

    #if (1) // 4 > 1
      if (FCL_FONT == 1)
      {      

        FCR_RETVAL = FCD_09e52_gLCD_Font2__ReadASCIILUT(FCL_CHARACTER, FCL_BYTEINDEX);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (1) // 4 > 2
      if (FCL_FONT == 2)
      {      

        FCR_RETVAL = FCD_09e53_gLCD_Font3__ReadASCIILUT(FCL_CHARACTER, FCL_BYTEINDEX);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (1) // 4 > 3
      if (FCL_FONT == 3)
      {      

        FCR_RETVAL = FCD_09e54_gLCD_Font4__ReadASCIILUT(FCL_CHARACTER, FCL_BYTEINDEX);

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 4 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 4 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  return (FCR_RETVAL);

}

#define FCA_GLCD_EB3 0x29f1
#define FCV_GLCD_EB3 0x0465

/*========================================================================*\
   Use :gLCD_EB3
       :GUID: ac3375c7-acf3-4160-8c3e-3011735116aa
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_EB3.fcpx
       :Version: 25.0 (0x100028)
       :Timestamp: 15\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_029f1_gLCD_EB3__TOUCHCOORDS 2
#define FCVsz_029f1_gLCD_EB3__COMMANDTX 20
#define FCV_029f1_gLCD_EB3__TIMEOUT (0x64)
MX_GLOBAL MX_UINT16 FCV_029f1_gLCD_EB3__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_029f1_gLCD_EB3__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_029f1_gLCD_EB3__RXCOUNT;
MX_GLOBAL MX_SINT16 FCV_029f1_gLCD_EB3__TOUCHCOORDS[FCVsz_029f1_gLCD_EB3__TOUCHCOORDS] = {-1, -1};
MX_GLOBAL MX_BOOL FCV_029f1_gLCD_EB3__SIMTOUCHED = (0);
MX_GLOBAL MX_UINT8 FCV_029f1_gLCD_EB3__COMMANDTX[FCVsz_029f1_gLCD_EB3__COMMANDTX];
MX_GLOBAL MX_UINT8 FCV_029f1_gLCD_EB3__TXCOUNT = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__ReceiveReply()
{
  //Local variable definitions
  MX_UINT8 FCL_RETRY = (0x32);
  MX_UINT8 FCL_RXDONE = (0x0);
  MX_UINT8 FCL_RXMODE = (0x0);
  MX_UINT16 FCL_RX;
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Receive Command Reply

  FCD_01211_RXCB__FlushBuffer();

  FCR_RETVAL = 0;

  while (FCL_RXDONE == 0)
  {
    FCL_RX = FC_CAL_UART_Receive_1(FCV_029f1_gLCD_EB3__TIMEOUT);

    if (FCL_RX > 255)
    {    

      if (FCL_RETRY == 0)
      {      

        FCL_RXDONE = 1;

      } else {

        FCL_RETRY = FCL_RETRY - 1;

      }

    } else {

      if (FCL_RXMODE == 0)
      {      

        if (FCL_RX == ':')
        {        

          FCL_RXMODE = 1;

        // } else {

        }

      } else {

        if (FCL_RXMODE == 1)
        {        

          if (FCL_RX == FCV_029f1_gLCD_EB3__COMMANDTX[0])
          {          

            FCL_RXMODE = 2;

          } else {

            FCL_RXMODE = 0;

          }

        } else {

          FCD_01211_RXCB__PutByte(FCL_RX);

          FCR_RETVAL = FCR_RETVAL + 1;

          FCL_RXDONE = FCD_01211_RXCB__LookForValue(";\n", 3, 2, 0, 0);

        }

      }

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__ConnectWifi()
{
  //Local variable definitions
  #define FCLsz_RX 4
  MX_UINT8 FCL_RX[FCLsz_RX];
  MX_UINT8 FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'e';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'g';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 1;

  FCD_029f1_gLCD_EB3__SendCommandWithDualString("", 1, "", 1);

  FCR_RETVAL = FCD_01211_RXCB__GetByte();

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_RX
}

/*=----------------------------------------------------------------------=*\
   Use :Allows the fonts to be scaled up by multiplying the number of pixels on the X and Y.
       :
       :Parameters for macro SetFontScaler:
       :  ScaleX : Sets the horizontal scale of the font, default 1
       :  ScaleY : Sets the vertical scale of the font, default 1
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetFontScaler(MX_UINT8 FCL_SCALEX, MX_UINT8 FCL_SCALEY)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '6';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_SCALEX;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_SCALEY;
  FCV_029f1_gLCD_EB3__TXCOUNT = 3;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a bitmap image loaded from the SD card scaled to the defined width and height.
       :FileInit must be called first to ensure the File System is setup.
       :
       :Parameters for macro DrawBitmapScaled:
       :  Filename[20] : Bitmap file to open from current directory on SD card 8.3 format
       :  X1 : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y1 : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Width : The dimension to draw the bitmap in pixels
       :  Height : The dimension to draw the bitmap in pixels
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__DrawBitmapScaled(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '9';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_WIDTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_WIDTH >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_HEIGHT;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_HEIGHT >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_ORIENTATION;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_TRANSPARENCY;
  FCV_029f1_gLCD_EB3__COMMANDTX[11] = FCL_FLIP;
  FCV_029f1_gLCD_EB3__TXCOUNT = 12;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_FILENAME, FCLsz_FILENAME);

  FCR_RETVAL = FCD_01211_RXCB__GetByte();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommand()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SendCommandWithArray:
       :  Data[1000] : MX_UINT8
       :  Count : MX_UINT16
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommandWithArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_COUNT)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FCD_05481_UART1__SendByteArray(FCL_DATA, 1000, FCL_COUNT);

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function to transfer the display manager edits through to the web mirror.
       :
       :Parameters for macro SendBinaryAction:
       :  Data[60] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SendBinaryAction(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '.';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_DATA, FCLsz_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Parameters for macro PrintNumber:
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Selects which Font to use Range: 0 to Font Count
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
  //Local variable definitions
  #define FCLsz_TEMP 8
  MX_CHAR FCL_TEMP[FCLsz_TEMP];


  FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,8);

  FCD_029f1_gLCD_EB3__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

  //Local variable definitions
  #undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
  //Local variable definitions
  MX_SINT16 FCL_C1;
  MX_SINT16 FCL_M1;
  MX_SINT16 FCL_D1 = (0);
  MX_SINT16 FCL_PIXELX;
  MX_SINT16 FCL_PIXELY;
  MX_SINT16 FCL_YINC = (1);
  MX_SINT16 FCL_XINC = (1);
  MX_BOOL FCL_STRAIGHT = (0);


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'E';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_X2;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_X2 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_Y2;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_Y2 >> 8;
  FCV_029f1_gLCD_EB3__TXCOUNT = 9;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Adjusts the brightness of the backlight.
       :
       :Parameters for macro BacklightBrightness:
       :  Brightness : Range: 0 - 255, 0=Off, 255=Max
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__BacklightBrightness(MX_UINT8 FCL_BRIGHTNESS)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'J';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_BRIGHTNESS;
  FCV_029f1_gLCD_EB3__TXCOUNT = 2;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Checks to see if the screen has been touched.
       :Returns 1 for a new valid touch and 0 for no touch.
       :
       :Parameters for macro TouchReadCoord:
       :  Axis : 0=X, 1=Y
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_029f1_gLCD_EB3__TouchReadCoord(MX_UINT8 FCL_AXIS)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  if (FCL_AXIS < 2)
  {  

    FCR_RETVAL = FCV_029f1_gLCD_EB3__TOUCHCOORDS[FCL_AXIS];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse object on the display with the center of the ellipse at the location X,Y
       :
       :Parameters for macro DrawEllipse:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  XRadius : Radius of the circle on the X axis specified in pixels
       :  YRadius : Radius of the circle on the Y axis specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

  FCL_X = FCL_X - FCL_XRADIUS;
  FCL_Y = FCL_Y - FCL_YRADIUS;
  FCL_XRADIUS = FCL_XRADIUS << 1;
  FCL_YRADIUS = FCL_YRADIUS << 1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'y';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_XRADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_XRADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_YRADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_YRADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 11;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'z';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__TXCOUNT = 5;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at current pixel location.
       :Not compatible with orientations other than 0.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__FastPlot()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a bitmap image loaded from the SD card
       :FileInit must be called first to ensure the File System is setup.
       :
       :Parameters for macro DrawQRCode:
       :  X1 : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y1 : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Scaler : Size of each block in pixels: 1=33x33, 2=66x66, 3=99x99, etc
       :  Text[20] : Data to embed into the QR code. e.g. "www.myURL.com"
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawQRCode(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_SCALER, MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '5';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_SCALER;
  FCV_029f1_gLCD_EB3__TXCOUNT = 6;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_TEXT, FCLsz_TEXT);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT16 FCL_STARTANGLE, MX_UINT16 FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 's';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_STARTANGLE;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_STARTANGLE >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_ENDANGLE;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_ENDANGLE >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[11] = FCL_RESOLUTION;
  FCV_029f1_gLCD_EB3__COMMANDTX[12] = FCL_RESOLUTION >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[13] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[14] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 15;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Parameters for macro SetDisplayOrientation:
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'K';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_ORIENTATION;
  FCV_029f1_gLCD_EB3__TXCOUNT = 2;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns the colour to use as the transparent mask. 
       :Anything in this specific colour will not be drawn when the DrawBitmap->Transparent parameter is set.
       :
       :Parameters for macro SetBitmapTransparency:
       :  R : Colour channel. Range: 0 to 255
       :  G : Colour channel. Range: 0 to 255
       :  B : Colour channel. Range: 0 to 255
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetBitmapTransparency(MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'S';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_R;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_G;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_B;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a bitmap image loaded from the SD card
       :FileInit must be called first to ensure the File System is setup.
       :
       :Parameters for macro DrawBitmap:
       :  Filename[20] : Bitmap file to open from current directory on SD card 8.3 format
       :  X1 : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y1 : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__DrawBitmap(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'R';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_ORIENTATION;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_TRANSPARENCY;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_FLIP;
  FCV_029f1_gLCD_EB3__TXCOUNT = 8;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_FILENAME, FCLsz_FILENAME);

  FCR_RETVAL = FCD_01211_RXCB__GetByte();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a floating point number to the Graphical LCD.
       :
       :Parameters for macro PrintFloat:
       :  Number : Floating point number to send to the display.
       :  NumDP : Number of decimal points
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Selects which Font to use Range: 0 to Font Count
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_NUMDP, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
  //Local variable definitions
  #define FCLsz_TEMP 8
  MX_CHAR FCL_TEMP[FCLsz_TEMP];


  FCI_FLOAT_TO_STRING(FCL_NUMBER, FCL_NUMDP, FCL_TEMP, FCLsz_TEMP);

  FCD_029f1_gLCD_EB3__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

  //Local variable definitions
  #undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SendCommandWithString:
       :  Str[20] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommandWithString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FCD_05481_UART1__SendString(FCL_STR, FCLsz_STR);

  FC_CAL_UART_Send_1('\0');

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Window:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;


}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Parameters for macro Print:
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Selects which Font to use Range: 0 to Font Count
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'G';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_FONT;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = 0;
  FCV_029f1_gLCD_EB3__TXCOUNT = 8;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_STR, FCLsz_STR);

}

/*=----------------------------------------------------------------------=*\
   Use :Checks to see if the screen has been touched.
       :Returns 1 for a new valid touch and 0 for no touch.
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_029f1_gLCD_EB3__TouchCheck()
{
  //Local variable definitions
  #define FCLsz_RX 4
  MX_UINT8 FCL_RX[FCLsz_RX];
  MX_BOOL FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'O';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 4;

  FCD_029f1_gLCD_EB3__SendCommand();

  FCD_01211_RXCB__GetArray(FCL_RX, 4, 4);

  FCV_029f1_gLCD_EB3__TOUCHCOORDS[0] = FCL_RX[0] | (FCL_RX[1] << 8);
  FCV_029f1_gLCD_EB3__TOUCHCOORDS[1] = FCL_RX[2] | (FCL_RX[3] << 8);

  if ((FCV_029f1_gLCD_EB3__TOUCHCOORDS[0] >= 0) && (FCV_029f1_gLCD_EB3__TOUCHCOORDS[1] >= 0))
  {  

    FCR_RETVAL = 1;

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_RX
}

/*=----------------------------------------------------------------------=*\
   Use :This macro overrides the default font with a substitute font file. 
       :The binary font file must be placed onto the SD card inside the Fonts folder.
       :
       :Parameters for macro SetExternalFont:
       :  Font : Selects which Font to override Range: 0 to (Font Count - 1)
       :  Str[13] : Binary font file to use in standard 8.3 file format
       :  CharacterSpacing : Number of pixel columns added in between each character
       :  SpaceWidth : Number of pixel columns used for a space character
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetExternalFont(MX_UINT8 FCL_FONT, MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_CHARACTERSPACING, MX_UINT8 FCL_SPACEWIDTH)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '+';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_FONT;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_CHARACTERSPACING;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_SPACEWIDTH;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_STR, FCLsz_STR);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SendCommandWithDualString:
       :  Str1[20] : MX_CHAR (by-ref)
       :  Str2[20] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommandWithDualString(MX_CHAR *FCL_STR1, MX_UINT16 FCLsz_STR1, MX_CHAR *FCL_STR2, MX_UINT16 FCLsz_STR2)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FCD_05481_UART1__SendString(FCL_STR1, FCLsz_STR1);

  FC_CAL_UART_Send_1('\0');

  FCD_05481_UART1__SendString(FCL_STR2, FCLsz_STR2);

  FC_CAL_UART_Send_1('\0');

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function to transfer the binary scene through to the web mirror.
       :
       :Parameters for macro SendBinaryScene:
       :  Data[2048] : Binary scene data
       :  Length : Number of bytes to send
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SendBinaryScene(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_LENGTH)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '-';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_LENGTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_LENGTH >> 8;
  FCV_029f1_gLCD_EB3__TXCOUNT = 3;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithArray(FCL_DATA, 2048, FCL_LENGTH);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__ClearDisplay()
{
  //Local variable definitions
  MX_UINT16 FCL_Y = (0x0);
  MX_UINT16 FCL_X = (0x0);
  MX_UINT8 FCL_ORIENTATIONSAVE;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'D';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetBackgroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'C';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_RED;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_GREEN;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_BLUE;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

  FCL_X = FCL_X - FCL_RADIUS;
  FCL_Y = FCL_Y - FCL_RADIUS;
  FCL_RADIUS = FCL_RADIUS << 1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'y';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 11;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_UINT16 FCL_HEIGHT;
  MX_UINT16 FCL_WIDTH;


  FCL_WIDTH = FCL_X2 - FCL_X1;
  FCL_HEIGHT = FCL_Y2 - FCL_Y1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 't';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_WIDTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_WIDTH >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_HEIGHT;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_HEIGHT >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[11] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[12] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 13;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetForegroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'B';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_RED;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_GREEN;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_BLUE;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_UINT16 FCL_WIDTH;
  MX_UINT16 FCL_HEIGHT;


  FCL_WIDTH = FCL_X2 - FCL_X1;
  FCL_HEIGHT = FCL_Y2 - FCL_Y1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'F';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_WIDTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_WIDTH >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_HEIGHT;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_HEIGHT >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 11;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Initialise()
{
  //Local variable definitions
  MX_UINT8 FCL_IDX;


  FCI_DELAYBYTE_S(2);

  FC_CAL_UART_Init_1();

  FCD_029f1_gLCD_EB3__SetBackgroundColour(0, 0 >> 8, 0 >> 16);

  FCD_029f1_gLCD_EB3__SetForegroundColour(16777215, 16777215 >> 8, 16777215 >> 16);

  FCD_029f1_gLCD_EB3__SetDisplayOrientation(1);

  FCD_029f1_gLCD_EB3__ClearDisplay();

  FCD_029f1_gLCD_EB3__SetExternalFont(0, "Ari14.bin", 10, 001, 5);

  #if (1) // 4 > 1
    FCD_029f1_gLCD_EB3__SetExternalFont(1, "Ari32.bin", 10, 001, 6);

    #if (1) // 4 > 2
      FCD_029f1_gLCD_EB3__SetExternalFont(2, "Ari59.bin", 10, 2, 10);

      #if (1) // 4 > 3
        FCD_029f1_gLCD_EB3__SetExternalFont(3, "Ari80.bin", 10, 001, 17);

        #if (0) // 4 > 4
        //Code has been optimised out by the pre-processor
        // #else
        #endif

      // #else
      //Code has been optimised out by the pre-processor
      #endif

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

#define FCA_TEXT1 0x262a
#define FCV_TEXT1 0x0463
#define FCA_TEXT3 0x2629
#define FCV_TEXT3 0x0461

/*========================================================================*\
   Use :cal_i2c1
       :GUID: ed3a5141-43bb-43e0-86b0-2243fd1147ca
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\cal_i2c.fcpx
       :Version: 20.0 (0x200028)
       :Timestamp: 19\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_07da1_cal_i2c1__TRANSADDR;
MX_GLOBAL MX_UINT32 FCV_07da1_cal_i2c1__CONSOLELOG;

/*=----------------------------------------------------------------------=*\
   Use :Send text to the console
       :
       :Parameters for macro Prv_TextConsole:
       :  str[20] : MX_CHAR (by-ref)
       :  Colour : MX_UINT8
       :  AppendTimestamp : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_07da1_cal_i2c1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_COLOUR, MX_UINT8 FCL_APPENDTIMESTAMP)
{
  //Local variable definitions
  #define FCLsz_TSTR 20
  MX_CHAR FCL_TSTR[FCLsz_TSTR];


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_TSTR
}

#define FCA_TEMP_HUM_SENSOR 0x1c01
#define FCV_TEMP_HUM_SENSOR 0x000f

/*========================================================================*\
   Use :temp_hum_sensor
       :GUID: cc6a9919-31de-480e-91c9-2a59254a5bbd
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Grove_Humidity_SHT41.fcpx
       :Version: 3.0 (0x100028)
       :Timestamp: 30\05\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_01c01_temp_hum_sensor__SAMPLEMASK = (0x0);
MX_GLOBAL MX_UINT16 FCV_01c01_temp_hum_sensor__TEMP = (0x0);
MX_GLOBAL MX_UINT16 FCV_01c01_temp_hum_sensor__HUM = (0x0);
MX_GLOBAL MX_UINT8 FCV_01c01_temp_hum_sensor__SCALE = (0x0);
MX_GLOBAL MX_UINT8 FCV_01c01_temp_hum_sensor__PRECISION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Return temperature reading as a float value in degrees C
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_01c01_temp_hum_sensor__GetTemperatureReal()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_FLOAT FCR_RETVAL;


  if ((FCV_01c01_temp_hum_sensor__SAMPLEMASK == 0) || (FCV_01c01_temp_hum_sensor__SAMPLEMASK & 2))
  {  

    FCD_01c01_temp_hum_sensor__Sample();

  // } else {

  }

  FCV_01c01_temp_hum_sensor__SAMPLEMASK = FCV_01c01_temp_hum_sensor__SAMPLEMASK | 2;

  if (FCV_01c01_temp_hum_sensor__SCALE)
  {  

    FCR_RETVAL = flt_fromi(FCV_01c01_temp_hum_sensor__TEMP);
    FCR_RETVAL = flt_div(FCR_RETVAL, 65535.0);
    FCR_RETVAL = flt_mul(FCR_RETVAL, 315.0);
    FCR_RETVAL = flt_sub(FCR_RETVAL, 49.0);

  } else {

    FCR_RETVAL = flt_fromi(FCV_01c01_temp_hum_sensor__TEMP);
    FCR_RETVAL = flt_div(FCR_RETVAL, 65535.0);
    FCR_RETVAL = flt_mul(FCR_RETVAL, 175.0);
    FCR_RETVAL = flt_sub(FCR_RETVAL, 45.0);

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Return temperature reading as an integer value in degrees C
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_01c01_temp_hum_sensor__GetTemperatureInt()
{
  //Local variable definitions
  MX_SINT32 FCL_TEMP;
  MX_SINT16 FCR_RETVAL;


  FCR_RETVAL = flt_toi(FCD_01c01_temp_hum_sensor__GetTemperatureReal());

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :returns the relative Humidity reading as an integer value
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_01c01_temp_hum_sensor__GetHumidityInt()
{
  //Local variable definitions
  MX_SINT32 FCL_TEMP;
  MX_SINT16 FCR_RETVAL;


  FCR_RETVAL = flt_toi(FCD_01c01_temp_hum_sensor__GetHumidityReal());

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Samples the temperature and humidity as raw values.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01c01_temp_hum_sensor__Sample()
{
  //Local variable definitions
  #define FCLsz_DATA 6
  MX_UINT8 FCL_DATA[FCLsz_DATA];
  MX_UINT8 FCL_RETRYCOUNT = (0x2);
  MX_UINT8 FCL_RET;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCV_01c01_temp_hum_sensor__SAMPLEMASK = 0;

  switch (FCV_01c01_temp_hum_sensor__PRECISION)
  {
    case 1:
    {

      FCL_DATA[0] = 0xF6;

      break;
    }
    case 2:
    {

      FCL_DATA[0] = 0xFD;

      break;
    }
    default:
    {
      FCL_DATA[0] = 0xE0;

    }
  }

  FC_CAL_I2C_Transaction_Write_1(FCL_DATA, 6, 1);

  while (FCL_RETRYCOUNT > 0)
  {
    switch (FCV_01c01_temp_hum_sensor__PRECISION)
    {
      case 1:
      {

        FCI_DELAYBYTE_MS(5);

        break;
      }
      case 2:
      {

        FCI_DELAYBYTE_MS(9);

        break;
      }
      default:
      {
        FCI_DELAYBYTE_MS(2);

      }
    }

    FCL_RET = FC_CAL_I2C_Transaction_Read_1(FCL_DATA, 6, 6);

    if (FCL_RET == 6)
    {    

      FCV_01c01_temp_hum_sensor__TEMP = (FCL_DATA[0] << 8) | FCL_DATA[1];
      FCV_01c01_temp_hum_sensor__HUM = (FCL_DATA[3] << 8) | FCL_DATA[4];

      FCR_RETVAL = 1;

      FCL_RETRYCOUNT = 0;

    } else {

      FCL_RETRYCOUNT = FCL_RETRYCOUNT - 1;

    }

  }

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_DATA
}

/*=----------------------------------------------------------------------=*\
   Use :Controls the precision of the sensor affecting things like sample time and sample reliability.
       :Sample Times: Low = 2ms, Medium = 5ms, High = 9ms
       :Default: Low
       :
       :Parameters for macro ChangePrecision:
       :  Precision : 0=Low, 1=Medium, 2=High
\*=----------------------------------------------------------------------=*/
void FCD_01c01_temp_hum_sensor__ChangePrecision(MX_UINT8 FCL_PRECISION)
{

  if (FCL_PRECISION < 3)
  {  

    FCV_01c01_temp_hum_sensor__PRECISION = FCL_PRECISION;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :returns the Humidity reading as a float value
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_01c01_temp_hum_sensor__GetHumidityReal()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_FLOAT FCR_RETVAL;


  if ((FCV_01c01_temp_hum_sensor__SAMPLEMASK == 0) || (FCV_01c01_temp_hum_sensor__SAMPLEMASK & 1))
  {  

    FCD_01c01_temp_hum_sensor__Sample();

  // } else {

  }

  FCV_01c01_temp_hum_sensor__SAMPLEMASK = FCV_01c01_temp_hum_sensor__SAMPLEMASK | 1;

  FCR_RETVAL = flt_fromi(FCV_01c01_temp_hum_sensor__HUM);
  FCR_RETVAL = flt_div(FCR_RETVAL, 65535.0);
  FCR_RETVAL = flt_mul(FCR_RETVAL, 125.0);
  FCR_RETVAL = flt_sub(FCR_RETVAL, 6.0);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the temperature scale to celcius or farenheit
       :Default: Celcius
       :
       :Parameters for macro SetTemperatureScale:
       :  Scale : 0=Celcius, 1=Farenheit
\*=----------------------------------------------------------------------=*/
void FCD_01c01_temp_hum_sensor__SetTemperatureScale(MX_UINT8 FCL_SCALE)
{

  if (FCL_SCALE < 2)
  {  

    FCV_01c01_temp_hum_sensor__SCALE = FCL_SCALE;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Configures the I2C peripheral and puts the sensor into one shot mode ready to be sampled. Must be called before calling any of the other component macros.
       :Returns 1 if the sensor has been intialised correctly, else returns 0.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01c01_temp_hum_sensor__Initialise()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCV_01c01_temp_hum_sensor__HUM = 0;
  FCV_01c01_temp_hum_sensor__TEMP = 0;

  FC_CAL_I2C_Transaction_Init_1(68);

  FCD_01c01_temp_hum_sensor__Sample();

  if ((FCV_01c01_temp_hum_sensor__HUM == 0x0000) || (FCV_01c01_temp_hum_sensor__HUM == 0xFFFF))
  {  

    FCR_RETVAL = 0;

  } else {

    FCR_RETVAL = 1;

  }

  return (FCR_RETVAL);

}

#define FCA_TEXT2 0x2261
#define FCV_TEXT2 0x000d

/*========================================================================*\
   Use :User Project
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_TEMPSTRING 20
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_FLOAT FCV_TEMP;
MX_GLOBAL MX_SINT16 FCV_TEMPINT;
MX_GLOBAL MX_CHAR FCV_TEMPSTRING[FCVsz_TEMPSTRING];
MX_GLOBAL MX_UINT8 FCV_TEMPBYTE;



/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
	#ifdef INTOSCHELPER
		INTOSCHELPERCODE
	#endif
	//Setup input pins as digital
	ANSELA = 0x00;
	ANSELB = 0x00;
	ANSELD = 0x00;
	ANSELE = 0x00;
	ANSELF = 0x00;
	ANSELG = 0x00;

	//Setup UART Remapping UART2=GLCD, UART5=USB
	RX2PPS = 0x31;
	RG0PPS = 0x0E;
	RX5PPS = 0x33;
	RG2PPS = 0x14;




  // Component Macro
  FCD_029f1_gLCD_EB3__Initialise();

  // Component Macro
  FCD_01c01_temp_hum_sensor__Initialise();

  // Loop
  while (1)
  {
    // Component Macro
    FCV_TEMPINT = FCD_01c01_temp_hum_sensor__GetTemperatureInt();

    // Component Macro
    FCD_029f1_gLCD_EB3__PrintNumber(FCV_TEMPINT, 150, 60, 2, 0);

    // Delay
    FCI_DELAYBYTE_MS(10);

  }

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{
	#ifdef USE_FLOWCODE_ICD3
		ICD_INTERRUPT_HANDLER
	#endif

}




