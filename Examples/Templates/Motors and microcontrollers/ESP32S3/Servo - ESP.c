// CRC: C09139DD0A75D64CECB6A655701556ECB3779E843346CE0F5130EA7DD15162532F19E22CED7E2D79FCA1D712F9F4A73B1790799BE3387D93492B2739DFD6F390EA86995873165087177459893585281C90686FF2551B5A206F82C454E0B2FCCD13F4AF9A399C50EF4BE936633A039C41886B5479A8E9E55CB1332C7405F36E8178642253E57F9DFA48624EF30B847B3F3027571EAD75915DA9B11F738DF98E15795C795372EAB058712E8753CADEBBDA24ED6BAB3C36658BADBBD1F888A9C0513B0760C24294949B20AD5EC69D65A6363ED0635041DD9D36A31416F5D37EFD1E36F5341AE70531053716231E9F99034F5884D874256A074E549D34A0D5AD11F3DB356436961E96ADC233CE887F489B65F5C2AD59375EC6E827FDDD94B8F81F9CD157EA94462C8AB8
// REVISION: 1.0
// GUID: A1D9A216-861A-4AF8-89E9-12744BC043FA
// DATE: 07\01\2026
// DIR: Misc\Templates\Motors|and|microcontrollers\ESP32S3\Servo|-|ESP.c
//************************************************************************************
//**  
//**  Source name:   D:\Dev\Flowcode V11\Examples\Templates\Motors and microcontrollers\ESP32S3\Servo - ESP.fcfx
//**  Title:         Servo - ArdMega
//**  Description:   
//**  Device:        ESP.ESP32.E-Blocks3 ESP32S3 Programmer
//**  
//**  Generated by:  Flowcode v11.0.0.8
//**  Date:          Wednesday, January 07, 2026 12:54:56
//**  Users:         1
//**  Registered to: BenR (82702381)
//**  Licence key: 95CJQR
//**  
//**  
//**  https://www.flowcode.co.uk
//**  
//************************************************************************************


#include "D:\Dev\Flowcode V11\Examples\Templates\Motors and microcontrollers\ESP32S3\Servo - ESP.h"

#define FCA_SERVO_CONTROLLER1 0xdd21
#define FCV_SERVO_CONTROLLER1 0x08a9

/*========================================================================*\
   Use :Servo_Controller1
       :GUID: 9202a62e-0a42-4780-adce-16b701e5ec53
       :Location: D:\Dev\Flowcode V11\Components\release\Servo_Controller.fcpx
       :Version: 10.0 (0x800828)*
       :Timestamp: 16\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE 8
#define FCVsz_0dd21_Servo_Controller1__SERVO_POSITION 8
#define FCVsz_0dd21_Servo_Controller1__SERVO_TRIM 8
#define FCVsz_0dd21_Servo_Controller1__SERVO_REQUIRED 8
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__SERVO_ENABLED = (0x0);
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__AUTOMOVING = (0x0);
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__SERVO_FLAG_DISABLE = (0x0);
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__SERVO_IDX = (0x0);
MX_GLOBAL MX_UINT8 FCV_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE[FCVsz_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE];
MX_GLOBAL MX_UINT16 FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCVsz_0dd21_Servo_Controller1__SERVO_POSITION];
MX_GLOBAL MX_SINT16 FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCVsz_0dd21_Servo_Controller1__SERVO_TRIM];
MX_GLOBAL MX_UINT16 FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCVsz_0dd21_Servo_Controller1__SERVO_REQUIRED];
MX_GLOBAL MX_UINT16 FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = (0x1);

/*=----------------------------------------------------------------------=*\
   Use :Disables a servo channel effectivly disabling the motor.
       :
       :Parameters for macro DisableServo:
       :  Channel : The channel to set the position for.  First channel is zero.
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__DisableServo(MX_UINT8 FCL_CHANNEL)
{
  //Local variable definitions
  MX_UINT8 FCL_DUMMY;


  switch (FCL_CHANNEL)
  {
    case 1:
    {

      #if (0) // 1 > 1
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 2:
    {

      #if (0) // 1 > 2
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 3:
    {

      #if (0) // 1 > 3
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 4:
    {

      #if (0) // 1 > 4
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 5:
    {

      #if (0) // 1 > 5
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 6:
    {

      #if (0) // 1 > 6
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 7:
    {

      #if (0) // 1 > 7
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    default:
    {
#if 0 // Disabled code
      FCL_DUMMY = GET_PORT_PIN(C, 0);

#endif // Disabled code

      // C Code
      #if defined MX_CAL_ESP
        FC_CAL_PWM_Disable_1();
      #endif

    }
  }

#if 0 // Disabled code
  if (FCL_CHANNEL < 1)
  {  

#if 0 // Disabled code
    FCV_0dd21_Servo_Controller1__SERVO_ENABLED = FCV_0dd21_Servo_Controller1__SERVO_ENABLED & ~(0x01 << FCL_CHANNEL);

#endif // Disabled code

  // } else {

  }

#endif // Disabled code

  if (FCL_CHANNEL < 1)
  {  

    FCV_0dd21_Servo_Controller1__SERVO_FLAG_DISABLE = FCV_0dd21_Servo_Controller1__SERVO_FLAG_DISABLE | (0x01 << FCL_CHANNEL);

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Moves directly to the specified position with no interpolation.
       :
       :Parameters for macro SetPosition:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to jump to. Range: 0-255
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION)
{
  //Local variable definitions
  MX_FLOAT FCL_DUTY;


  if (FCL_CHANNEL < 1)
  {  

    FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCL_POSITION * 175;
    FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCL_POSITION * 175;

    // C Code
    #if defined MX_CAL_ESP

    FCL_DUTY = flt_div((2500 - 1000), 255.0);
    FCL_DUTY = flt_mul(FCL_DUTY, flt_fromi((255 - FCL_POSITION)));
    FCL_DUTY = flt_add(FCL_DUTY, 1000);

    FCL_DUTY = flt_div(10000.0, FCL_DUTY);

    switch (FCL_CHANNEL)
    {
      case 1:
      {

        #if (0) // 1 > 1
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 2:
      {

        #if (0) // 1 > 2
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 3:
      {

        #if (0) // 1 > 3
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 4:
      {

        #if (0) // 1 > 4
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 5:
      {

        #if (0) // 1 > 5
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 6:
      {

        #if (0) // 1 > 6
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 7:
      {

        #if (0) // 1 > 7
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      default:
      {
        // C Code
        FC_CAL_PWM_SetDutyFloat_1(FCL_DUTY);

      }
    }

    // C Code
    #endif

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Moves a single step towards the new position, the rate of movement is determined by how often the move to macro is called. 
       :Returns 1 if the position has been reached.
       :
       :Parameters for macro MoveToPositionInt:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Target position to move towards. Range: 0-65535
       :
       :Returns : 1 = reached target, 0 = target not reached.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__MoveToPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION)
{
  //Local variable definitions
  MX_UINT16 FCL_POS;
  MX_UINT8 FCR_RETVAL; // 1 = reached target, 0 = target not reached.


  FCR_RETVAL = 1;

  FCL_POS = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.686198));

  if (FCL_CHANNEL < 1)
  {  

    if (FCL_POS != FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
    {    

      FCR_RETVAL = 0;

      if (FCL_POS > FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
      {      

        FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] + 1;

      } else {

        FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] - 1;

      }

      FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL];

      // C Code
      #if defined MX_CAL_ESP

      FCD_0dd21_Servo_Controller1__SetPositionInt(FCL_CHANNEL, FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL]);

      // C Code
      #endif

    // } else {

    }

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Moves directly to the specified position with no interpolation.
       :Uses a 16-bit position parameter to add extra precision.
       :
       :Parameters for macro SetPositionInt:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to jump to. Range: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION)
{
  //Local variable definitions
  MX_FLOAT FCL_DUTY;


  if (FCL_CHANNEL < 1)
  {  

    FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.686198));
    FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.686198));

    // C Code
    #if defined MX_CAL_ESP

    FCL_DUTY = flt_div((2500 - 1000), 65535.0);
    FCL_DUTY = flt_mul(FCL_DUTY, flt_fromi((65535 - FCL_POSITION)));
    FCL_DUTY = flt_add(FCL_DUTY, 1000);

    FCL_DUTY = flt_div(10000.0, FCL_DUTY);

    switch (FCL_CHANNEL)
    {
      case 1:
      {

        #if (0) // 1 > 1
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 2:
      {

        #if (0) // 1 > 2
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 3:
      {

        #if (0) // 1 > 3
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 4:
      {

        #if (0) // 1 > 4
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 5:
      {

        #if (0) // 1 > 5
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 6:
      {

        #if (0) // 1 > 6
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      case 7:
      {

        #if (0) // 1 > 7
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        break;
      }
      default:
      {
        // C Code
        FC_CAL_PWM_SetDutyFloat_1(FCL_DUTY);

      }
    }

    // C Code
    #endif

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Moves a single step towards the new angle, the rate of movement is determined by how often the move to macro is called. 
       :Returns 1 if the position has been reached.
       :
       :Parameters for macro MoveToAngle:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Angle : Angle in degrees, Range 0 to calibration angle
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_0dd21_Servo_Controller1__MoveToAngle(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_ANGLE)
{
  //Local variable definitions
  MX_UINT16 FCL_CALC;
  MX_BOOL FCR_RETVAL;


  FCR_RETVAL = 1;

  if (FCL_CHANNEL < 1)
  {  

    if (FCL_ANGLE > FCV_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE[FCL_CHANNEL])
    {    

      FCL_ANGLE = FCV_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE[FCL_CHANNEL];

    // } else {

    }

    FCL_CALC = FCL_ANGLE * 255 / FCV_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE[FCL_CHANNEL];

    FCR_RETVAL = FCD_0dd21_Servo_Controller1__MoveToPosition(FCL_CHANNEL, FCL_CALC);

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Moves a single step towards the new position, the rate of movement is determined by how often the move to macro is called. 
       :Returns 1 if the position has been reached.
       :
       :Parameters for macro MoveToPosition:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Target position to move towards. Range: 0-255
       :
       :Returns : 1 = reached target, 0 = target not reached.
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__MoveToPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION)
{
  //Local variable definitions
  MX_UINT16 FCL_POS;
  MX_UINT8 FCR_RETVAL; // 1 = reached target, 0 = target not reached.


  FCR_RETVAL = 1;

  FCL_POS = FCL_POSITION * 175;

  if (FCL_CHANNEL < 1)
  {  

    if (FCL_POS != FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
    {    

      FCR_RETVAL = 0;

      if (FCL_POS > FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL])
      {      

        if (FCL_POS > (FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] + 175))
        {        

          FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] + 175;

        } else {

          FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCL_POS;

        }

      } else {

        if (FCL_POS < (FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] - 175))
        {        

          FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] - 175;

        } else {

          FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL] = FCL_POS;

        }

      }

      FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCL_CHANNEL];

      // C Code
      #if defined MX_CAL_ESP

      FCD_0dd21_Servo_Controller1__SetPosition(FCL_CHANNEL, FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL]);

      // C Code
      #endif

    // } else {

    }

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows the level of trim for each servo channel to be adjusted progmatically.
       :
       :Parameters for macro SetTrim:
       :  Channel : The channel to set the position for.  First channel is zero.
       :  Trim : Legacy: 0=0us, 1=+25us, 2=+50us, 3=+75us, 4=+100us, 5=-25us, 6=-50us, 7=-75us, 8=-100us or Smooth: 0-200
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetTrim(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_TRIM)
{
  //Local variable definitions
  MX_SINT16 FCL_TCALC;


  #if (1)
    if (FCL_CHANNEL < 1)
    {    

      if (FCL_TRIM < 200)
      {      

        FCL_TCALC = FCL_TRIM - 100;

        FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCL_CHANNEL] = FCL_TCALC * (6000 / 50);

      // } else {

      }

    // } else {

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Is the AutoMoveToPosition movement complete.
       : 
       :Returns 1 if the servos are still moving.
       :
       :Returns 0 if all servo movement is complete.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__IsAutoMoving()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCV_0dd21_Servo_Controller1__AUTOMOVING > 0)
  {  

    FCR_RETVAL = 1;

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the speed of the auto move to position macro.
       :
       :Default speed is shown in the Servo_Period_Multiplier property.
       :
       :Parameters for macro SetAutoMoveSpeedInt:
       :  Speed : 1=Slowest (Default), 2= Double, 3=Triple, 4=Quadruple
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetAutoMoveSpeedInt(MX_UINT16 FCL_SPEED)
{

  if (FCL_SPEED < 1)
  {  

    FCL_SPEED = 1;

  } else {

    if (FCL_SPEED > 65500)
    {    

      FCL_SPEED = 65500;

    // } else {

    }

  }

  FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = FCL_SPEED * 175;

}

/*=----------------------------------------------------------------------=*\
   Use :Is the AutoMoveToPosition movement complete for a specific servo output.
       :
       :Returns 1 if the servo is still moving.
       : 
       :Returns 0 if the servo movement is complete.
       :
       :Parameters for macro IsServoAutoMoving:
       :  Channel : Servo Motor Output Range: 0-7
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0dd21_Servo_Controller1__IsServoAutoMoving(MX_UINT8 FCL_CHANNEL)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCV_0dd21_Servo_Controller1__AUTOMOVING & (1 << FCL_CHANNEL))
  {  

    FCR_RETVAL = 1;

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Automatically moves towards the new position at a fixed rate determined by the AutoMoveSpeed.
       :
       :Parameters for macro AutoMoveToPosition:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to automatically move to. Range: 0-255
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__AutoMoveToPosition(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_POSITION)
{

  if (FCL_CHANNEL < 1)
  {  

    if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (1 << FCL_CHANNEL))
    {    

      FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = FCL_POSITION * 175;

      // C Code
      #if defined MX_CAL_ESP

      FCD_0dd21_Servo_Controller1__SetPosition(FCL_CHANNEL, FCL_POSITION);

      // C Code
      #else

      FCV_0dd21_Servo_Controller1__AUTOMOVING = FCV_0dd21_Servo_Controller1__AUTOMOVING | (1 << FCL_CHANNEL);

      // C Code
      #endif

    // } else {

    }

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Enables a servo channel effectivly setting the position of the motor to the value in the local position variable.
       :
       :Parameters for macro EnableServo:
       :  Channel : The channel to set the position for.  First channel is zero.
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__EnableServo(MX_UINT8 FCL_CHANNEL)
{
  //Local variable definitions
  MX_UINT8 FCL_DUMMY;


  switch (FCL_CHANNEL)
  {
    case 1:
    {

      #if (0) // 1 > 1
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 2:
    {

      #if (0) // 1 > 2
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 3:
    {

      #if (0) // 1 > 3
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 4:
    {

      #if (0) // 1 > 4
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 5:
    {

      #if (0) // 1 > 5
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 6:
    {

      #if (0) // 1 > 6
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 7:
    {

      #if (0) // 1 > 7
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    default:
    {
      SET_PORT_PIN(C, 0, 0);

      // C Code
      #if defined MX_CAL_ESP
        FC_CAL_PWM_Enable_1();
      #endif

    }
  }

  if (FCL_CHANNEL < 1)
  {  

    FCV_0dd21_Servo_Controller1__SERVO_ENABLED = FCV_0dd21_Servo_Controller1__SERVO_ENABLED | (0x01 << FCL_CHANNEL);

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Automatically moves towards the new angle at a fixed rate determined by the AutoMoveSpeed.
       :AutoMove not currently supported by ESP32.
       :
       :Parameters for macro AutoMoveToAngle:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Angle : Angle in degrees, Range 0 to calibration angle
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__AutoMoveToAngle(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_ANGLE)
{
  //Local variable definitions
  MX_UINT16 FCL_CALC;


  if (FCL_CHANNEL < 1)
  {  

    if (FCL_ANGLE > FCV_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE[FCL_CHANNEL])
    {    

      FCL_ANGLE = FCV_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE[FCL_CHANNEL];

    // } else {

    }

    FCL_CALC = FCL_ANGLE * 255 / FCV_0dd21_Servo_Controller1__SERVO_CALIBRATION_ANGLE[FCL_CHANNEL];

    FCD_0dd21_Servo_Controller1__AutoMoveToPosition(FCL_CHANNEL, FCL_CALC);

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the speed of the auto move to position macro.
       :
       :Default speed is shown in the Servo_Period_Multiplier property.
       :
       :Parameters for macro SetAutoMoveSpeed:
       :  Speed : 1=Slowest (Default), 2= Double, 3=Triple, 4=Quadruple
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__SetAutoMoveSpeed(MX_UINT8 FCL_SPEED)
{

  if (FCL_SPEED < 1)
  {  

    FCL_SPEED = 1;

  } else {

    if (FCL_SPEED > 250)
    {    

      FCL_SPEED = 250;

    // } else {

    }

  }

  FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = FCL_SPEED * 175;

}

/*=----------------------------------------------------------------------=*\
   Use :Automatically moves towards the new 16-bit position at a fixed rate determined by the AutoMoveSpeed.
       :
       :Parameters for macro AutoMoveToPositionInt:
       :  Channel : The channel to assign the new position. Range: 0-7
       :  Position : Position to automatically move to. Range: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__AutoMoveToPositionInt(MX_UINT8 FCL_CHANNEL, MX_UINT16 FCL_POSITION)
{

  if (FCL_CHANNEL < 1)
  {  

    if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (1 << FCL_CHANNEL))
    {    

      FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCL_CHANNEL] = flt_toi(flt_mul(flt_fromi(FCL_POSITION), 0.686198));

      // C Code
      #if defined MX_CAL_ESP

      FCD_0dd21_Servo_Controller1__SetPositionInt(FCL_CHANNEL, FCL_POSITION);

      // C Code
      #else

      FCV_0dd21_Servo_Controller1__AUTOMOVING = FCV_0dd21_Servo_Controller1__AUTOMOVING | (1 << FCL_CHANNEL);

      // C Code
      #endif

    // } else {

    }

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sets up the servo motor interrupts
\*=----------------------------------------------------------------------=*/
void FCD_0dd21_Servo_Controller1__Initialise()
{

  FCV_0dd21_Servo_Controller1__AUTOMOVESPEED = 175;

  FCV_0dd21_Servo_Controller1__SERVO_IDX = 0;

  while (FCV_0dd21_Servo_Controller1__SERVO_IDX < 8)
  {
    FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = 128 * 175;
    FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] = 128 * 175;
    FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCV_0dd21_Servo_Controller1__SERVO_IDX] = 0;

    FCV_0dd21_Servo_Controller1__SERVO_IDX = FCV_0dd21_Servo_Controller1__SERVO_IDX + 1;

  }

  FCV_0dd21_Servo_Controller1__SERVO_IDX = 0;

  //Comment:
  //Calculate Trim timings

  #if (1) // 1 > 0
    #if (0) // 0 > 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0) // 1 > 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 > 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 > 3
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 > 4
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 > 5
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 > 6
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 > 7
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  // Setup MCU registers
  #if defined MX_CAL_STARM
  
  	MX_UINT32 TIM_SERVO_CLOCK_FREQ;
  	RCC_ClkInitTypeDef TIM_SERVO_CLOCK_CONF;
  	uint32_t Flatency;
  	HAL_RCC_GetClockConfig(&TIM_SERVO_CLOCK_CONF, &Flatency);
  	if (TIM_SERVO_CLOCK_CONF.APB1CLKDivider == RCC_HCLK_DIV1)
  		TIM_SERVO_CLOCK_FREQ = HAL_RCC_GetPCLK1Freq();
  	else
  		TIM_SERVO_CLOCK_FREQ = HAL_RCC_GetPCLK1Freq() * 2;
  	#define TIM_SERVO_PRESCALER ((TIM_SERVO_CLOCK_FREQ/1000000)-1)
  
  	MX_HANDLE_TIM_SERVO.Instance = TIM_SERVO_INSTANCE;
  	MX_HANDLE_TIM_SERVO.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  	MX_HANDLE_TIM_SERVO.Init.CounterMode = TIM_COUNTERMODE_UP;
  	MX_HANDLE_TIM_SERVO.Init.RepetitionCounter = 0;
  	MX_HANDLE_TIM_SERVO.Init.Prescaler = TIM_SERVO_PRESCALER;
  	MX_HANDLE_TIM_SERVO.Init.Period = 3000;	// 3mS interval = 24mS repeat
  
  	__HAL_RCC_TIM_SERVO_CLK_ENABLE();
  	HAL_NVIC_SetPriority(TIM_SERVO_IRQn, 3, 0);
  	HAL_TIM_Base_Init(&(MX_HANDLE_TIM_SERVO));
  
  	TIM_ClockConfigTypeDef MX_CONFIG_CLK_SERVO;
  	MX_CONFIG_CLK_SERVO.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  	MX_CONFIG_CLK_SERVO.ClockPolarity = TIM_CLOCKPOLARITY_RISING;
  	MX_CONFIG_CLK_SERVO.ClockPrescaler = TIM_CLOCKPRESCALER_DIV1;
  	MX_CONFIG_CLK_SERVO.ClockFilter = 0;
  	HAL_TIM_ConfigClockSource(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_CLK_SERVO);
  
  	HAL_TIM_OC_Init(&MX_HANDLE_TIM_SERVO);
  
  	TIM_MasterConfigTypeDef MX_CONFIG_MASTER_SERVO;
  	MX_CONFIG_MASTER_SERVO.MasterOutputTrigger = TIM_TRGO_RESET;
  	MX_CONFIG_MASTER_SERVO.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  	HAL_TIMEx_MasterConfigSynchronization(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_MASTER_SERVO);
  
  	MX_CONFIG_OC_SERVO.OCMode = TIM_OCMODE_TIMING;
  	MX_CONFIG_OC_SERVO.Pulse = 1500;
  	MX_CONFIG_OC_SERVO.OCPolarity = TIM_OCPOLARITY_HIGH;
  	HAL_TIM_OC_ConfigChannel(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_OC_SERVO, TIM_CHANNEL_1);
  
  
  	HAL_NVIC_EnableIRQ(TIM_SERVO_IRQn);
  	HAL_TIM_Base_Start_IT(&(MX_HANDLE_TIM_SERVO));
  	HAL_TIM_OC_Start_IT(&MX_HANDLE_TIM_SERVO, TIM_CHANNEL_1);
  
  
  #elif defined MX_CAL_ARM
  
  	AT91F_TC2_CfgPMC();
  	AT91C_BASE_TC2->TC_CMR = (AT91C_TC_WAVE | AT91C_TC_CPCTRG | AT91C_TC_CLKS_TIMER_DIV2_CLOCK);
  	AT91C_BASE_TC2->TC_CCR = (AT91C_TC_SWTRG | AT91C_TC_CLKEN);
  	AT91C_BASE_TC2->TC_RC = MX_SERVO_PERIOD;
  	AT91C_BASE_TC2->TC_CMR |= AT91C_TC_CLKI;
  	AT91C_BASE_TC2->TC_IER = AT91C_TC_CPCS;
  	AT91C_BASE_TC2->TC_IER = AT91C_TC_CPAS;
  
  #elif defined MX_CAL_ESP
  
  #else
  
  	#ifdef MX_CAL_PIC16
  
  		PR3 = (MX_SERVO_CCPR1H << 8) | MX_SERVO_CCPR1L;
  
  		//#if (MX_CLKS_PER_INST == 2)
  		//	PR3 = PR3 * 2;
  		//#endif
  
  		T2CON = 0;				//Stop TMR2
  		IFS0bits.T2IF = 0;		//Clear interrupt
  		IEC0bits.T2IE = 1;		//Enable TMR2 interrupts
  
  		T3CON = 0;				//Stop TMR3
  		IFS0bits.T3IF = 0;		//Clear interrupt
  
  		TMR3 = 0;				//Clear TMR3
  		IEC0bits.T3IE = 1;		//Enable TMR3 interrupts
  		T3CON = 0x8000;			//Start TMR3
  
  	#else
  
  		MX_SERVO_REG_CCPR1H = MX_SERVO_CCPR1H;					//Set capture compare setpoint
  		MX_SERVO_REG_CCPR1L = MX_SERVO_CCPR1L;
  		MX_SERVO_REG_T1CON = MX_SERVO_T1CON;					//Setup timer and start running
  
          #ifdef MX_SERVO_T1_CLK
              T1CLK = MX_SERVO_T1_CLK;
          #endif
  
  		MX_SERVO_REG_CCP1CON = MX_SERVO_CCP1CON;				//Configure CCP1 settings
  		st_bit(MX_SERVO_REG_CCP1EN, MX_SERVO_FLAG_CCP1EN);		//Enable CCP1 interrupt
  		MX_SERVO_REG_CCP2CON = MX_SERVO_CCP2CON;				//Configure CCP2 settings
  
  		st_bit(MX_SERVO_REG_CCP2EN, MX_SERVO_FLAG_CCP2EN);		//Enable CCP2 interrupt
  		st_bit(MX_SERVO_REG_INT, MX_SERVO_FLAG_PERIPH);			//Enable Interrupts
  		st_bit(MX_SERVO_REG_INT, MX_SERVO_FLAG_GLOB);
  
  		#ifdef MX_CAL_AVR
  			sei();
  		#endif
  		#ifdef MX_CAL_ARD
  			sei();
  		#endif
  	#endif
  #endif

  #if (1)
    // C Code
    #ifdef MX_CAL_PIC16
    
      T3CON |= 0x0010;
    
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

}

#define FCA_SERVOMOTOR1 0xb391
#define FCV_SERVOMOTOR1 0x0885

/*========================================================================*\
   Use :cal_adc
       :GUID: e77a4e40-e0df-431a-98f8-7ae4d8ebfbeb
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\cal_adc.fcpx
       :Version: 6.0 (0x200028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)


/*========================================================================*\
   Use :adc_base1
       :GUID: 9b845489-48f5-4fa5-aace-2c97efdcede3
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\adc_base_2d.fcpx
       :Version: 4.0 (0x100328)
       :Timestamp: 08\05\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0cc51_adc_base1__RawSampleInt()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = FC_ADC_Sample_1(1);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT16 FCL_AVERAGE = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT8 FCR_RETVAL;


  if (FCL_DELAYUS > 0)
  {  

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(4, 6, 1, FCL_DELAYUS);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(0);
      FCL_COUNT = FCL_COUNT + 1;

    }

  } else {

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(4, 6, 1, 40);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(0);
      FCL_COUNT = FCL_COUNT + 1;

    }

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as a string
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_0cc51_adc_base1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
  //Local variable definitions
  MX_FLOAT FCL_SAMPLE;


  FCL_SAMPLE = FCD_0cc51_adc_base1__GetVoltage();

  FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL, FCRsz_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = FCD_0cc51_adc_base1__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_0cc51_adc_base1__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT32 FCL_AVERAGE = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_SINT16 FCR_RETVAL;


  if (FCL_DELAYUS > 0)
  {  

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(4, 6, 1, FCL_DELAYUS);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(1);
      FCL_COUNT = FCL_COUNT + 1;

    }

  } else {

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(4, 6, 1, 40);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(1);
      FCL_COUNT = FCL_COUNT + 1;

    }

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0cc51_adc_base1__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = FCD_0cc51_adc_base1__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_0cc51_adc_base1__GetVoltage()
{
  //Local variable definitions
  MX_UINT16 FCL_SAMPLE;
  MX_FLOAT FCR_RETVAL;


  FC_ADC_Enable_1(4, 6, 1, 40);

  FCL_SAMPLE = FC_ADC_Sample_1(1);

  FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.000403);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_0cc51_adc_base1__RawEnable()
{

  FC_ADC_Enable_1(4, 6, 1, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__RawSampleByte()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = FC_ADC_Sample_1(0);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0cc51_adc_base1__GetInt()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FC_ADC_Enable_1(4, 6, 1, 40);

  FCR_RETVAL = FC_ADC_Sample_1(1);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_0cc51_adc_base1__RawDisable()
{

  FC_ADC_Disable_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__GetByte()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FC_ADC_Enable_1(4, 6, 1, 40);

  FCR_RETVAL = FC_ADC_Sample_1(0);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :MapFunction1
       :GUID: ccdce31d-a1a3-437a-88ba-5431745ddf6e
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\MapFunction.fcpx
       :Version: 7.0 (0x200028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Map function for unsigned long type variables
       :
       :Parameters for macro MapUlong:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0c431_MapFunction1__MapUlong(MX_UINT32 FCL_VALUE, MX_UINT32 FCL_INMIN, MX_UINT32 FCL_INMAX, MX_UINT32 FCL_OUTMIN, MX_UINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = (FCL_VALUE - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for signed int type variables
       :
       :Parameters for macro MapInt:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_0c431_MapFunction1__MapInt(MX_SINT16 FCL_VALUE, MX_SINT16 FCL_INMIN, MX_SINT16 FCL_INMAX, MX_SINT16 FCL_OUTMIN, MX_SINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_SINT32 FCL_TEMP;
  MX_SINT16 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for floating point type variables
       :
       :Parameters for macro MapFloat:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_0c431_MapFunction1__MapFloat(MX_FLOAT FCL_VALUE, MX_FLOAT FCL_INMIN, MX_FLOAT FCL_INMAX, MX_FLOAT FCL_OUTMIN, MX_FLOAT FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (flt_lt(FCL_VALUE, FCL_INMIN))
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (flt_gt(FCL_VALUE, FCL_INMAX))
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = flt_add(flt_div(flt_mul((flt_sub(FCL_VALUE, FCL_INMIN)), (flt_sub(FCL_OUTMAX, FCL_OUTMIN))), (flt_sub(FCL_INMAX, FCL_INMIN))), FCL_OUTMIN);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for signed long type variables
       :
       :Parameters for macro MapLong:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_SINT32
\*=----------------------------------------------------------------------=*/
MX_SINT32 FCD_0c431_MapFunction1__MapLong(MX_SINT32 FCL_VALUE, MX_SINT32 FCL_INMIN, MX_SINT32 FCL_INMAX, MX_SINT32 FCL_OUTMIN, MX_SINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_SINT32 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = (FCL_VALUE - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for unsigned int type variables
       :
       :Parameters for macro MapUInt:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0c431_MapFunction1__MapUInt(MX_UINT16 FCL_VALUE, MX_UINT16 FCL_INMIN, MX_UINT16 FCL_INMAX, MX_UINT16 FCL_OUTMIN, MX_UINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT32 FCL_TEMP;
  MX_UINT16 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for byte type variables
       :
       :Parameters for macro MapByte:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c431_MapFunction1__MapByte(MX_UINT8 FCL_VALUE, MX_UINT8 FCL_INMIN, MX_UINT8 FCL_INMAX, MX_UINT8 FCL_OUTMIN, MX_UINT8 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT8 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :IsSim1
       :GUID: 5f7b77e5-e979-4010-93f1-e6d98f83bd71
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\IsSim.fcpx
       :Version: 6.0 (0x100028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Returns 0 if running on an embedded target or 1 if running in simulation runtime.
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_0b4c1_IsSim1__Check()
{
  //Local variable definitions
  MX_BOOL FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

#define FCA_POTENTIOMETER1 0x0a21
#define FCV_POTENTIOMETER1 0x0799

/*========================================================================*\
   Use :Potentiometer1
       :GUID: 11ca2f38-de81-4812-9338-4b5a7a89a658
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Potentiometer.fcpx
       :Version: 21.0 (0x100028)
       :Timestamp: 06\05\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_00a21_Potentiometer1__H;
MX_GLOBAL MX_SINT16 FCV_00a21_Potentiometer1__CHANNEL = (0);

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_00a21_Potentiometer1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
  //Local variable definitions
  MX_FLOAT FCL_VOLTAGE = (0.0);


  FCL_VOLTAGE = FCD_0cc51_adc_base1__GetVoltage();

  FCI_FLOAT_TO_STRING(FCL_VOLTAGE, FCV_PRECISION, FCR_RETVAL, FCRsz_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC as a byte
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_00a21_Potentiometer1__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT16 FCL_AVERAGE = (0x0);
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  while (FCL_COUNT < FCL_NUMSAMPLES)
  {
    FCR_RETVAL = FCD_0cc51_adc_base1__GetByte();

    FCI_DELAYBYTE_US(FCL_DELAYUS);

    FCL_AVERAGE = FCL_AVERAGE + FCR_RETVAL;
    FCL_COUNT = FCL_COUNT + 1;

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC at full bit depth
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00a21_Potentiometer1__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT32 FCL_AVERAGE = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  while (FCL_COUNT < FCL_NUMSAMPLES)
  {
    FCR_RETVAL = FCD_0cc51_adc_base1__GetInt();

    FCI_DELAYBYTE_US(FCL_DELAYUS);

    FCL_AVERAGE = FCL_AVERAGE + FCR_RETVAL;
    FCL_COUNT = FCL_COUNT + 1;

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_00a21_Potentiometer1__GetVoltage()
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  FCR_RETVAL = 0;

  FCR_RETVAL = FCD_0cc51_adc_base1__GetVoltage();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00a21_Potentiometer1__GetInt()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCR_RETVAL = FCD_0cc51_adc_base1__GetInt();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_00a21_Potentiometer1__GetByte()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCR_RETVAL = FCD_0cc51_adc_base1__GetByte();

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :WidthData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: D:\Dev\Flowcode V11\Components\release\lut.fcpx
       :Version: 18.0 (0x100828)*
       :Timestamp: 05\01\2026
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb2_WidthData__FLOATFIXEDLIST 200000
#define FCVsz_00fb2_WidthData__INTFIXEDLIST 95
#define FCD_00fb2_WidthData__INTFIXEDLIST(ix) 0

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb2_WidthData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 95;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :ASCIIData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: D:\Dev\Flowcode V11\Components\release\lut.fcpx
       :Version: 18.0 (0x100828)*
       :Timestamp: 05\01\2026
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1_ASCIIData__FLOATFIXEDLIST 200000
#define FCVsz_00fb1_ASCIIData__INTFIXEDLIST 475
#define FCD_00fb1_ASCIIData__INTFIXEDLIST(ix) FCD_00fb1_ASCIIData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCIIData__INTFIXEDLIST_LUT ROMARRAY_E =
{
0x00,0x06,0x5F,0x06,0x00,0x07,0x03,0x00,0x07,0x03,0x24,0x7E,0x24,0x7E,0x24,0x24,0x2B,0x6A,0x12,0x00,0x63,0x13,0x08,0x64,0x63,0x36,0x49,0x56,0x20,0x50,0x00,0x07,0x03,0x00,0x00,0x00,0x3E,0x41,0x00,0x00,0x00,0x41,0x3E,0x00,0x00,0x08,0x3E,0x1C,0x3E,0x08,0x08,0x08,0x3E,0x08,0x08,0x00,0xE0,0x60,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x60,0x60,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x3E,0x51,0x49,0x45,0x3E,0x00,0x42,0x7F,0x40,0x00,0x62,0x51,0x49,0x49,0x46,0x22,0x49,0x49,0x49,0x36,0x18,0x14,0x12,0x7F,0x10,0x27,0x45,0x45,0x45,0x39,0x3C,0x4A,0x49,0x49,0x30,0x01,0x71,0x09,0x05,0x03,0x36,0x49,0x49,0x49,0x36,0x06,0x49,0x49,0x29,0x1E,0x00,0x6C,0x6C,0x00,0x00,0x00,0xEC,0x6C,0x00,0x00,0x08,0x14,0x22,0x41,0x00,0x24,0x24,0x24,0x24,0x24,0x00,0x41,0x22,0x14,0x08,0x02,0x01,0x59,0x09,0x06,0x3E,0x41,0x5D,0x55,0x1E,0x7E,0x09,0x09,0x09,0x7E,0x7F,0x49,0x49,0x49,0x36,0x3E,0x41,0x41,0x41,0x22,0x7F,0x41,0x41,0x41,0x3E,0x7F,0x49,0x49,0x49,0x41,0x7F,0x09,0x09,0x09,0x01,0x3E,0x41,0x49,0x49,0x7A,0x7F,0x08,0x08,0x08,0x7F,0x00,0x41,0x7F,0x41,0x00,0x30,0x40,0x40,0x40,0x3F,0x7F,0x08,0x14,0x22,0x41,0x7F,0x40,0x40,0x40,0x40,0x7F,0x02,0x04,0x02,0x7F,0x7F,0x02,0x04,0x08,0x7F,0x3E,0x41,0x41,0x41,0x3E,0x7F,0x09,0x09,0x09,0x06,0x3E,0x41,0x51,0x21,0x5E,0x7F,0x09,0x09,0x19,0x66,0x26,0x49,0x49,0x49,0x32,0x01,0x01,0x7F,0x01,0x01,0x3F,0x40,0x40,0x40,0x3F,0x1F,0x20,0x40,0x20,0x1F,0x3F,0x40,0x3C,0x40,0x3F,0x63,0x14,0x08,0x14,0x63,0x07,0x08,0x70,0x08,0x07,0x71,0x49,0x45,0x43,0x00,0x00,0x7F,0x41,0x41,0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x41,0x41,0x7F,0x00,0x04,0x02,0x01,0x02,0x04,0x80,0x80,0x80,0x80,0x80,0x00,0x03,0x07,0x00,0x00,0x20,0x54,0x54,0x54,0x78,0x7F,0x44,0x44,0x44,0x38,0x38,0x44,0x44,0x44,0x28,0x38,0x44,0x44,0x44,0x7F,0x38,0x54,0x54,0x54,0x18,0x08,0x7E,0x09,0x09,0x00,0x18,0xA4,0xA4,0xA4,0x7C,0x7F,0x04,0x04,0x78,0x00,0x00,0x00,0x7D,0x00,0x00,0x40,0x80,0x84,0x7D,0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00,0x7F,0x40,0x00,0x7C,0x04,0x18,0x04,0x78,0x7C,0x04,0x04,0x78,0x00,0x38,0x44,0x44,0x44,0x38,0xFC,0x44,0x44,0x44,0x38,0x38,0x44,0x44,0x44,0xFC,0x44,0x78,0x44,0x04,0x08,0x08,0x54,0x54,0x54,0x20,0x04,0x3E,0x44,0x24,0x00,0x3C,0x40,0x20,0x7C,0x00,0x1C,0x20,0x40,0x20,0x1C,0x3C,0x60,0x30,0x60,0x3C,0x6C,0x10,0x10,0x6C,0x00,0x9C,0xA0,0x60,0x3C,0x00,0x64,0x54,0x54,0x4C,0x00,0x08,0x3E,0x41,0x41,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x41,0x41,0x3E,0x08,0x02,0x01,0x02,0x01,0x00,0x06,0x09,0x09,0x06,0x00
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 475;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_Font1
       :GUID: 1b08885c-807e-4631-930e-a4fef06159dc
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_Font.fcpx
       :Version: 37.0 (0x1400028)
       :Timestamp: 12\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_09e51_gLCD_Font1__OLDCHAR = (0x0);
MX_GLOBAL MX_UINT32 FCV_09e51_gLCD_Font1__OLDPOSITION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Adds up all the pixels widths before the selected character to get to the start of the pixel data
       :
       :Parameters for macro SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_09e51_gLCD_Font1__SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH;
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (1)
    #if (0) // 1 == 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the width of the ASCII character font data
       :
       :Parameters for macro ReadWidth:
       :  Character : ASCII position so A = 'A'
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadWidth(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCL_PWIDTH;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 127 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (1)
      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 005;

      } else {

        FCR_RETVAL = 5;

      }

    #else
    //Code has been optimised out by the pre-processor
    #endif

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Collects a stat about the selected font
       :
       :Parameters for macro ReadFontStat:
       :  Index : 0=SpaceColumns, 1=CharacterHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadFontStat(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX == 1)
  {  

    FCR_RETVAL = 8;

  } else {

    FCR_RETVAL = 000;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single pixel column byte from the selected ASCII character font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  Character : ASCII position so A = 'A'
       :  ByteIndex : Range: 0 to ((PixelWidth - 1) * BytesPerColumn)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 127 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 95)))
    {    

      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 0;

      } else {

        //Comment:
        //Out of range

        FCR_RETVAL = 0xAA;

      }

    } else {

      FCL_CHARACTER = FCL_CHARACTER - 33;

      #if (1) // 1 == 1
        if (FCL_CHARACTER == FCV_09e51_gLCD_Font1__OLDCHAR)
        {        

          FCL_POSITION = FCV_09e51_gLCD_Font1__OLDPOSITION;

        } else {

          FCL_POSITION = FCL_CHARACTER * 5 * 1;

          FCV_09e51_gLCD_Font1__OLDPOSITION = FCL_POSITION;
          FCV_09e51_gLCD_Font1__OLDCHAR = FCL_CHARACTER;

        }

      #else
      //Code has been optimised out by the pre-processor
      #endif

      FCL_POSITION = FCL_POSITION + FCL_BYTEINDEX;

      FCR_RETVAL = FCD_00fb1_ASCIIData__INTFIXEDLIST(FCL_POSITION);

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :Base_GLCD1
       :GUID: 4384cba9-0bea-4359-8c5b-dcd046aa7778
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Base_GLCD.fcpx
       :Version: 53.0 (0x2300028)
       :Timestamp: 08\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME2 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME1 13
#define FCVsz_0ba71_Base_GLCD1__SPACEWIDTH 1
#define FCVsz_0ba71_Base_GLCD1__FONTHEADER 16
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME8 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME7 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME6 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME5 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME4 13
#define FCVsz_0ba71_Base_GLCD1__CHARSPACING 1
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME3 13

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0ba71_Base_GLCD1__Prv_SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH = (0x0);
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the number of pixel columns used in the selected font
       :
       :Parameters for macro ReadFontWidth:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character to get the pixel width e.g. 'A' or 65
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontWidth(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadWidth(FCL_CHARACTER);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_ReadFontFileHeader:
       :  Font : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD1__Prv_ReadFontFileHeader(MX_UINT8 FCL_FONT)
{
  //Local variable definitions
  MX_UINT8 FCL_RETVAL = (0x0);
  MX_UINT8 FCL_IDX = (0x0);
  #define FCLsz_TEST 20
  MX_CHAR FCL_TEST[FCLsz_TEST] = "";


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_TEST
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a stat from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontStat:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Index : 0=SpaceWidth, 1=PixelHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontStat(MX_UINT8 FCL_FONT, MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    //Comment:
    //Character Spacing comes from font component properties
    //specified by the user and independent of the font file.

    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadFontStat(FCL_INDEX);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows one of the default external font files to be switched out for a different font file.
       :
       :Parameters for macro SetExternalFont:
       :  Font : Range: 0 to (FontCount - 1)
       :  Filename[20] : New font filename
       :  CharacterSpacing : Number of pixel columns to use between each character
       :  SpaceWidth : Number of pixel columns to use for a space character
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD1__SetExternalFont(MX_UINT8 FCL_FONT, MX_CHAR *PFCL_FILENAME, MX_UINT8 FCL_CHARACTERSPACING, MX_UINT8 FCL_SPACEWIDTH)
{
  #define FCLsz_FILENAME 20
  MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
  FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontByte:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character for example 'A' or 65
       :  ByteIndex : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontByte(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0) // (0) && (FCL_CHARACTER != ' ')
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadASCIILUT(FCL_CHARACTER, FCL_BYTEINDEX);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :LCD1
       :GUID: 0953aac0-9c23-4c2f-9843-88954a4191ea
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\LCD.fcpx
       :Version: 6.0 (0x200528)
       :Timestamp: 10\10\2023
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Clear()
{

  // ctrl_lcd::Clear()

  // ::Component.Property.SetValue(this, "CursorPosX", 0)

  // ::Component.Property.SetValue(this, "CursorPosY", 0)

  FCD_04071_LCD1__RawSend(0x01, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x02, 0);

  FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
  //Local variable definitions
  MX_UINT8 FCL_IDX = (0x0);
  MX_UINT8 FCL_COUNT;


  FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

  while (FCL_IDX < FCL_COUNT)
  {
    #if (0) // 0 > 0
    //Code has been optimised out by the pre-processor
    #else
      // ctrl_lcd::AddText(CursorPosX, CursorPosY, .Text)

      FCD_04071_LCD1__RawSend(FCL_TEXT[FCL_IDX], 0x10);

    #endif

    FCL_IDX = FCL_IDX + 1;

  }

  // ::Component.Property.SetValue(this, "CursorPosX", CursorPosX + LENGTH$ (.Text))

}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

  FCD_04071_LCD1__RawSend(FCL_CHARACTER, 0x10);

  // ctrl_lcd::AddChar(CursorPosX, CursorPosY, .character)

  // ::Component.Property.SetValue(this, "CursorPosX", CursorPosX + 1)

}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintNumber(MX_SINT16 FCL_NUMBER)
{
  //Local variable definitions
  #define FCLsz_S 10
  MX_CHAR FCL_S[FCLsz_S];


  FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

  FCD_04071_LCD1__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

  FCD_04071_LCD1__RawSend(64 + (FCL_INDEX << 3), 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(FCL_D0, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D1, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D2, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D3, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D4, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D5, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D6, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D7, 0x10);

  FCD_04071_LCD1__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__ClearLine(MX_UINT8 FCL_LINE)
{
  //Local variable definitions
  MX_UINT8 FCL_X;


  if (FCL_LINE < 4)
  {  

    // ctrl_lcd::ClearLine(.Line)

    FCD_04071_LCD1__Cursor(0, FCL_LINE);

    FCL_X = 0;

    while (FCL_X < 20)
    {
      FCD_04071_LCD1__RawSend(' ', 0x10);

      FCL_X = FCL_X + 1;

    }

    FCD_04071_LCD1__Cursor(0, FCL_LINE);

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

  // ::Component.Property.SetValue(this, "CursorPosX", .x)

  // ::Component.Property.SetValue(this, "CursorPosY", .y)

  #if (0) // 4 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 4 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (1) // 4 == 4
    if (FCL_Y == 0)
    {    

      FCL_Y = 0x80;

    } else {

      if (FCL_Y == 1)
      {      

        FCL_Y = 0xC0;

      } else {

        #if (0) // 20 == 16
        //Code has been optimised out by the pre-processor
        #else
          #if (1) // 20 == 20
            if (FCL_Y == 2)
            {            

              FCL_Y = 0x94;

            } else {

              FCL_Y = 0xd4;

            }

          // #else
          //Code has been optimised out by the pre-processor
          #endif

        #endif

      }

    }

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  FCD_04071_LCD1__RawSend(FCL_Y + FCL_X, 0);

  FCI_DELAYBYTE_MS(2);

  //Comment:
  //EB2 LCDs have occasional problems here if cursor command isn't called twice

  FCD_04071_LCD1__RawSend(FCL_Y + FCL_X, 0);

  FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Command(MX_UINT8 FCL_INSTRUCTION)
{

  FCD_04071_LCD1__RawSend(FCL_INSTRUCTION, 0);

  FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
  //Local variable definitions
  #define FCLsz_S 15
  MX_CHAR FCL_S[FCLsz_S];


  if (FCL_FORMAT == 1)
  {  

    FCI_UTOS32(FCL_NUMBER, FCL_S,15);

  } else {

    FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

  }

  FCD_04071_LCD1__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  Position : Holds the number of positions to shift the display
       :  Direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
  //Local variable definitions
  MX_UINT8 FCL_CMD = (0x0);
  MX_UINT8 FCL_SCROLL;


  FCL_CMD = 0;

  if (FCL_DIRECTION == 0)
  {  

    FCL_CMD = 0x18;

    // .scroll=ctrl_lcd::GetScrollX()

    // ctrl_lcd::SetScrollX(.scroll + .Position)

  } else {

    FCL_CMD = 0x1C;

    // ctrl_lcd::SetScrollX(ctrl_lcd::GetScrollX() - .Position)

  }

  if (FCL_CMD != 0 && FCL_POSITION != 0)
  {  

    while (FCL_POSITION != 0)
    {
      FCD_04071_LCD1__RawSend(FCL_CMD, 0);

      FCL_POSITION = FCL_POSITION - 1;

    }

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
  //Local variable definitions
  MX_UINT8 FCL_NIBBLE;


  //Comment:
  //Output upper nibble of the byte

  #if (1) // 0 == 0
    SET_PORT_PIN(B, 0, 0);
    SET_PORT_PIN(B, 1, 0);
    SET_PORT_PIN(B, 2, 0);
    SET_PORT_PIN(B, 3, 0);
    SET_PORT_PIN(B, 4, 0);
    SET_PORT_PIN(B, 5, 0);

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    FCL_NIBBLE = (FCL_DATA >> 4);
    SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  //Comment:
  //Output byte to pins

  #if (0) // 0 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Comment:
  //Output byte to port

  #if (0) // 0 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  if (FCL_TYPE)
  {  

    SET_PORT_PIN(B, 4, 1);

  // } else {

  }

  #if (1)
    FCI_DELAYBYTE_US(100);

    FCI_DELAYBYTE_US(100);

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  FCI_DELAYBYTE_US(100);

  //Comment:
  //Set Enable high, pause then set low
  //to acknowledge the data has been 
  //submitted.

  SET_PORT_PIN(B, 5, 1);

  FCI_DELAYBYTE_US(100);

  SET_PORT_PIN(B, 5, 0);

  FCI_DELAYBYTE_US(100);

  #if (1) // 0 == 0
    SET_PORT_PIN(B, 0, 0);
    SET_PORT_PIN(B, 1, 0);
    SET_PORT_PIN(B, 2, 0);
    SET_PORT_PIN(B, 3, 0);
    SET_PORT_PIN(B, 4, 0);

    FCL_NIBBLE = (FCL_DATA & 0xf);
    SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

    if (FCL_TYPE)
    {    

      SET_PORT_PIN(B, 4, 1);

    // } else {

    }

    FCI_DELAYBYTE_US(100);

    SET_PORT_PIN(B, 5, 1);

    FCI_DELAYBYTE_US(100);

    SET_PORT_PIN(B, 5, 0);

    FCI_DELAYBYTE_US(100);

  // #else
  //Code has been optimised out by the pre-processor
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Print a Float number rounded up to a specified amount of decimal places.
       :
       :Parameters for macro PrintFloat:
       :  Number : Enter the number or variable to print to the LCD
       :  DecimalPlaces : Enter how many decimal places to round up to (1 - 6)
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_DECIMALPLACES)
{
  //Local variable definitions
  #define FCLsz_S 10
  MX_CHAR FCL_S[FCLsz_S];


  if (FCL_DECIMALPLACES > 6)
  {  

    FCL_DECIMALPLACES = 6;

  } else {

    if (FCL_DECIMALPLACES < 1)
    {    

      FCL_DECIMALPLACES = 1;

    // } else {

    }

  }

  FCI_FLOAT_TO_STRING(FCL_NUMBER, FCL_DECIMALPLACES, FCL_S, FCLsz_S);

  FCD_04071_LCD1__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

  #if (0) // 0 > 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Start()
{

  // ::Component.Property.SetValue(this, "CursorPosX", 0)

  // ::Component.Property.SetValue(this, "CursorPosY", 0)

  #if (1) // 0 == 0
    SET_PORT_PIN(B, 0, 0);
    SET_PORT_PIN(B, 1, 0);
    SET_PORT_PIN(B, 2, 0);
    SET_PORT_PIN(B, 3, 0);
    SET_PORT_PIN(B, 4, 0);
    SET_PORT_PIN(B, 5, 0);

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0) // 0 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 0 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  FCI_DELAYBYTE_MS(12);

  FCD_04071_LCD1__RawSend(0x33, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x33, 0);

  FCI_DELAYBYTE_MS(2);

  #if (0) // 0 > 0
  //Code has been optimised out by the pre-processor
  #else
    FCD_04071_LCD1__RawSend(0x32, 0);

    FCI_DELAYBYTE_MS(2);

    FCD_04071_LCD1__RawSend(0x2c, 0);

  #endif

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x06, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x0c, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x01, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x02, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__Clear();

  #if (0) // 0 > 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

#define FCA_LCD_BL0169 0x49e1
#define FCV_LCD_BL0169 0x0011

/*========================================================================*\
   Use :LCD_BL0169
       :GUID: ee697d50-7fb5-4074-8cd6-996e5c386722
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\LCD_BL0169.fcpx
       :Version: 5.0 (0x100028)
       :Timestamp: 17\06\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__Clear()
{

  FCD_04071_LCD1__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{

  FCD_04071_LCD1__PrintString(FCL_TEXT, FCLsz_TEXT);

}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

  FCD_04071_LCD1__PrintAscii(FCL_CHARACTER);

}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintNumber(MX_SINT16 FCL_NUMBER)
{

  FCD_04071_LCD1__PrintNumber(FCL_NUMBER);

}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

  FCD_04071_LCD1__RAMWrite(FCL_INDEX, FCL_D0, FCL_D1, FCL_D2, FCL_D3, FCL_D4, FCL_D5, FCL_D6, FCL_D7);

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__ClearLine(MX_UINT8 FCL_LINE)
{

  FCD_04071_LCD1__ClearLine(FCL_LINE);

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

  FCD_04071_LCD1__Cursor(FCL_X, FCL_Y);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{

  FCD_04071_LCD1__PrintFormattedNumber(FCL_NUMBER, FCL_FORMAT);

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{

  FCD_04071_LCD1__RawSend(FCL_DATA, FCL_TYPE);

}

/*=----------------------------------------------------------------------=*\
   Use :Print a Float number rounded up to a specified amount of decimal places.
       :
       :Parameters for macro PrintFloat:
       :  Number : Enter the number or variable to print to the LCD
       :  DecimalPlaces : Enter how many decimal places to round up to (1 - 6)
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_DECIMALPLACES)
{
  //Local variable definitions
  #define FCLsz_S 10
  MX_CHAR FCL_S[FCLsz_S];


  if (FCL_DECIMALPLACES > 6)
  {  

    FCL_DECIMALPLACES = 6;

  } else {

    if (FCL_DECIMALPLACES < 1)
    {    

      FCL_DECIMALPLACES = 1;

    // } else {

    }

  }

  FCI_FLOAT_TO_STRING(FCL_NUMBER, FCL_DECIMALPLACES, FCL_S, FCLsz_S);

  FCD_049e1_LCD_BL0169__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

  FCD_04071_LCD1__RemapCharacter(FCL_REMAPIDX, FCL_SEARCHCHARACTER, FCL_REPLACEMENTCHARACTER);

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__Start()
{

  FCD_04071_LCD1__Start();

}

#define FCA_TEXT2 0x2262
#define FCV_TEXT2 0x000f
#define FCA_TEXT9 0x2261
#define FCV_TEXT9 0x000d

/*========================================================================*\
   Use :User Project
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_MSG 20
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT16 FCV_INCREMENTNUMBER;
MX_GLOBAL MX_CHAR FCV_MSG[FCVsz_MSG];
MX_GLOBAL MX_UINT8 FCV_SERVO_POSITION = (0x0);
MX_GLOBAL MX_UINT8 FCV_BTN;



/*========================================================================*\
   Use :Main
\*========================================================================*/
void app_main()
{
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    gpio_config_t usb_phy_conf = {
        .pin_bit_mask = (1ULL << 19) | (1ULL << 20),
        .mode = GPIO_MODE_INPUT_OUTPUT,
        .pull_up_en = 0,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE,
    };
    gpio_config(&usb_phy_conf);


  // Component Macro
  FCD_049e1_LCD_BL0169__Start();

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintString("Servo motor test", 17);

  // Delay
  FCI_DELAYBYTE_S(1);

  // Component Macro
  FCD_0dd21_Servo_Controller1__Initialise();

  // Component Macro
  FCD_0dd21_Servo_Controller1__EnableServo(0);

  // Loop
  while (1)
  {
    // Component Macro
    FCD_049e1_LCD_BL0169__Clear();

    // Component Macro
    FCV_SERVO_POSITION = FCD_00a21_Potentiometer1__GetByte();

    // Component Macro
    FCD_049e1_LCD_BL0169__Cursor(0, 0);

    // Component Macro
    FCD_049e1_LCD_BL0169__PrintNumber(FCV_SERVO_POSITION);

    // Component Macro
    FCD_0dd21_Servo_Controller1__SetPosition(0, FCV_SERVO_POSITION);

    // Delay
    FCI_DELAYINT_MS(500);

  }

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
	#ifdef USE_FLOWCODE_ICD3
		ICD_INTERRUPT_HANDLER
	#endif

  // C Code
  MX_CCP1_INT_START
  {

  //Comment:
  //Servo Mark - each channel fires once for at least Minimum us
  //Up to Maximum us

  // Needed because variable is lost
  MX_UINT32 FCL_SERVOCAL;
  MX_SINT16 FCL_TRIM;

  if (FCV_0dd21_Servo_Controller1__SERVO_IDX < 1)
  {

    if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (0x01 << FCV_0dd21_Servo_Controller1__SERVO_IDX))
    {  

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 0)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #if (MX_Servo_Channel_Count > 1)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 1)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 2)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 2)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 3)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 3)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 4)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 4)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 5)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 5)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 6)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 6)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 7)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 7)
      {    

        SET_PORT_PIN(C, 0, 1);

      // } else {

      }

      // C Code
      #endif

    // } else {

    }

  // } else {

  }

  FCL_SERVOCAL = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX];
  FCL_SERVOCAL = FCL_SERVOCAL + 30030;
  FCL_SERVOCAL = FCL_SERVOCAL + FCV_0dd21_Servo_Controller1__SERVO_TRIM[FCV_0dd21_Servo_Controller1__SERVO_IDX];

  //Comment:
  //These did work to give a slightly more accurate top end
  //However using it Medelec experienced problems with max duty bleeding
  //and effecting other channels.

  #if 0 // Disabled code
  if (1 == 1)
  {

    FCL_SERVOCAL = FCL_SERVOCAL + (FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] >> 1);

  // } else {

  }

  #endif // Disabled code

  #if 0 // Disabled code
  if (FCL_SERVOCAL > ((36 << 8) | 248))
  {

    FCL_SERVOCAL = ((36 << 8) | 248);

  // } else {

  }

  #endif // Disabled code

  // C Code
  #if defined MX_CAL_STARM
  	MX_CONFIG_OC_SERVO.Pulse = FCL_SERVOCAL;
  	HAL_TIM_OC_ConfigChannel(&MX_HANDLE_TIM_SERVO, &MX_CONFIG_OC_SERVO, TIM_CHANNEL_1);
  
  #elif defined MX_CAL_ARM
  	AT91C_BASE_TC2->TC_RA = FCL_SERVOCAL;											//Setup capture compare registers
  
  #elif defined MX_CAL_ESP
  
  #else
  	#ifdef MX_CAL_PIC16
  		PR2 = FCL_SERVOCAL;
  		TMR2 = 0;
  		T2CON = 0x8000;
  	#else
  		MX_SERVO_REG_CCPR2H = ( FCL_SERVOCAL >> 8 );								//Setup capture compare registers
  		MX_SERVO_REG_CCPR2L = ( FCL_SERVOCAL & 0xFF );
  	#endif
  #endif

  if (1)
  {

    //Comment:
    //Only PIC16 can run fast enough for problems?

    // C Code
    #ifdef MX_CAL_PIC16
    
      T2CON |= 0x0010;
    
    #endif

  // } else {

  }

  // C Code
  #if defined MX_CAL_STARM
  
  #elif defined MX_CAL_ESP
  
  #elif defined MX_CAL_PIC16
  	MX_SERVO_REG_CCP1F.MX_SERVO_FLAG_CCP1F = 0;											//Clear interrupt
  #else
  	cr_bit(MX_SERVO_REG_CCP1F, MX_SERVO_FLAG_CCP1F);									//Clear interrupt
  #endif

  // C Code
  }
  
  
  MX_CCP2_INT_START
  {

  // Needed because variables are lost
  MX_SINT16 FCL_CALC;

  //Comment:
  //Servo Space - Fills the remainder of the period with output low

  if (FCV_0dd21_Servo_Controller1__SERVO_IDX < 1)
  {

    if (FCV_0dd21_Servo_Controller1__SERVO_ENABLED & (0x01 << FCV_0dd21_Servo_Controller1__SERVO_IDX))
    {  

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 0)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #if (MX_Servo_Channel_Count > 1)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 1)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 2)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 2)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 3)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 3)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 4)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 4)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 5)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 5)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 6)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 6)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #endif
      
      #if (MX_Servo_Channel_Count > 7)

      if (FCV_0dd21_Servo_Controller1__SERVO_IDX == 7)
      {    

        SET_PORT_PIN(C, 0, 0);

      // } else {

      }

      // C Code
      #endif

      if (FCV_0dd21_Servo_Controller1__SERVO_FLAG_DISABLE & (0x01 << FCV_0dd21_Servo_Controller1__SERVO_IDX))
      {    

        FCV_0dd21_Servo_Controller1__SERVO_ENABLED = FCV_0dd21_Servo_Controller1__SERVO_ENABLED & ~(1 << FCV_0dd21_Servo_Controller1__SERVO_IDX);
        FCV_0dd21_Servo_Controller1__SERVO_FLAG_DISABLE = FCV_0dd21_Servo_Controller1__SERVO_FLAG_DISABLE & ~(1 << FCV_0dd21_Servo_Controller1__SERVO_IDX);

      // } else {

      }

    // } else {

    }

  // } else {

  }

  FCV_0dd21_Servo_Controller1__SERVO_IDX = (FCV_0dd21_Servo_Controller1__SERVO_IDX + 1) & 0x07;

  if (FCV_0dd21_Servo_Controller1__AUTOMOVING & (1 << FCV_0dd21_Servo_Controller1__SERVO_IDX))
  {

    if (FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] > FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX])
    {  

      if ((FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] + FCV_0dd21_Servo_Controller1__AUTOMOVESPEED) < FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX])
      {    

        FCL_CALC = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] + FCV_0dd21_Servo_Controller1__AUTOMOVESPEED;

        if (FCL_CALC > 44625)
        {      

          FCL_CALC = 44625;

        // } else {

        }

      } else {

        FCL_CALC = FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX];

      }

      FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = FCL_CALC;

    } else {

      if (FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX] < FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX])
      {    

        if ((FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] - FCV_0dd21_Servo_Controller1__AUTOMOVESPEED) > FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX])
        {      

          FCL_CALC = FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] - FCV_0dd21_Servo_Controller1__AUTOMOVESPEED;

        } else {

          FCL_CALC = FCV_0dd21_Servo_Controller1__SERVO_REQUIRED[FCV_0dd21_Servo_Controller1__SERVO_IDX];

        }

        FCV_0dd21_Servo_Controller1__SERVO_POSITION[FCV_0dd21_Servo_Controller1__SERVO_IDX] = FCL_CALC;

      } else {

        FCV_0dd21_Servo_Controller1__AUTOMOVING = FCV_0dd21_Servo_Controller1__AUTOMOVING & ~(1 << FCV_0dd21_Servo_Controller1__SERVO_IDX);

      }

    }

  // } else {

  }

  // C Code
  #if defined MX_CAL_STARM
  
  #elif defined MX_CAL_ESP
  
  #elif defined MX_CAL_PIC16
  	T2CON = 0;
  	MX_SERVO_REG_CCP2F.MX_SERVO_FLAG_CCP2F = 0;								//Clear interrupt
  #else
  	cr_bit(MX_SERVO_REG_CCP2F, MX_SERVO_FLAG_CCP2F);						//Clear interrupt
  #endif

  // C Code
  }




