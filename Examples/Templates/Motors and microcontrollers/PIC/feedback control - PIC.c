// CRC: C09139DD0A75D64CECB6A655701556ECB3779E843346CE0F5130EA7DD15162532F19E22CED7E2D79FCA1D712F9F4A73B1790799BE3387D93492B2739DFD6F390EA86995873165087177459893585281C686A9056384CCBB9CE2D824EFAA61AFF6E4F71DE29CF3BD0059AEDDE67088793E25E38DDEBCD8688F1D21CA3DFA187DD9B008837450503992D9D94AE6EC26A9416B7C00C5C2A7C42ED1C6AE80F0EBC61681554E29EDC773C0C3CAEE8E7DA6987F4A4EB740F41C3BAA595FBBB2AFBBCCE8B875C6B4DFE052156B5FB59581729F2C251F8F0864C0B852A1533B8B9F9CFA43DC0FD5461EC63C053304B7C716AAF951C19EAC5150F98C0B3EAFE9E3E91EEA814F197E63469B8A1549D34A0D5AD11F3464282909DBCBB6B02ADEA84D06AE4887874B7C1919677A161112B2378F6127E5D3A7ED706D09BBA
// REVISION: 1.0
// GUID: 389655F2-6D6B-41ED-98CE-5C1CDF9755FA
// DATE: 11\12\2025
// DIR: Misc\Templates\Motors|and|microcontrollers\PIC\feedback|control|-|PIC.c
//************************************************************************************
//**  
//**  Source name:   \\IRONMAN-PC2\Dev\Flowcode V11\Examples\Templates\Motors and microcontrollers\PIC\feedback control - PIC.fcfx
//**  Title:         Feedback Control - PIC
//**  Description:   
//**  Device:        PIC.18F.E-blocks3 8-bit PIC
//**  
//**  Generated by:  Flowcode v11.0.0.8
//**  Date:          Thursday, December 11, 2025 12:33:44
//**  Users:         1
//**  Registered to: JohnD (65060919)
//**  Licence key: MNBNUH
//**  
//**  
//**  https://www.flowcode.co.uk
//**  
//************************************************************************************


#include "\\IRONMAN-PC2\Dev\Flowcode V11\Examples\Templates\Motors and microcontrollers\PIC\feedback control - PIC.h"

#define FCA_TIMER1 0x26e1
#define FCV_TIMER1 0x0b9f

/*========================================================================*\
   Use :Timer1
       :GUID: 24ad2718-c70b-4088-aeda-3949dfdba740
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Timer.fcpx
       :Version: 22.0 (0xe00028)
       :Timestamp: 07\02\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_026e1_Timer1__RUNNING = (0x0);
MX_GLOBAL MX_UINT16 FCV_026e1_Timer1__TCOUNTSAVE = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Returns the count value as a number of whole seconds, rounded down to the nearest second
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_026e1_Timer1__GetCountSeconds()
{
  //Local variable definitions
  MX_UINT32 FCL_COUNT;
  MX_FLOAT FCL_FVAR;
  MX_UINT32 FCR_RETVAL;


  FCL_COUNT = FCD_026e1_Timer1__GetRawCount();

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    FCL_FVAR = flt_mul(0.008000, flt_fromi(FCL_COUNT));
    FCR_RETVAL = flt_toi(flt_div(FCL_FVAR, 1000.0));

  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Starts the timer counting.
       :
       :Parameters for macro StartCounter:
       :  ResetCounters : Range: 0-1 where 0=Do Not Reset and 1=Reset
\*=----------------------------------------------------------------------=*/
void FCD_026e1_Timer1__StartCounter(MX_BOOL FCL_RESETCOUNTERS)
{

  if (FCL_RESETCOUNTERS)
  {  

    FCD_026e1_Timer1__ResetCounter();

  } else {

    FCD_026e1_Timer1__RestoreCounter();

  }

  #if (0) // 2 == 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (1) // 2 == 2
    // Enable Interrupt
    Timer_2_Enable

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0) // 2 == 3
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 4
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 5
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 6
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 7
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 8
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 9
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  // ::System.TimerStart(0, TimerDelay)

#if 0 // Disabled code
  // ::Component.Property.SetColor(TimerStatus, 0, 0xC0, 0)

#endif // Disabled code

  // OnOffIndicator1::SwitchOn()

  FCV_026e1_Timer1__RUNNING = 1;

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the count value as a floating point string in seconds.
       :
       :Parameters for macro GetCountString:
       :  Precision : Number of decimal places to display in string
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_026e1_Timer1__GetCountString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_PRECISION)
{
  //Local variable definitions
  MX_FLOAT FCL_FVAR;


  FCL_FVAR = FCD_026e1_Timer1__GetCountReal();

  FCI_FLOAT_TO_STRING(FCL_FVAR, FCL_PRECISION, FCR_RETVAL, FCRsz_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_026e1_Timer1__RestoreCounter()
{
  //Local variable definitions
  MX_UINT16 FCL_COUNTSAVE;


  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    FCL_COUNTSAVE = FCV_026e1_Timer1__TCOUNTSAVE;

    #if (0) // 2 == 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (1) // 2 == 2
      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      // C Code
      Timer_2_CountRegLow = FCL_COUNTSAVE;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 2 == 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 8
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 9
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    FCV_026e1_Timer1__TCOUNTSAVE = 0;

  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the count value as a number of whole microseconds, rounded down to the nearest microsecond
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_026e1_Timer1__GetCountMicroSeconds()
{
  //Local variable definitions
  MX_UINT32 FCL_COUNT;
  MX_FLOAT FCL_FVAR;
  MX_UINT32 FCR_RETVAL;


  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    FCL_COUNT = FCD_026e1_Timer1__GetRawCount();

    FCL_FVAR = flt_mul(0.008000, flt_fromi(FCL_COUNT));
    FCR_RETVAL = flt_toi(flt_mul(FCL_FVAR, 1000.0));

  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the count value as a number of whole milliseconds, rounded down to the nearest millisecond
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_026e1_Timer1__GetCountMilliseconds()
{
  //Local variable definitions
  MX_UINT32 FCL_COUNT;
  MX_FLOAT FCL_FVAR;
  MX_UINT32 FCR_RETVAL;


  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    FCL_COUNT = FCD_026e1_Timer1__GetRawCount();

    FCL_FVAR = flt_mul(0.008000, flt_fromi(FCL_COUNT));
    FCR_RETVAL = flt_toi(FCL_FVAR);

  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Stops the timer counting.
\*=----------------------------------------------------------------------=*/
void FCD_026e1_Timer1__StopCounter()
{
  //Local variable definitions
  MX_UINT16 FCL_TMRSAVE;


  FCL_TMRSAVE = 0;

  #if (0) // 2 == 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (1) // 2 == 2
    #if (0)
    //Code has been optimised out by the pre-processor
    #else
      // C Code
      FCL_TMRSAVE = Timer_2_CountRegLow;

      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

    #endif

    // Enable Interrupt
    Timer_2_Disable

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0) // 2 == 3
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 4
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 5
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 6
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 7
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 8
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 2 == 9
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  FCV_026e1_Timer1__RUNNING = 0;

  // ::System.TimerStop(0)

#if 0 // Disabled code
  // ::Component.Property.SetColor(TimerStatus, 0x80, 0, 0)

#endif // Disabled code

  // OnOffIndicator1::SwitchOff()

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    FCV_026e1_Timer1__TCOUNTSAVE = FCL_TMRSAVE;

  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_026e1_Timer1__ResetCounter()
{

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    FCV_026e1_Timer1__TCOUNTSAVE = 0;

    #if (0) // 2 == 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (1) // 2 == 2
      // C Code
      Timer_2_CountRegLow = 1;

      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      // Code
      TIM_2_COUNTER = 0;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 2 == 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 8
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 9
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the count value as a floating point value in seconds.
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_026e1_Timer1__GetCountReal()
{
  //Local variable definitions
  MX_UINT32 FCL_COUNT;
  MX_FLOAT FCR_RETVAL;


  FCL_COUNT = FCD_026e1_Timer1__GetRawCount();

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    FCR_RETVAL = flt_mul(0.008000, flt_fromi(FCL_COUNT));
    FCR_RETVAL = flt_div(FCR_RETVAL, 1000.0);

  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Efficient command to collect the integer number of instructions since the timer was started.
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_026e1_Timer1__GetRawCount()
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    #if (0) // 2 == 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (1) // 2 == 2
      // C Code
      FCR_RETVAL = TIM_2_COUNTER;

      FCR_RETVAL = FCR_RETVAL << 8;

      if (FCV_026e1_Timer1__RUNNING)
      {      

        // C Code
        FCR_RETVAL = FCR_RETVAL | Timer_2_CountRegLow;

        #if (0)
        //Code has been optimised out by the pre-processor
        // #else
        #endif

      } else {

        FCR_RETVAL = FCR_RETVAL + FCV_026e1_Timer1__TCOUNTSAVE;

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 2 == 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 8
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 2 == 9
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :cal_adc
       :GUID: e77a4e40-e0df-431a-98f8-7ae4d8ebfbeb
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\cal_adc.fcpx
       :Version: 6.0 (0x200028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)


/*========================================================================*\
   Use :adc_base1
       :GUID: 9b845489-48f5-4fa5-aace-2c97efdcede3
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\adc_base_2d.fcpx
       :Version: 4.0 (0x100328)
       :Timestamp: 08\05\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0cc51_adc_base1__RawSampleInt()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = FC_ADC_Sample_1(1);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT16 FCL_AVERAGE = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT8 FCR_RETVAL;


  if (FCL_DELAYUS > 0)
  {  

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(1, 31, 0, FCL_DELAYUS);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(0);
      FCL_COUNT = FCL_COUNT + 1;

    }

  } else {

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(1, 31, 0, 40);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(0);
      FCL_COUNT = FCL_COUNT + 1;

    }

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as a string
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_0cc51_adc_base1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
  //Local variable definitions
  MX_FLOAT FCL_SAMPLE;


  FCL_SAMPLE = FCD_0cc51_adc_base1__GetVoltage();

  FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL, FCRsz_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = FCD_0cc51_adc_base1__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_0cc51_adc_base1__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT32 FCL_AVERAGE = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_SINT16 FCR_RETVAL;


  if (FCL_DELAYUS > 0)
  {  

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(1, 31, 0, FCL_DELAYUS);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(1);
      FCL_COUNT = FCL_COUNT + 1;

    }

  } else {

    while (FCL_COUNT < FCL_NUMSAMPLES)
    {
      FC_ADC_Enable_1(1, 31, 0, 40);

      FCL_AVERAGE = FCL_AVERAGE + FC_ADC_Sample_1(1);
      FCL_COUNT = FCL_COUNT + 1;

    }

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0cc51_adc_base1__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = FCD_0cc51_adc_base1__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_0cc51_adc_base1__GetVoltage()
{
  //Local variable definitions
  MX_UINT16 FCL_SAMPLE;
  MX_FLOAT FCR_RETVAL;


  FC_ADC_Enable_1(1, 31, 0, 40);

  FCL_SAMPLE = FC_ADC_Sample_1(1);

  FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.003223);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_0cc51_adc_base1__RawEnable()
{

  FC_ADC_Enable_1(1, 31, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__RawSampleByte()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = FC_ADC_Sample_1(0);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0cc51_adc_base1__GetInt()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FC_ADC_Enable_1(1, 31, 0, 40);

  FCR_RETVAL = FC_ADC_Sample_1(1);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_0cc51_adc_base1__RawDisable()
{

  FC_ADC_Disable_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0cc51_adc_base1__GetByte()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FC_ADC_Enable_1(1, 31, 0, 40);

  FCR_RETVAL = FC_ADC_Sample_1(0);

  FC_ADC_Disable_1();

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :MapFunction1
       :GUID: ccdce31d-a1a3-437a-88ba-5431745ddf6e
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\MapFunction.fcpx
       :Version: 7.0 (0x200028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Map function for unsigned long type variables
       :
       :Parameters for macro MapUlong:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0c431_MapFunction1__MapUlong(MX_UINT32 FCL_VALUE, MX_UINT32 FCL_INMIN, MX_UINT32 FCL_INMAX, MX_UINT32 FCL_OUTMIN, MX_UINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = (FCL_VALUE - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for signed int type variables
       :
       :Parameters for macro MapInt:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_0c431_MapFunction1__MapInt(MX_SINT16 FCL_VALUE, MX_SINT16 FCL_INMIN, MX_SINT16 FCL_INMAX, MX_SINT16 FCL_OUTMIN, MX_SINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_SINT32 FCL_TEMP;
  MX_SINT16 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for floating point type variables
       :
       :Parameters for macro MapFloat:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_0c431_MapFunction1__MapFloat(MX_FLOAT FCL_VALUE, MX_FLOAT FCL_INMIN, MX_FLOAT FCL_INMAX, MX_FLOAT FCL_OUTMIN, MX_FLOAT FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (flt_lt(FCL_VALUE, FCL_INMIN))
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (flt_gt(FCL_VALUE, FCL_INMAX))
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = flt_add(flt_div(flt_mul((flt_sub(FCL_VALUE, FCL_INMIN)), (flt_sub(FCL_OUTMAX, FCL_OUTMIN))), (flt_sub(FCL_INMAX, FCL_INMIN))), FCL_OUTMIN);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for signed long type variables
       :
       :Parameters for macro MapLong:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_SINT32
\*=----------------------------------------------------------------------=*/
MX_SINT32 FCD_0c431_MapFunction1__MapLong(MX_SINT32 FCL_VALUE, MX_SINT32 FCL_INMIN, MX_SINT32 FCL_INMAX, MX_SINT32 FCL_OUTMIN, MX_SINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_SINT32 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = (FCL_VALUE - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for unsigned int type variables
       :
       :Parameters for macro MapUInt:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0c431_MapFunction1__MapUInt(MX_UINT16 FCL_VALUE, MX_UINT16 FCL_INMIN, MX_UINT16 FCL_INMAX, MX_UINT16 FCL_OUTMIN, MX_UINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT32 FCL_TEMP;
  MX_UINT16 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for byte type variables
       :
       :Parameters for macro MapByte:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c431_MapFunction1__MapByte(MX_UINT8 FCL_VALUE, MX_UINT8 FCL_INMIN, MX_UINT8 FCL_INMAX, MX_UINT8 FCL_OUTMIN, MX_UINT8 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT8 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :IsSim1
       :GUID: 5f7b77e5-e979-4010-93f1-e6d98f83bd71
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\IsSim.fcpx
       :Version: 6.0 (0x100028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Returns 0 if running on an embedded target or 1 if running in simulation runtime.
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_0b4c1_IsSim1__Check()
{
  //Local variable definitions
  MX_BOOL FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

#define FCA_POTENTIOMETER1 0x0a21
#define FCV_POTENTIOMETER1 0x0abf

/*========================================================================*\
   Use :Potentiometer1
       :GUID: 11ca2f38-de81-4812-9338-4b5a7a89a658
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Potentiometer.fcpx
       :Version: 21.0 (0x100028)
       :Timestamp: 06\05\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_00a21_Potentiometer1__H;
MX_GLOBAL MX_SINT16 FCV_00a21_Potentiometer1__CHANNEL = (0);

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_00a21_Potentiometer1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
  //Local variable definitions
  MX_FLOAT FCL_VOLTAGE = (0.0);


  FCL_VOLTAGE = FCD_0cc51_adc_base1__GetVoltage();

  FCI_FLOAT_TO_STRING(FCL_VOLTAGE, FCV_PRECISION, FCR_RETVAL, FCRsz_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC as a byte
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_00a21_Potentiometer1__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT16 FCL_AVERAGE = (0x0);
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  while (FCL_COUNT < FCL_NUMSAMPLES)
  {
    FCR_RETVAL = FCD_0cc51_adc_base1__GetByte();

    FCI_DELAYBYTE_US(FCL_DELAYUS);

    FCL_AVERAGE = FCL_AVERAGE + FCR_RETVAL;
    FCL_COUNT = FCL_COUNT + 1;

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC at full bit depth
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00a21_Potentiometer1__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
  //Local variable definitions
  MX_UINT32 FCL_AVERAGE = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  while (FCL_COUNT < FCL_NUMSAMPLES)
  {
    FCR_RETVAL = FCD_0cc51_adc_base1__GetInt();

    FCI_DELAYBYTE_US(FCL_DELAYUS);

    FCL_AVERAGE = FCL_AVERAGE + FCR_RETVAL;
    FCL_COUNT = FCL_COUNT + 1;

  }

  FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_00a21_Potentiometer1__GetVoltage()
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  FCR_RETVAL = 0;

  FCR_RETVAL = FCD_0cc51_adc_base1__GetVoltage();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00a21_Potentiometer1__GetInt()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCR_RETVAL = FCD_0cc51_adc_base1__GetInt();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_00a21_Potentiometer1__GetByte()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCR_RETVAL = FCD_0cc51_adc_base1__GetByte();

  return (FCR_RETVAL);

}

#define FCA_TEXT3 0x2646
#define FCV_TEXT3 0x0abd

/*========================================================================*\
   Use :TimedInterval1
       :GUID: d7633558-54a4-47ff-8c00-95170632c57e
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\TimedInterval.fcpx
       :Version: 10.0 (0x100228)
       :Timestamp: 01\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_00a91_TimedInterval1__RUNNING = (0x0);
MX_GLOBAL MX_UINT32 FCV_00a91_TimedInterval1__INTCOUNT = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Starts the timer interval.
\*=----------------------------------------------------------------------=*/
void FCD_00a91_TimedInterval1__StartTimerInterval()
{

  FCV_00a91_TimedInterval1__INTCOUNT = 0;

  #if (1) // 1 == 1
    // Enable Interrupt
    TimerInterval_1_Enable

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0) // 1 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 == 3
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 == 4
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  // ::System.TimerStart(0, TimerDelay)

  // OnOffIndicator1::SwitchOn()

  FCV_00a91_TimedInterval1__RUNNING = 1;

}

/*=----------------------------------------------------------------------=*\
   Use :Stops the timer interval.
\*=----------------------------------------------------------------------=*/
void FCD_00a91_TimedInterval1__StopTimerInterval()
{
  //Local variable definitions
  MX_UINT16 FCL_TMRSAVE;


  FCL_TMRSAVE = 0;

  #if (1) // 1 == 1
    // Enable Interrupt
    TimerInterval_1_Disable

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0) // 1 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 == 3
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 1 == 4
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  FCV_00a91_TimedInterval1__RUNNING = 0;

  // ::System.TimerStop(0)

  // OnOffIndicator1::SwitchOff()

}

#define FCA_DCMOTOR1 0x4891
#define FCV_DCMOTOR1 0x0799

/*========================================================================*\
   Use :DCMotor1
       :GUID: 4b0e5196-0db2-45a9-bcb9-b172f71f9c4d
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\DCMotor.fcpx
       :Version: 13.0 (0x100228)
       :Timestamp: 06\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_04891_DCMotor1__SW_PWM_STATE = (0x0);
MX_GLOBAL MX_BOOL FCV_04891_DCMotor1__ENABLED = (0);
MX_GLOBAL MX_UINT16 FCV_04891_DCMotor1__SW_PWM_DUTY = (0x0);
MX_GLOBAL MX_UINT16 FCV_04891_DCMotor1__SW_PWM_COUNT = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Turn off power to the motor by setting the pins according to the 'Coast Pattern' property.
\*=----------------------------------------------------------------------=*/
void FCD_04891_DCMotor1__Coast()
{
  //Local variable definitions
  MX_UINT8 FCL_DUMMY;


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Actively drives both ends of the motor by setting the pins according to the 'Brake Pattern' property.
\*=----------------------------------------------------------------------=*/
void FCD_04891_DCMotor1__Break()
{

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Disable the motor output
\*=----------------------------------------------------------------------=*/
void FCD_04891_DCMotor1__Disable()
{
  //Local variable definitions
  MX_UINT8 FCL_DUMMY;


  FCV_04891_DCMotor1__ENABLED = 0;

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (1) // 3 == 3
    FCD_00a91_TimedInterval1__StopTimerInterval();

  // #else
  //Code has been optimised out by the pre-processor
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Set the motor turning in the forwards direction by setting the pins according to the 'Forwards Pattern' property.
       :
       :Parameters for macro Forwards:
       :  Duty : Sets the motor power for PWM or H-Bridge outputs
\*=----------------------------------------------------------------------=*/
void FCD_04891_DCMotor1__Forwards(MX_UINT16 FCL_DUTY)
{

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (1) // 3 == 3
    FCV_04891_DCMotor1__SW_PWM_STATE = 0;
    FCV_04891_DCMotor1__SW_PWM_DUTY = FCL_DUTY;

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the motor output
\*=----------------------------------------------------------------------=*/
void FCD_04891_DCMotor1__Enable()
{

  FCV_04891_DCMotor1__ENABLED = 1;

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 3 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (1) // 3 == 3
    FCD_00a91_TimedInterval1__StartTimerInterval();

  // #else
  //Code has been optimised out by the pre-processor
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Set the motor turning in the reverse direction by setting the pins according to the 'Reverse Pattern' property.
       :
       :Parameters for macro Reverse:
       :  Duty : Sets the motor power for PWM or H-Bridge outputs
\*=----------------------------------------------------------------------=*/
void FCD_04891_DCMotor1__Reverse(MX_UINT16 FCL_DUTY)
{

  #if (1)
    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 3 == 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 3 == 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 3 == 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (1) // 3 == 3
      FCV_04891_DCMotor1__SW_PWM_STATE = 1;
      FCV_04891_DCMotor1__SW_PWM_DUTY = FCL_DUTY;

      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_04891_DCMotor1__TimerRoutine()
{

  FCV_04891_DCMotor1__SW_PWM_COUNT = FCV_04891_DCMotor1__SW_PWM_COUNT + 1;

  if (FCV_04891_DCMotor1__SW_PWM_COUNT == 255)
  {  

    FCV_04891_DCMotor1__SW_PWM_COUNT = 0;

    if (FCV_04891_DCMotor1__SW_PWM_DUTY)
    {    

      if (FCV_04891_DCMotor1__SW_PWM_STATE)
      {      

        SET_PORT_PIN(E, 1, 2 & 1);

        #if (1)
          SET_PORT_PIN(E, 2, (2 & 2) >> 1);

        // #else
        //Code has been optimised out by the pre-processor
        #endif

      } else {

        SET_PORT_PIN(E, 1, 1 & 1);

        #if (1)
          SET_PORT_PIN(E, 2, (1 & 2) >> 1);

        // #else
        //Code has been optimised out by the pre-processor
        #endif

      }

    // } else {

    }

  // } else {

  }

  if (FCV_04891_DCMotor1__SW_PWM_COUNT == FCV_04891_DCMotor1__SW_PWM_DUTY)
  {  

    #if (0) // 0 == 1
    //Code has been optimised out by the pre-processor
    #else
      SET_PORT_PIN(E, 1, 0 & 1);

      #if (1)
        SET_PORT_PIN(E, 2, (0 & 2) >> 1);

      // #else
      //Code has been optimised out by the pre-processor
      #endif

    #endif

  // } else {

  }

}


/*========================================================================*\
   Use :WidthData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb2_WidthData__FLOATFIXEDLIST 200000
#define FCVsz_00fb2_WidthData__INTFIXEDLIST 95
#define FCD_00fb2_WidthData__INTFIXEDLIST(ix) 0

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb2_WidthData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 95;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :ASCIIData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 17.0 (0x100828)
       :Timestamp: 10\11\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1_ASCIIData__FLOATFIXEDLIST 200000
#define FCVsz_00fb1_ASCIIData__INTFIXEDLIST 475
#define FCD_00fb1_ASCIIData__INTFIXEDLIST(ix) FCD_00fb1_ASCIIData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCIIData__INTFIXEDLIST_LUT ROMARRAY_E =
{
0x00,0x06,0x5F,0x06,0x00,0x07,0x03,0x00,0x07,0x03,0x24,0x7E,0x24,0x7E,0x24,0x24,0x2B,0x6A,0x12,0x00,0x63,0x13,0x08,0x64,0x63,0x36,0x49,0x56,0x20,0x50,0x00,0x07,0x03,0x00,0x00,0x00,0x3E,0x41,0x00,0x00,0x00,0x41,0x3E,0x00,0x00,0x08,0x3E,0x1C,0x3E,0x08,0x08,0x08,0x3E,0x08,0x08,0x00,0xE0,0x60,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x60,0x60,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x3E,0x51,0x49,0x45,0x3E,0x00,0x42,0x7F,0x40,0x00,0x62,0x51,0x49,0x49,0x46,0x22,0x49,0x49,0x49,0x36,0x18,0x14,0x12,0x7F,0x10,0x27,0x45,0x45,0x45,0x39,0x3C,0x4A,0x49,0x49,0x30,0x01,0x71,0x09,0x05,0x03,0x36,0x49,0x49,0x49,0x36,0x06,0x49,0x49,0x29,0x1E,0x00,0x6C,0x6C,0x00,0x00,0x00,0xEC,0x6C,0x00,0x00,0x08,0x14,0x22,0x41,0x00,0x24,0x24,0x24,0x24,0x24,0x00,0x41,0x22,0x14,0x08,0x02,0x01,0x59,0x09,0x06,0x3E,0x41,0x5D,0x55,0x1E,0x7E,0x09,0x09,0x09,0x7E,0x7F,0x49,0x49,0x49,0x36,0x3E,0x41,0x41,0x41,0x22,0x7F,0x41,0x41,0x41,0x3E,0x7F,0x49,0x49,0x49,0x41,0x7F,0x09,0x09,0x09,0x01,0x3E,0x41,0x49,0x49,0x7A,0x7F,0x08,0x08,0x08,0x7F,0x00,0x41,0x7F,0x41,0x00,0x30,0x40,0x40,0x40,0x3F,0x7F,0x08,0x14,0x22,0x41,0x7F,0x40,0x40,0x40,0x40,0x7F,0x02,0x04,0x02,0x7F,0x7F,0x02,0x04,0x08,0x7F,0x3E,0x41,0x41,0x41,0x3E,0x7F,0x09,0x09,0x09,0x06,0x3E,0x41,0x51,0x21,0x5E,0x7F,0x09,0x09,0x19,0x66,0x26,0x49,0x49,0x49,0x32,0x01,0x01,0x7F,0x01,0x01,0x3F,0x40,0x40,0x40,0x3F,0x1F,0x20,0x40,0x20,0x1F,0x3F,0x40,0x3C,0x40,0x3F,0x63,0x14,0x08,0x14,0x63,0x07,0x08,0x70,0x08,0x07,0x71,0x49,0x45,0x43,0x00,0x00,0x7F,0x41,0x41,0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x41,0x41,0x7F,0x00,0x04,0x02,0x01,0x02,0x04,0x80,0x80,0x80,0x80,0x80,0x00,0x03,0x07,0x00,0x00,0x20,0x54,0x54,0x54,0x78,0x7F,0x44,0x44,0x44,0x38,0x38,0x44,0x44,0x44,0x28,0x38,0x44,0x44,0x44,0x7F,0x38,0x54,0x54,0x54,0x18,0x08,0x7E,0x09,0x09,0x00,0x18,0xA4,0xA4,0xA4,0x7C,0x7F,0x04,0x04,0x78,0x00,0x00,0x00,0x7D,0x00,0x00,0x40,0x80,0x84,0x7D,0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00,0x7F,0x40,0x00,0x7C,0x04,0x18,0x04,0x78,0x7C,0x04,0x04,0x78,0x00,0x38,0x44,0x44,0x44,0x38,0xFC,0x44,0x44,0x44,0x38,0x38,0x44,0x44,0x44,0xFC,0x44,0x78,0x44,0x04,0x08,0x08,0x54,0x54,0x54,0x20,0x04,0x3E,0x44,0x24,0x00,0x3C,0x40,0x20,0x7C,0x00,0x1C,0x20,0x40,0x20,0x1C,0x3C,0x60,0x30,0x60,0x3C,0x6C,0x10,0x10,0x6C,0x00,0x9C,0xA0,0x60,0x3C,0x00,0x64,0x54,0x54,0x4C,0x00,0x08,0x3E,0x41,0x41,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x41,0x41,0x3E,0x08,0x02,0x01,0x02,0x01,0x00,0x06,0x09,0x09,0x06,0x00
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 475;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_Font1
       :GUID: 1b08885c-807e-4631-930e-a4fef06159dc
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_Font.fcpx
       :Version: 37.0 (0x1400028)
       :Timestamp: 12\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_09e51_gLCD_Font1__OLDCHAR = (0x0);
MX_GLOBAL MX_UINT32 FCV_09e51_gLCD_Font1__OLDPOSITION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Adds up all the pixels widths before the selected character to get to the start of the pixel data
       :
       :Parameters for macro SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_09e51_gLCD_Font1__SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH;
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (1)
    #if (0) // 1 == 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the width of the ASCII character font data
       :
       :Parameters for macro ReadWidth:
       :  Character : ASCII position so A = 'A'
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadWidth(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCL_PWIDTH;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 127 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (1)
      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 005;

      } else {

        FCR_RETVAL = 5;

      }

    #else
    //Code has been optimised out by the pre-processor
    #endif

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Collects a stat about the selected font
       :
       :Parameters for macro ReadFontStat:
       :  Index : 0=SpaceColumns, 1=CharacterHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadFontStat(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX == 1)
  {  

    FCR_RETVAL = 8;

  } else {

    FCR_RETVAL = 000;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single pixel column byte from the selected ASCII character font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  Character : ASCII position so A = 'A'
       :  ByteIndex : Range: 0 to ((PixelWidth - 1) * BytesPerColumn)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 127 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 127;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 95)))
    {    

      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 0;

      } else {

        //Comment:
        //Out of range

        FCR_RETVAL = 0xAA;

      }

    } else {

      FCL_CHARACTER = FCL_CHARACTER - 33;

      #if (1) // 1 == 1
        if (FCL_CHARACTER == FCV_09e51_gLCD_Font1__OLDCHAR)
        {        

          FCL_POSITION = FCV_09e51_gLCD_Font1__OLDPOSITION;

        } else {

          FCL_POSITION = FCL_CHARACTER * 5 * 1;

          FCV_09e51_gLCD_Font1__OLDPOSITION = FCL_POSITION;
          FCV_09e51_gLCD_Font1__OLDCHAR = FCL_CHARACTER;

        }

      #else
      //Code has been optimised out by the pre-processor
      #endif

      FCL_POSITION = FCL_POSITION + FCL_BYTEINDEX;

      FCR_RETVAL = FCD_00fb1_ASCIIData__INTFIXEDLIST(FCL_POSITION);

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :Base_GLCD1
       :GUID: 4384cba9-0bea-4359-8c5b-dcd046aa7778
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Base_GLCD.fcpx
       :Version: 53.0 (0x2300028)
       :Timestamp: 08\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME2 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME1 13
#define FCVsz_0ba71_Base_GLCD1__SPACEWIDTH 1
#define FCVsz_0ba71_Base_GLCD1__FONTHEADER 16
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME8 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME7 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME6 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME5 13
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME4 13
#define FCVsz_0ba71_Base_GLCD1__CHARSPACING 1
#define FCVsz_0ba71_Base_GLCD1__FONTFILENAME3 13

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0ba71_Base_GLCD1__Prv_SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH = (0x0);
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the number of pixel columns used in the selected font
       :
       :Parameters for macro ReadFontWidth:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character to get the pixel width e.g. 'A' or 65
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontWidth(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadWidth(FCL_CHARACTER);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_ReadFontFileHeader:
       :  Font : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD1__Prv_ReadFontFileHeader(MX_UINT8 FCL_FONT)
{
  //Local variable definitions
  MX_UINT8 FCL_RETVAL = (0x0);
  MX_UINT8 FCL_IDX = (0x0);
  #define FCLsz_TEST 20
  MX_CHAR FCL_TEST[FCLsz_TEST] = "";


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_TEST
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a stat from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontStat:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Index : 0=SpaceWidth, 1=PixelHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontStat(MX_UINT8 FCL_FONT, MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    //Comment:
    //Character Spacing comes from font component properties
    //specified by the user and independent of the font file.

    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadFontStat(FCL_INDEX);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows one of the default external font files to be switched out for a different font file.
       :
       :Parameters for macro SetExternalFont:
       :  Font : Range: 0 to (FontCount - 1)
       :  Filename[20] : New font filename
       :  CharacterSpacing : Number of pixel columns to use between each character
       :  SpaceWidth : Number of pixel columns to use for a space character
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD1__SetExternalFont(MX_UINT8 FCL_FONT, MX_CHAR *PFCL_FILENAME, MX_UINT8 FCL_CHARACTERSPACING, MX_UINT8 FCL_SPACEWIDTH)
{
  #define FCLsz_FILENAME 20
  MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
  FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontByte:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character for example 'A' or 65
       :  ByteIndex : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontByte(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0) // (0) && (FCL_CHARACTER != ' ')
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadASCIILUT(FCL_CHARACTER, FCL_BYTEINDEX);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :LCD1
       :GUID: 0953aac0-9c23-4c2f-9843-88954a4191ea
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\LCD.fcpx
       :Version: 6.0 (0x200528)
       :Timestamp: 10\10\2023
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Clear()
{

  // ctrl_lcd::Clear()

  // ::Component.Property.SetValue(this, "CursorPosX", 0)

  // ::Component.Property.SetValue(this, "CursorPosY", 0)

  FCD_04071_LCD1__RawSend(0x01, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x02, 0);

  FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
  //Local variable definitions
  MX_UINT8 FCL_IDX = (0x0);
  MX_UINT8 FCL_COUNT;


  FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

  while (FCL_IDX < FCL_COUNT)
  {
    #if (0) // 0 > 0
    //Code has been optimised out by the pre-processor
    #else
      // ctrl_lcd::AddText(CursorPosX, CursorPosY, .Text)

      FCD_04071_LCD1__RawSend(FCL_TEXT[FCL_IDX], 0x10);

    #endif

    FCL_IDX = FCL_IDX + 1;

  }

  // ::Component.Property.SetValue(this, "CursorPosX", CursorPosX + LENGTH$ (.Text))

}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

  FCD_04071_LCD1__RawSend(FCL_CHARACTER, 0x10);

  // ctrl_lcd::AddChar(CursorPosX, CursorPosY, .character)

  // ::Component.Property.SetValue(this, "CursorPosX", CursorPosX + 1)

}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintNumber(MX_SINT16 FCL_NUMBER)
{
  //Local variable definitions
  #define FCLsz_S 10
  MX_CHAR FCL_S[FCLsz_S];


  FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

  FCD_04071_LCD1__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

  FCD_04071_LCD1__RawSend(64 + (FCL_INDEX << 3), 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(FCL_D0, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D1, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D2, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D3, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D4, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D5, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D6, 0x10);

  FCD_04071_LCD1__RawSend(FCL_D7, 0x10);

  FCD_04071_LCD1__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__ClearLine(MX_UINT8 FCL_LINE)
{
  //Local variable definitions
  MX_UINT8 FCL_X;


  if (FCL_LINE < 4)
  {  

    // ctrl_lcd::ClearLine(.Line)

    FCD_04071_LCD1__Cursor(0, FCL_LINE);

    FCL_X = 0;

    while (FCL_X < 20)
    {
      FCD_04071_LCD1__RawSend(' ', 0x10);

      FCL_X = FCL_X + 1;

    }

    FCD_04071_LCD1__Cursor(0, FCL_LINE);

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

  // ::Component.Property.SetValue(this, "CursorPosX", .x)

  // ::Component.Property.SetValue(this, "CursorPosY", .y)

  #if (0) // 4 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 4 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (1) // 4 == 4
    if (FCL_Y == 0)
    {    

      FCL_Y = 0x80;

    } else {

      if (FCL_Y == 1)
      {      

        FCL_Y = 0xC0;

      } else {

        #if (0) // 20 == 16
        //Code has been optimised out by the pre-processor
        #else
          #if (1) // 20 == 20
            if (FCL_Y == 2)
            {            

              FCL_Y = 0x94;

            } else {

              FCL_Y = 0xd4;

            }

          // #else
          //Code has been optimised out by the pre-processor
          #endif

        #endif

      }

    }

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  FCD_04071_LCD1__RawSend(FCL_Y + FCL_X, 0);

  FCI_DELAYBYTE_MS(2);

  //Comment:
  //EB2 LCDs have occasional problems here if cursor command isn't called twice

  FCD_04071_LCD1__RawSend(FCL_Y + FCL_X, 0);

  FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Command(MX_UINT8 FCL_INSTRUCTION)
{

  FCD_04071_LCD1__RawSend(FCL_INSTRUCTION, 0);

  FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
  //Local variable definitions
  #define FCLsz_S 15
  MX_CHAR FCL_S[FCLsz_S];


  if (FCL_FORMAT == 1)
  {  

    FCI_UTOS32(FCL_NUMBER, FCL_S,15);

  } else {

    FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

  }

  FCD_04071_LCD1__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  Position : Holds the number of positions to shift the display
       :  Direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
  //Local variable definitions
  MX_UINT8 FCL_CMD = (0x0);
  MX_UINT8 FCL_SCROLL;


  FCL_CMD = 0;

  if (FCL_DIRECTION == 0)
  {  

    FCL_CMD = 0x18;

    // .scroll=ctrl_lcd::GetScrollX()

    // ctrl_lcd::SetScrollX(.scroll + .Position)

  } else {

    FCL_CMD = 0x1C;

    // ctrl_lcd::SetScrollX(ctrl_lcd::GetScrollX() - .Position)

  }

  if (FCL_CMD != 0 && FCL_POSITION != 0)
  {  

    while (FCL_POSITION != 0)
    {
      FCD_04071_LCD1__RawSend(FCL_CMD, 0);

      FCL_POSITION = FCL_POSITION - 1;

    }

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
  //Local variable definitions
  MX_UINT8 FCL_NIBBLE;


  //Comment:
  //Output upper nibble of the byte

  #if (1) // 0 == 0
    SET_PORT_PIN(B, 0, 0);
    SET_PORT_PIN(B, 1, 0);
    SET_PORT_PIN(B, 2, 0);
    SET_PORT_PIN(B, 3, 0);
    SET_PORT_PIN(B, 4, 0);
    SET_PORT_PIN(B, 5, 0);

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    FCL_NIBBLE = (FCL_DATA >> 4);
    SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  //Comment:
  //Output byte to pins

  #if (0) // 0 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Comment:
  //Output byte to port

  #if (0) // 0 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  if (FCL_TYPE)
  {  

    SET_PORT_PIN(B, 4, 1);

  // } else {

  }

  #if (1)
    FCI_DELAYBYTE_US(100);

    FCI_DELAYBYTE_US(100);

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  FCI_DELAYBYTE_US(100);

  //Comment:
  //Set Enable high, pause then set low
  //to acknowledge the data has been 
  //submitted.

  SET_PORT_PIN(B, 5, 1);

  FCI_DELAYBYTE_US(100);

  SET_PORT_PIN(B, 5, 0);

  FCI_DELAYBYTE_US(100);

  #if (1) // 0 == 0
    SET_PORT_PIN(B, 0, 0);
    SET_PORT_PIN(B, 1, 0);
    SET_PORT_PIN(B, 2, 0);
    SET_PORT_PIN(B, 3, 0);
    SET_PORT_PIN(B, 4, 0);

    FCL_NIBBLE = (FCL_DATA & 0xf);
    SET_PORT_PIN(B, 0, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 1, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 2, (FCL_NIBBLE & 0x01));
    FCL_NIBBLE = FCL_NIBBLE >> 1;
    SET_PORT_PIN(B, 3, (FCL_NIBBLE & 0x01));

    if (FCL_TYPE)
    {    

      SET_PORT_PIN(B, 4, 1);

    // } else {

    }

    FCI_DELAYBYTE_US(100);

    SET_PORT_PIN(B, 5, 1);

    FCI_DELAYBYTE_US(100);

    SET_PORT_PIN(B, 5, 0);

    FCI_DELAYBYTE_US(100);

  // #else
  //Code has been optimised out by the pre-processor
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Print a Float number rounded up to a specified amount of decimal places.
       :
       :Parameters for macro PrintFloat:
       :  Number : Enter the number or variable to print to the LCD
       :  DecimalPlaces : Enter how many decimal places to round up to (1 - 6)
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_DECIMALPLACES)
{
  //Local variable definitions
  #define FCLsz_S 10
  MX_CHAR FCL_S[FCLsz_S];


  if (FCL_DECIMALPLACES > 6)
  {  

    FCL_DECIMALPLACES = 6;

  } else {

    if (FCL_DECIMALPLACES < 1)
    {    

      FCL_DECIMALPLACES = 1;

    // } else {

    }

  }

  FCI_FLOAT_TO_STRING(FCL_NUMBER, FCL_DECIMALPLACES, FCL_S, FCLsz_S);

  FCD_04071_LCD1__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

  #if (0) // 0 > 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD1__Start()
{

  // ::Component.Property.SetValue(this, "CursorPosX", 0)

  // ::Component.Property.SetValue(this, "CursorPosY", 0)

  #if (1) // 0 == 0
    SET_PORT_PIN(B, 0, 0);
    SET_PORT_PIN(B, 1, 0);
    SET_PORT_PIN(B, 2, 0);
    SET_PORT_PIN(B, 3, 0);
    SET_PORT_PIN(B, 4, 0);
    SET_PORT_PIN(B, 5, 0);

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  #if (0) // 0 == 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0) // 0 == 2
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  FCI_DELAYBYTE_MS(12);

  FCD_04071_LCD1__RawSend(0x33, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x33, 0);

  FCI_DELAYBYTE_MS(2);

  #if (0) // 0 > 0
  //Code has been optimised out by the pre-processor
  #else
    FCD_04071_LCD1__RawSend(0x32, 0);

    FCI_DELAYBYTE_MS(2);

    FCD_04071_LCD1__RawSend(0x2c, 0);

  #endif

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x06, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x0c, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x01, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__RawSend(0x02, 0);

  FCI_DELAYBYTE_MS(2);

  FCD_04071_LCD1__Clear();

  #if (0) // 0 > 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

#define FCA_LCD_BL0169 0x49e1
#define FCV_LCD_BL0169 0x0011

/*========================================================================*\
   Use :LCD_BL0169
       :GUID: ee697d50-7fb5-4074-8cd6-996e5c386722
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\LCD_BL0169.fcpx
       :Version: 5.0 (0x100028)
       :Timestamp: 17\06\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__Clear()
{

  FCD_04071_LCD1__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{

  FCD_04071_LCD1__PrintString(FCL_TEXT, FCLsz_TEXT);

}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

  FCD_04071_LCD1__PrintAscii(FCL_CHARACTER);

}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintNumber(MX_SINT16 FCL_NUMBER)
{

  FCD_04071_LCD1__PrintNumber(FCL_NUMBER);

}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

  FCD_04071_LCD1__RAMWrite(FCL_INDEX, FCL_D0, FCL_D1, FCL_D2, FCL_D3, FCL_D4, FCL_D5, FCL_D6, FCL_D7);

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__ClearLine(MX_UINT8 FCL_LINE)
{

  FCD_04071_LCD1__ClearLine(FCL_LINE);

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

  FCD_04071_LCD1__Cursor(FCL_X, FCL_Y);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{

  FCD_04071_LCD1__PrintFormattedNumber(FCL_NUMBER, FCL_FORMAT);

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{

  FCD_04071_LCD1__RawSend(FCL_DATA, FCL_TYPE);

}

/*=----------------------------------------------------------------------=*\
   Use :Print a Float number rounded up to a specified amount of decimal places.
       :
       :Parameters for macro PrintFloat:
       :  Number : Enter the number or variable to print to the LCD
       :  DecimalPlaces : Enter how many decimal places to round up to (1 - 6)
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_DECIMALPLACES)
{
  //Local variable definitions
  #define FCLsz_S 10
  MX_CHAR FCL_S[FCLsz_S];


  if (FCL_DECIMALPLACES > 6)
  {  

    FCL_DECIMALPLACES = 6;

  } else {

    if (FCL_DECIMALPLACES < 1)
    {    

      FCL_DECIMALPLACES = 1;

    // } else {

    }

  }

  FCI_FLOAT_TO_STRING(FCL_NUMBER, FCL_DECIMALPLACES, FCL_S, FCLsz_S);

  FCD_049e1_LCD_BL0169__PrintString(FCL_S, FCLsz_S);

  //Local variable definitions
  #undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a remap character allowing the PrintString function to automatically swap between pre-defined characters. 
       :The characters can be custom (in the range 0-9) or can point to an existing character in the LCD character map.
       :
       :Parameters for macro RemapCharacter:
       :  RemapIdx : Remap Index, Range: 0 to (Remap Characters - 1)
       :  SearchCharacter : Character to look for a replace
       :  ReplacementCharacter : New character value to use in place of the search character.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER)
{

  FCD_04071_LCD1__RemapCharacter(FCL_REMAPIDX, FCL_SEARCHCHARACTER, FCL_REPLACEMENTCHARACTER);

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_049e1_LCD_BL0169__Start()
{

  FCD_04071_LCD1__Start();

}

#define FCA_TEXT2 0x2262
#define FCV_TEXT2 0x000f
#define FCA_TEXT9 0x2261
#define FCV_TEXT9 0x000d

/*========================================================================*\
   Use :User Project
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_COUNT = (0x0);
MX_GLOBAL MX_UINT8 FCV_DISPLAYUPDATECOUNT = (0x0);
MX_GLOBAL MX_FLOAT FCV_RPM = (0.0);
MX_GLOBAL MX_UINT8 FCV_PWMVALUE;
MX_GLOBAL MX_FLOAT FCV_REVOLUTIONTIME = (0.0);
MX_GLOBAL MX_BOOL FCV_DATAREADY = (0);

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_update_display()
{

  // Output
  SET_PORT_PIN(E,3,(1));

  // Component Macro
  FCD_049e1_LCD_BL0169__Cursor(0, 0);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintString("Forwards ", 10);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintNumber(FCV_PWMVALUE);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintString("  ", 3);

  // Component Macro
  FCD_049e1_LCD_BL0169__Cursor(0, 1);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintString("Period ", 8);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintFloat(FCV_REVOLUTIONTIME, 4);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintString("  ", 3);

  // Component Macro
  FCD_049e1_LCD_BL0169__Cursor(0, 2);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintString("RPM ", 5);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintFloat(FCV_RPM, 2);

  // Component Macro
  FCD_049e1_LCD_BL0169__PrintString("  ", 3);

  // Output
  SET_PORT_PIN(E,3,(0));

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_feedback_interrupt()
{

  // Output
  SET_PORT_PIN(E,5,(1));

  // Increment Counter
  FCV_COUNT = FCV_COUNT + 1;

  // Three Edges per revolution
  if (FCV_COUNT == 3)
  {  

    // Get time for one revolution as a float in seconds
    FCV_REVOLUTIONTIME = FCD_026e1_Timer1__GetCountReal();

    // Reset timer
    FCD_026e1_Timer1__ResetCounter();

    // Clear Counter
    FCV_COUNT = 0;

    // Flag to do floating point maths in main loop
    FCV_DATAREADY = 1;

  // } else {

  }

  // Output
  SET_PORT_PIN(E,5,(0));

}



/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
	#ifdef INTOSCHELPER
		INTOSCHELPERCODE
	#endif
	//Setup input pins as digital
	ANSELA = 0x00;
	ANSELB = 0x00;
	ANSELD = 0x00;
	ANSELE = 0x00;
	ANSELF = 0x00;
	ANSELG = 0x00;

	//Setup UART Remapping UART2=GLCD, UART5=USB
	RX2PPS = 0x31;
	RG0PPS = 0x0E;
	RX5PPS = 0x33;
	RG2PPS = 0x14;




  //Comment:
  //Motor Feedback voltage requires MCU to be running at 3V3.
  //Ensure 5V / 3V3 +V SEL switch is in the 3V3 position.

  // Component Macro
  FCD_049e1_LCD_BL0169__Start();

  // Component Macro
  FCD_04891_DCMotor1__Enable();

  // Component Macro
  FCD_049e1_LCD_BL0169__Clear();

  // Component Macro
  FCD_04891_DCMotor1__Forwards(125);

  // Delay
  FCI_DELAYBYTE_S(1);

  // Start Timer Running
  FCD_026e1_Timer1__StartCounter(1);

  // Interrupt - Rising Edge E7
  st_bit(INTCON, INT3EDG);
  INT3PPS = 39;
  st_bit(INTCON, GIE);
  st_bit(INTCON, PEIE);
  st_bit(PIE0, INT3IE);

  // Loop
  while (1)
  {
    // Calculation
    FCV_DISPLAYUPDATECOUNT = FCV_DISPLAYUPDATECOUNT + 1;

    // Every 100ms
    if (FCV_DISPLAYUPDATECOUNT == 100)
    {    

      //Comment:
      //Set the motor speed

      // Component Macro
      FCV_PWMVALUE = FCD_00a21_Potentiometer1__GetByte();

      // Component Macro
      FCD_04891_DCMotor1__Forwards(FCV_PWMVALUE);

      //Comment:
      //Update the display

      // User Macro
      FCM_update_display();

      // Calculation
      FCV_DISPLAYUPDATECOUNT = 0;

    // } else {

    }

    // Decision
    if (FCV_DATAREADY)
    {    

      // Perform floating point maths to get RPM
      FCV_RPM = flt_mul((flt_div(1.0, FCV_REVOLUTIONTIME)), 60.0);

      // Calculation
      FCV_DATAREADY = 0;

    // } else {

    }

    // Delay
    FCI_DELAYBYTE_MS(1);

  }

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{
	#ifdef USE_FLOWCODE_ICD3
		ICD_INTERRUPT_HANDLER
	#endif

  //Handler code for [INT3]
  #ifndef MX_INTHANDLER_PIR0_INT3IF
  #define MX_INTHANDLER_PIR0_INT3IF
  if (ts_bit(PIR0, INT3IF) && ts_bit(PIE0, INT3IE))
  {
  	FCM_feedback_interrupt();
  	cr_bit(PIR0, INT3IF);
  }
  #else
  #warning "This interrupt has previously been enabled, so the macro <feedback_interrupt> may never get called."
  #endif


  if (ts_bit(PIR0, TMR0IF) && ts_bit(PIE0, TMR0IE)) {  
    FCV_00a91_TimedInterval1__INTCOUNT = FCV_00a91_TimedInterval1__INTCOUNT + 1;

    if (FCV_00a91_TimedInterval1__INTCOUNT == 0)
    {  

      #if (1)
          

        #if (1 == 1)
              

          // C Code
          TimerInterval_1_CountRegLow = TimerInterval_1_SubPeriod;

          #if (0)
                  

            // C Code
            TimerInterval_1_CountRegHigh = TimerInterval_1_SubPeriod >> 8;

          // } else {

          #endif

        // } else {

        #endif

        #if (1 == 2)
              

          // C Code
          TimerInterval_2_CountRegLow = TimerInterval_2_SubPeriod;

          #if (0)
                  

            // C Code
            TimerInterval_2_CountRegHigh = TimerInterval_2_SubPeriod >> 8;

          // } else {

          #endif

        // } else {

        #endif

        #if (1 == 3)
              

          // C Code
          TimerInterval_3_CountRegLow = TimerInterval_3_SubPeriod;

          #if (0)
                  

            // C Code
            TimerInterval_3_CountRegHigh = TimerInterval_3_SubPeriod >> 8;

          // } else {

          #endif

        // } else {

        #endif

        #if (1 == 4)
              

          // C Code
          TimerInterval_4_CountRegLow = TimerInterval_4_SubPeriod;

          #if (0)
                  

            // C Code
            TimerInterval_4_CountRegHigh = TimerInterval_4_SubPeriod >> 8;

          // } else {

          #endif

        // } else {

        #endif

      #else   

        FCV_00a91_TimedInterval1__INTCOUNT = 0;

        #if (1 == 1)
              

          // C Code
          TimerInterval_1_Macro();

        // } else {

        #endif

        #if (1 == 2)
              

          // C Code
          TimerInterval_2_Macro();

        // } else {

        #endif

        #if (1 == 3)
              

          // C Code
          TimerInterval_3_Macro();

        // } else {

        #endif

        #if (1 == 4)
              

          // C Code
          TimerInterval_4_Macro();

        // } else {

        #endif

      #endif

    } else {

      if (FCV_00a91_TimedInterval1__INTCOUNT > 0)
      {    

        FCV_00a91_TimedInterval1__INTCOUNT = 0;

        #if (0 == 0)
              

          #if (1 == 1)
                  

            // C Code
            TimerInterval_1_CountRegLow = TimerInterval_1_SubPeriod;

            #if (0)
                      

              // C Code
              TimerInterval_1_CountRegHigh = TimerInterval_1_SubPeriod >> 8;

            // } else {

            #endif

          // } else {

          #endif

          #if (1 == 2)
                  

            // C Code
            TimerInterval_2_CountRegLow = TimerInterval_2_SubPeriod;

            #if (0)
                      

              // C Code
              TimerInterval_2_CountRegHigh = TimerInterval_2_SubPeriod >> 8;

            // } else {

            #endif

          // } else {

          #endif

          #if (1 == 3)
                  

            // C Code
            TimerInterval_3_CountRegLow = TimerInterval_3_SubPeriod;

            #if (0)
                      

              // C Code
              TimerInterval_3_CountRegHigh = TimerInterval_3_SubPeriod >> 8;

            // } else {

            #endif

          // } else {

          #endif

          #if (1 == 4)
                  

            // C Code
            TimerInterval_4_CountRegLow = TimerInterval_4_SubPeriod;

            #if (0)
                      

              // C Code
              TimerInterval_4_CountRegHigh = TimerInterval_4_SubPeriod >> 8;

            // } else {

            #endif

          // } else {

          #endif

        // } else {

        #endif

        #if (1 == 1)
              

          // C Code
          TimerInterval_1_Macro();

        // } else {

        #endif

        #if (1 == 2)
              

          // C Code
          TimerInterval_2_Macro();

        // } else {

        #endif

        #if (1 == 3)
              

          // C Code
          TimerInterval_3_Macro();

        // } else {

        #endif

        #if (1 == 4)
              

          // C Code
          TimerInterval_4_Macro();

        // } else {

        #endif

      // } else {

      }

   
  }
    cr_bit(PIR0, TMR0IF); }
  #ifndef Timer_2_Handler_Ref
    #define Timer_2_Handler_Ref
    Timer_2_Handler
  #endif
}




