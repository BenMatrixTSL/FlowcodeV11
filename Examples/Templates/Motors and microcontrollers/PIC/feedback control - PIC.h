// CRC: C09139DD0A75D64CECB6A655701556ECB3779E843346CE0F5130EA7DD15162532F19E22CED7E2D79FCA1D712F9F4A73B1790799BE3387D93492B2739DFD6F390EA86995873165087177459893585281C686A9056384CCBB9CE2D824EFAA61AFF6E4F71DE29CF3BD0059AEDDE67088793E25E38DDEBCD8688F1D21CA3DFA187DD36792F2610DA4D3E9E11C33D97D7302716B7C00C5C2A7C42ED1C6AE80F0EBC61681554E29EDC773C0C3CAEE8E7DA698734B6F6C44AA7F411129178B9A5903FF75EE6BFEABCF5B9A0FB3A6EC75E87040D8CC3C5E1343E318CC546225E431965777A530B1A3400F77B9BE93CEB47136F69805A5E4A3CDA43B7D5E38F81E73961E60E1031E311592434549D34A0D5AD11F359199B87A8BD6EED626427A8AFABDB796702738E788A7F53F0B9F6FEC6D77E3F44FB7D5555DAC58F
// REVISION: 1.0
// GUID: ECB9DFF0-64E2-4E40-9EA7-676FEB72A704
// DATE: 11\12\2025
// DIR: Misc\Templates\Motors|and|microcontrollers\PIC\feedback|control|-|PIC.h
//************************************************************************************
//**  
//**  Source name:   \\IRONMAN-PC2\Dev\Flowcode V11\Examples\Templates\Motors and microcontrollers\PIC\feedback control - PIC.fcfx
//**  Title:         Feedback Control - PIC
//**  Description:   
//**  Device:        PIC.18F.E-blocks3 8-bit PIC
//**  
//**  Generated by:  Flowcode v11.0.0.8
//**  Date:          Thursday, December 11, 2025 12:33:44
//**  Users:         1
//**  Registered to: JohnD (65060919)
//**  Licence key: MNBNUH
//**  
//**  
//**  https://www.flowcode.co.uk
//**  
//************************************************************************************


#define MX_PIC

#define MX_CAL_PIC

#define MX_CLK_SPEED 64000000

#define FCP_NULL Unconnected_Port

#define MX_PWM_NEW_TMR_CONF2
#include <xc.h>
#include <math.h>

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV11\CAL\internals.c"



MX_UINT32 FCLV_LOOP1;
MX_UINT32 FCLV_LOOP2;
MX_UINT32 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;
MX_UINT8 FCLV_LOOP5;

void FCM_update_display();
void FCM_feedback_interrupt();

/*========================================================================*\
   Use :Timer1
       :Macro function declarations
\*========================================================================*/

/*=----------------------------------------------------------------------=*\
   Use :Timer1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#ifndef Timer_2_Defines
  #define Timer_2_Defines
  MX_ULONG TIM_2_COUNTER = 0;
  #define TIM_2_INC TIM_2_COUNTER++; 
  #define Timer_2_Enable {st_bit(INTCON, GIE); T2CON = T2CON & 0xF0;  T2CON = (T2CON & 0x0F) | 0xF0;  T2CLKCON = 1;  st_bit(INTCON, PEIE); st_bit(PIE5, TMR2IE); }
  #define Timer_2_Handler {if (ts_bit(PIR5, TMR2IF) && ts_bit(PIE5, TMR2IE)) {  TIM_2_INC  cr_bit(PIR5, TMR2IF); }}
  #define Timer_2_Disable {cr_bit(PIE5, TMR2IE); }
  #define Timer_2_CountRegLow TMR2
#endif

MX_UINT32 FCD_026e1_Timer1__GetCountSeconds();
void FCD_026e1_Timer1__StartCounter(MX_BOOL FCL_RESETCOUNTERS);
void FCD_026e1_Timer1__GetCountString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_PRECISION);
void FCD_026e1_Timer1__RestoreCounter();
MX_UINT32 FCD_026e1_Timer1__GetCountMicroSeconds();
MX_UINT32 FCD_026e1_Timer1__GetCountMilliseconds();
void FCD_026e1_Timer1__StopCounter();
void FCD_026e1_Timer1__ResetCounter();
MX_FLOAT FCD_026e1_Timer1__GetCountReal();
MX_UINT32 FCD_026e1_Timer1__GetRawCount();

/*========================================================================*\
   Use :cal_adc
       :Macro function declarations
\*========================================================================*/
#define MX_ADC_REF1 
#define MX_ADC_TYPE_36 
#define MX_ADC_BITS_10 
#define MX_ADC_CHANNEL_1 


/*=----------------------------------------------------------------------=*\
   Use :cal_adc
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define FC_ADC_Enable_1 FC_CAL_ADC_Enable_1
#define FC_ADC_Disable_1 FC_CAL_ADC_Disable_1
#define FC_ADC_Sample_1 FC_CAL_ADC_Sample_1

void FC_ADC_Disable_1();
void FC_ADC_Enable_1(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_ADC_Sample_1(MX_UINT8 FCL_SAMPLE_MODE);
MX_UINT16 FCD_0cc51_adc_base1__RawSampleInt();
MX_UINT8 FCD_0cc51_adc_base1__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_0cc51_adc_base1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_0cc51_adc_base1__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_0cc51_adc_base1__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_0cc51_adc_base1__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_0cc51_adc_base1__GetVoltage();
void FCD_0cc51_adc_base1__RawEnable();
MX_UINT8 FCD_0cc51_adc_base1__RawSampleByte();
MX_UINT16 FCD_0cc51_adc_base1__GetInt();
void FCD_0cc51_adc_base1__RawDisable();
MX_UINT8 FCD_0cc51_adc_base1__GetByte();
MX_UINT32 FCD_0c431_MapFunction1__MapUlong(MX_UINT32 FCL_VALUE, MX_UINT32 FCL_INMIN, MX_UINT32 FCL_INMAX, MX_UINT32 FCL_OUTMIN, MX_UINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX);
MX_SINT16 FCD_0c431_MapFunction1__MapInt(MX_SINT16 FCL_VALUE, MX_SINT16 FCL_INMIN, MX_SINT16 FCL_INMAX, MX_SINT16 FCL_OUTMIN, MX_SINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX);
MX_FLOAT FCD_0c431_MapFunction1__MapFloat(MX_FLOAT FCL_VALUE, MX_FLOAT FCL_INMIN, MX_FLOAT FCL_INMAX, MX_FLOAT FCL_OUTMIN, MX_FLOAT FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX);
MX_SINT32 FCD_0c431_MapFunction1__MapLong(MX_SINT32 FCL_VALUE, MX_SINT32 FCL_INMIN, MX_SINT32 FCL_INMAX, MX_SINT32 FCL_OUTMIN, MX_SINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX);
MX_UINT16 FCD_0c431_MapFunction1__MapUInt(MX_UINT16 FCL_VALUE, MX_UINT16 FCL_INMIN, MX_UINT16 FCL_INMAX, MX_UINT16 FCL_OUTMIN, MX_UINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX);
MX_UINT8 FCD_0c431_MapFunction1__MapByte(MX_UINT8 FCL_VALUE, MX_UINT8 FCL_INMIN, MX_UINT8 FCL_INMAX, MX_UINT8 FCL_OUTMIN, MX_UINT8 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX);
MX_BOOL FCD_0b4c1_IsSim1__Check();

/*========================================================================*\
   Use :Potentiometer1
       :Macro function declarations
\*========================================================================*/
#define FCV_00a21_Potentiometer1__COMPONENTLABEL (0)

void FCD_00a21_Potentiometer1__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_00a21_Potentiometer1__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_00a21_Potentiometer1__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_00a21_Potentiometer1__GetVoltage();
MX_UINT16 FCD_00a21_Potentiometer1__GetInt();
MX_UINT8 FCD_00a21_Potentiometer1__GetByte();

/*========================================================================*\
   Use :TimedInterval1
       :Macro function declarations
\*========================================================================*/

/*=----------------------------------------------------------------------=*\
   Use :TimedInterval1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define TimerInterval_1_Enable {st_bit(INTCON, GIE); st_bit(INTCON, PEIE); st_bit(PIE0, TMR0IE);  T0CON1 = (T0CON1 & 0x0F) | 0x40;  T0CON1 = (T0CON1 & 0xF0) | 0x04;  T0CON0 = (T0CON0 & 0xF0) | 0x80; }
#define TimerInterval_1_Disable {cr_bit(PIE0, TMR0IE); }
#define TimerInterval_1_SubPeriod 217
#define TimerInterval_1_Macro FCD_04891_DCMotor1__TimerRoutine
#define TimerInterval_1_CountRegLow TMR0

void FCD_00a91_TimedInterval1__StartTimerInterval();
void FCD_00a91_TimedInterval1__StopTimerInterval();
void FC_CAL_HBRIDGE_Disable_1();
void FC_CAL_HBRIDGE_Enable_1();
void FC_CAL_HBRIDGE_SetSpeed_1(MX_UINT16 FCL_DUTY);
void FC_CAL_HBRIDGE_SetDirection_1(MX_UINT8 FCL_DIRECTION);

/*========================================================================*\
   Use :cal_pwm1
       :Macro function declarations
\*========================================================================*/
#define MX_PWM_PRESCALE1 (1)
#define MX_PWM_PIN_1 (0)
#define MX_PWM_TYPE_1 (0)
#define MX_PWM_PORT_1 PORT
#define MX_PWM_TRIS_1 TRIS
#define MX_PWM_CHANNEL_1 (1)

void FC_CAL_PWM_ChangePeriod_1(MX_UINT16 FCL_PERIOD, MX_UINT16 FCL_PRESCALER);
void FC_CAL_PWM_Disable_1();
void FC_CAL_PWM_SetDuty8Bit_1(MX_UINT8 FCL_DUTY);
void FC_CAL_PWM_Enable_1();
void FC_CAL_PWM_ChangeFrequency_1(MX_UINT32 FCL_FREQUENCY);
void FC_CAL_PWM_SetDuty10Bit_1(MX_UINT16 FCL_DUTY);
void FC_CAL_PWM_SetDutyFloat_1(MX_FLOAT FCL_DUTY);
void FCD_04891_DCMotor1__Coast();
void FCD_04891_DCMotor1__Break();
void FCD_04891_DCMotor1__Disable();
void FCD_04891_DCMotor1__Forwards(MX_UINT16 FCL_DUTY);
void FCD_04891_DCMotor1__Enable();
void FCD_04891_DCMotor1__Reverse(MX_UINT16 FCL_DUTY);
void FCD_04891_DCMotor1__TimerRoutine();
MX_UINT16 FCD_00fb2_WidthData__GetLUTCount();
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount();
MX_UINT32 FCD_09e51_gLCD_Font1__SumWidths(MX_UINT8 FCL_CHARACTER);
MX_UINT8 FCD_09e51_gLCD_Font1__ReadWidth(MX_UINT8 FCL_CHARACTER);
MX_UINT8 FCD_09e51_gLCD_Font1__ReadFontStat(MX_UINT8 FCL_INDEX);
MX_UINT8 FCD_09e51_gLCD_Font1__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX);

/*========================================================================*\
   Use :Base_GLCD1
       :Macro function declarations
\*========================================================================*/

/*=----------------------------------------------------------------------=*\
   Use :Base_GLCD1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define ReadFontWidth(FONT, CHAR) FCD_0ba71_Base_GLCD1__ReadFontWidth(FONT, CHAR)
#define ReadFontStat(FONT, IDX) FCD_0ba71_Base_GLCD1__ReadFontStat(FONT, IDX)


MX_UINT32 FCD_0ba71_Base_GLCD1__Prv_SumWidths(MX_UINT8 FCL_CHARACTER);
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontWidth(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER);
void FCD_0ba71_Base_GLCD1__Prv_ReadFontFileHeader(MX_UINT8 FCL_FONT);
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontStat(MX_UINT8 FCL_FONT, MX_UINT8 FCL_INDEX);
void FCD_0ba71_Base_GLCD1__SetExternalFont(MX_UINT8 FCL_FONT, MX_CHAR *PFCL_FILENAME, MX_UINT8 FCL_CHARACTERSPACING, MX_UINT8 FCL_SPACEWIDTH);
MX_UINT8 FCD_0ba71_Base_GLCD1__ReadFontByte(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX);
void FCD_04071_LCD1__Clear();
void FCD_04071_LCD1__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD1__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD1__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD1__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD1__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD1__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD1__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD1__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD1__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD1__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD1__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_DECIMALPLACES);
void FCD_04071_LCD1__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER);
void FCD_04071_LCD1__Start();
void FCD_049e1_LCD_BL0169__Clear();
void FCD_049e1_LCD_BL0169__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_049e1_LCD_BL0169__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_049e1_LCD_BL0169__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_049e1_LCD_BL0169__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_049e1_LCD_BL0169__ClearLine(MX_UINT8 FCL_LINE);
void FCD_049e1_LCD_BL0169__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_049e1_LCD_BL0169__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_049e1_LCD_BL0169__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_049e1_LCD_BL0169__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_DECIMALPLACES);
void FCD_049e1_LCD_BL0169__RemapCharacter(MX_UINT8 FCL_REMAPIDX, MX_UINT8 FCL_SEARCHCHARACTER, MX_UINT8 FCL_REPLACEMENTCHARACTER);
void FCD_049e1_LCD_BL0169__Start();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV11\CAL\includes.c"

