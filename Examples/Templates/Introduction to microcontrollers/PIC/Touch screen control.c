// CRC: C09139DD0A75D64CECB6A655701556ECC9D6F74ED0D3E47ACDB0BF7143A6B82B25FF37B297F9A200CC671842E99E31865D362FEAF5AAADADC10D5A554C6808E48D6FBA8944EFB526A10634EB7F31C4B96ED5D536AA0B2C84E7EEDE774A5BCDA63801B544F4F230687C0EFE02BC59510BC93C11AA0246185AEA8B112B224AD90E6D41D6708DC021D1B686C842E2A01B3DDD04A5F8AD9BEEB1823278EF8F2BA19CEFB7F8B9768FC390BAFB420BC9D6F4D5796EDD611F6757020C3CAEE8E7DA6987F0C9B82F7A5213E4F9858A5E874BF958CDE91F108D6A4C2EA40E8730C9A84251E18E0E090B8C53D46DF1116EC4240EB074B362D43DB0D051150D61E90424904A4810686D9994D17F0135443BBE80DB5E5884D874256A074E549D34A0D5AD11F31677A5C253EEE671805B4C4468141E1DB62488110E173A8E00BCBB6501ED73225F16A50661D68CC2
// REVISION: 1.0
// GUID: 49ADD554-D31E-4424-AE4A-792F3B873D36
// DATE: 05\12\2025
// DIR: Misc\Templates\Introduction|to|microcontrollers\PIC\Touch|screen|control.c
//************************************************************************************
//**  
//**  Source name:   \\IRONMAN-PC2\Dev\Flowcode V11\Examples\Templates\Introduction to microcontrollers\PIC\Touch screen control.fcfx
//**  Title:         Advanced touch displays - PIC
//**  Description:   Autodetected info:
//**                 
//**                 	Name:	E-Blocks3 ArdMega Programmer
//**                 	Code:	BL1281
//**                 	Family:	ARD
//**                 
//**                 
//**                 Connected boards:
//**                 
//**                 	PORTA:	
//**                 	PORTB:	
//**                 	PORTC:	
//**                 	PORTD:	
//**                 	PORTE:	
//**                 	PORTF:	
//**                 	Internal:	GLCD
//**                 	Internal:	DisplayManager
//**                 	Internal:	UART
//**                 	Internal:	Bluetooth
//**                 	Internal:	Wifi
//**  Device:        PIC.18F.E-blocks3 8-bit PIC
//**  
//**  Generated by:  Flowcode v11.0.0.8
//**  Date:          Wednesday, December 03, 2025 10:51:13
//**  Users:         1
//**  Registered to: JohnD (65060919)
//**  Licence key: MNBNUH
//**  
//**  
//**  https://www.flowcode.co.uk
//**  
//************************************************************************************


#include "\\IRONMAN-PC2\Dev\Flowcode V11\Examples\Templates\Introduction to microcontrollers\PIC\Touch screen control.h"


/*========================================================================*\
   Use :MapFunction1
       :GUID: ccdce31d-a1a3-437a-88ba-5431745ddf6e
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\MapFunction.fcpx
       :Version: 7.0 (0x200028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Map function for unsigned long type variables
       :
       :Parameters for macro MapUlong:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0c431_MapFunction1__MapUlong(MX_UINT32 FCL_VALUE, MX_UINT32 FCL_INMIN, MX_UINT32 FCL_INMAX, MX_UINT32 FCL_OUTMIN, MX_UINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = (FCL_VALUE - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for signed int type variables
       :
       :Parameters for macro MapInt:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_0c431_MapFunction1__MapInt(MX_SINT16 FCL_VALUE, MX_SINT16 FCL_INMIN, MX_SINT16 FCL_INMAX, MX_SINT16 FCL_OUTMIN, MX_SINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_SINT32 FCL_TEMP;
  MX_SINT16 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for floating point type variables
       :
       :Parameters for macro MapFloat:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_0c431_MapFunction1__MapFloat(MX_FLOAT FCL_VALUE, MX_FLOAT FCL_INMIN, MX_FLOAT FCL_INMAX, MX_FLOAT FCL_OUTMIN, MX_FLOAT FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (flt_lt(FCL_VALUE, FCL_INMIN))
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (flt_gt(FCL_VALUE, FCL_INMAX))
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = flt_add(flt_div(flt_mul((flt_sub(FCL_VALUE, FCL_INMIN)), (flt_sub(FCL_OUTMAX, FCL_OUTMIN))), (flt_sub(FCL_INMAX, FCL_INMIN))), FCL_OUTMIN);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for signed long type variables
       :
       :Parameters for macro MapLong:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_SINT32
\*=----------------------------------------------------------------------=*/
MX_SINT32 FCD_0c431_MapFunction1__MapLong(MX_SINT32 FCL_VALUE, MX_SINT32 FCL_INMIN, MX_SINT32 FCL_INMAX, MX_SINT32 FCL_OUTMIN, MX_SINT32 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_SINT32 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCR_RETVAL = (FCL_VALUE - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for unsigned int type variables
       :
       :Parameters for macro MapUInt:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0c431_MapFunction1__MapUInt(MX_UINT16 FCL_VALUE, MX_UINT16 FCL_INMIN, MX_UINT16 FCL_INMAX, MX_UINT16 FCL_OUTMIN, MX_UINT16 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT32 FCL_TEMP;
  MX_UINT16 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Map function for byte type variables
       :
       :Parameters for macro MapByte:
       :  Value : Main variable used for map function
       :  InMin : Lowest input value
       :  InMax : Highest value input
       :  OutMin : Lowest value after conversion
       :  OutMax : highest value after conversion
       :  ClampMinMax : Clamp min & max so result does not go above or below set values. 0=No, 1=Yes
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c431_MapFunction1__MapByte(MX_UINT8 FCL_VALUE, MX_UINT8 FCL_INMIN, MX_UINT8 FCL_INMAX, MX_UINT8 FCL_OUTMIN, MX_UINT8 FCL_OUTMAX, MX_BOOL FCL_CLAMPMINMAX)
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT8 FCR_RETVAL;


  if (FCL_CLAMPMINMAX)
  {  

    if (FCL_VALUE < FCL_INMIN)
    {    

      FCL_VALUE = FCL_INMIN;

    // } else {

    }

    if (FCL_VALUE > FCL_INMAX)
    {    

      FCL_VALUE = FCL_INMAX;

    // } else {

    }

  // } else {

  }

  FCL_TEMP = FCL_VALUE;
  FCL_TEMP = (FCL_TEMP - FCL_INMIN) * (FCL_OUTMAX - FCL_OUTMIN) / (FCL_INMAX - FCL_INMIN) + FCL_OUTMIN;
  FCR_RETVAL = FCL_TEMP;

  return (FCR_RETVAL);

}

#define FCA_SLIDER 0x77c1
#define FCV_SLIDER 0x0df1

/*========================================================================*\
   Use :Slider
       :GUID: 471eab69-d1c0-45eb-88f8-d01bd7167b23
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\DC_Slider.fcpx
       :Version: 6.0 (0x100028)
       :Timestamp: 28\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Changes the theme index of the selected Object or Widget.
       :
       :Parameters for macro ModifyColour:
       :  Index : 0=Thumb, 1=Background, 2=Low Line, 3=High Line
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
       :  Redraw : MX_BOOL
\*=----------------------------------------------------------------------=*/
void FCD_077c1_Slider__ModifyColour(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B, MX_BOOL FCL_REDRAW)
{

  FCD_0a401_DisplayManager1__ModifyColour(24, FCL_INDEX, FCL_R, FCL_G, FCL_B, FCL_REDRAW);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the value of one of the sliders ranging between 0-1 or Custom range Min-Max.
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_077c1_Slider__GetSliderValue()
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  FCR_RETVAL = FCD_0a401_DisplayManager1__GetSliderValue(24);

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the assigned object/widget ID.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_077c1_Slider__GetID()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 24;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Changes the width and height of the selected Object or Widget.
       :
       :Parameters for macro ModifyScale:
       :  Width : MX_UINT16
       :  Height : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_077c1_Slider__ModifyScale(MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT)
{

  FCD_0a401_DisplayManager1__ModifyScale(24, FCL_WIDTH, FCL_HEIGHT);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the value of one of the sliders and optionally redraws the slider to reflect the value change.
       :
       :Parameters for macro SetSliderValue:
       :  Value : Range: 0 to 1 - Or Custom Range Min to Max
       :  RedrawSlider : 0=Do not redraw, 1=Redraw
\*=----------------------------------------------------------------------=*/
void FCD_077c1_Slider__SetSliderValue(MX_FLOAT FCL_VALUE, MX_BOOL FCL_REDRAWSLIDER)
{

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  FCD_0a401_DisplayManager1__SetSliderValue(24, FCL_VALUE, FCL_REDRAWSLIDER);

}

/*=----------------------------------------------------------------------=*\
   Use :Moves an existing object or Widget to absolute coordinates on the screen.
       :
       :Parameters for macro ModifyPosition:
       :  X : MX_SINT16
       :  Y : MX_SINT16
       :  Relative : 0=Absolute Positioning, 1=Relative Positioning
\*=----------------------------------------------------------------------=*/
void FCD_077c1_Slider__ModifyPosition(MX_SINT16 FCL_X, MX_SINT16 FCL_Y, MX_BOOL FCL_RELATIVE)
{

  FCD_0a401_DisplayManager1__ModifyPosition(24, FCL_X, FCL_Y, FCL_RELATIVE);

}

#define FCA_VALUE_DISPLAY 0x5fa1
#define FCV_VALUE_DISPLAY 0x0dd5

/*========================================================================*\
   Use :value_display
       :GUID: 81f24c15-ab7c-49ba-b55f-62d3cbfee92a
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\DC_Text.fcpx
       :Version: 5.0 (0x100028)
       :Timestamp: 24\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Changes the theme index of the selected Object or Widget.
       :
       :Parameters for macro ModifyColour:
       :  Index : 0=Foreground, 1=Background, 2=Text, 3=Highlight
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
       :  Redraw : MX_BOOL
\*=----------------------------------------------------------------------=*/
void FCD_05fa1_value_display__ModifyColour(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B, MX_BOOL FCL_REDRAW)
{

  FCD_0a401_DisplayManager1__ModifyColour(1, FCL_INDEX, FCL_R, FCL_G, FCL_B, FCL_REDRAW);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the assigned object/widget ID.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_05fa1_value_display__GetID()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 1;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Changes the width and height of the selected Object or Widget.
       :
       :Parameters for macro ModifyScale:
       :  Width : MX_UINT16
       :  Height : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_05fa1_value_display__ModifyScale(MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT)
{

  FCD_0a401_DisplayManager1__ModifyScale(1, FCL_WIDTH, FCL_HEIGHT);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a floating point value with optional units onto an object or Widget location.
       :
       :Parameters for macro SetTextFloat:
       :  Number : MX_FLOAT
       :  NumDP : Number of decimal points to display
       :  Unit[20] : Optional unit string to add after the numeric value. e.g. "g" or "s"
\*=----------------------------------------------------------------------=*/
void FCD_05fa1_value_display__SetTextFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_NUMDP, MX_CHAR *FCL_UNIT, MX_UINT16 FCLsz_UNIT)
{
  //Local variable definitions
  #define FCLsz_TEXT 20
  MX_CHAR FCL_TEXT[FCLsz_TEXT] = "";


  FCI_FLOAT_TO_STRING(FCL_NUMBER, FCL_NUMDP, FCL_TEXT, FCLsz_TEXT);
  FCI_SHEAD(FCL_TEXT,FCLsz_TEXT, FCL_UNIT,FCLsz_UNIT, FCL_TEXT,20);

  FCD_0a401_DisplayManager1__SetTextLabel(1, FCL_TEXT, FCLsz_TEXT, 0, 1, 1, 1);

  //Local variable definitions
  #undef FCLsz_TEXT
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a string onto an object or Widget location.
       :
       :Parameters for macro SetTextLabel:
       :  Text[20] : Text string to set as the label
\*=----------------------------------------------------------------------=*/
void FCD_05fa1_value_display__SetTextLabel(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{

  FCD_0a401_DisplayManager1__SetTextLabel(1, FCL_TEXT, FCLsz_TEXT, 0, 1, 1, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an integer numerical value with optional units onto an object or Widget location.
       :
       :Parameters for macro SetTextNumber:
       :  Number : MX_SINT16
       :  Unit[20] : Unit string to add after the numeric value. e.g. "g" or "s"
\*=----------------------------------------------------------------------=*/
void FCD_05fa1_value_display__SetTextNumber(MX_SINT16 FCL_NUMBER, MX_CHAR *FCL_UNIT, MX_UINT16 FCLsz_UNIT)
{
  //Local variable definitions
  #define FCLsz_TEXT 20
  MX_CHAR FCL_TEXT[FCLsz_TEXT] = "";


  FCI_TOSTRING(FCL_NUMBER, FCL_TEXT,20);
  FCI_SHEAD(FCL_TEXT,FCLsz_TEXT, FCL_UNIT,FCLsz_UNIT, FCL_TEXT,20);

  FCD_0a401_DisplayManager1__SetTextLabel(1, FCL_TEXT, FCLsz_TEXT, 0, 1, 1, 1);

  //Local variable definitions
  #undef FCLsz_TEXT
}

/*=----------------------------------------------------------------------=*\
   Use :Moves an existing object or Widget to absolute coordinates on the screen.
       :
       :Parameters for macro ModifyPosition:
       :  X : MX_SINT16
       :  Y : MX_SINT16
       :  Relative : 0=Absolute Positioning, 1=Relative Positioning
\*=----------------------------------------------------------------------=*/
void FCD_05fa1_value_display__ModifyPosition(MX_SINT16 FCL_X, MX_SINT16 FCL_Y, MX_BOOL FCL_RELATIVE)
{

  FCD_0a401_DisplayManager1__ModifyPosition(1, FCL_X, FCL_Y, FCL_RELATIVE);

}

#define FCA_DOWN 0xca04
#define FCV_DOWN 0x0dc7
#define FCA_UP 0xca03
#define FCV_UP 0x0db9
#define FCA_GOTOSCREEN0 0xca02
#define FCV_GOTOSCREEN0 0x0dab
#define FCA_GOTOSCREEN1 0xca01
#define FCV_GOTOSCREEN1 0x0d8f

/*========================================================================*\
   Use :AdvString1
       :GUID: 34f258e1-5c8c-4519-b29d-aba7cbf41faf
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\AdvString.fcpx
       :Version: 5.0 (0x100028)
       :Timestamp: 14\04\2023
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Inserts a string into another string at the specified index position.
       :
       :Parameters for macro InsertInto:
       :  DataString[1000] : Data string to ammend
       :  Insert[1000] : Data to insert
       :  InsertionIndex : Index location in the string to insert the data
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__InsertInto(MX_CHAR *FCL_DATASTRING, MX_UINT16 FCLsz_DATASTRING, MX_CHAR *FCL_INSERT, MX_UINT16 FCLsz_INSERT, MX_UINT16 FCL_INSERTIONINDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_STRLEN;
  MX_UINT16 FCL_INSERTLEN;
  MX_UINT16 FCL_IDX;


  FCL_STRLEN = FCI_GETLENGTH(FCL_DATASTRING, FCLsz_DATASTRING);
  FCL_INSERTLEN = FCI_GETLENGTH(FCL_INSERT, FCLsz_INSERT);

  if (FCL_INSERTIONINDEX <= FCL_STRLEN)
  {  

    FCL_DATASTRING[(FCL_STRLEN + FCL_INSERTLEN)] = 0;

    for (FCL_IDX=0; (FCL_IDX)<(FCL_STRLEN - FCL_INSERTIONINDEX); (FCL_IDX)++)
    {
      FCL_DATASTRING[(FCL_STRLEN + FCL_INSERTLEN) - (FCL_IDX + 1)] = FCL_DATASTRING[FCL_STRLEN - (FCL_IDX + 1)];

    }

    for (FCL_IDX=0; (FCL_IDX)<(FCL_INSERTLEN); (FCL_IDX)++)
    {
      FCL_DATASTRING[FCL_INSERTIONINDEX + FCL_IDX] = FCL_INSERT[FCL_IDX];

    }

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to find a specific string inside the data string and if found replaces with the
       :provided replacement string.
       :Returns the number of times the search pattern was found.
       :
       :Parameters for macro SearchAndReplace:
       :  StrData[1000] : Data string to scan
       :  StrSearch[1000] : String to look for in the data
       :  StrReplace[1000] : String to insert into the data
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_087d1_AdvString1__SearchAndReplace(MX_CHAR *FCL_STRDATA, MX_UINT16 FCLsz_STRDATA, MX_CHAR *FCL_STRSEARCH, MX_UINT16 FCLsz_STRSEARCH, MX_CHAR *FCL_STRREPLACE, MX_UINT16 FCLsz_STRREPLACE)
{
  //Local variable definitions
  MX_SINT16 FCL_POS;
  MX_UINT16 FCL_LENSTR;
  MX_UINT16 FCL_LENSEARCH;
  MX_UINT16 FCL_LENREPLACE;
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCL_LENSTR = FCI_GETLENGTH(FCL_STRDATA, FCLsz_STRDATA);
  FCL_LENSEARCH = FCI_GETLENGTH(FCL_STRSEARCH, FCLsz_STRSEARCH);
  FCL_LENREPLACE = FCI_GETLENGTH(FCL_STRREPLACE, FCLsz_STRREPLACE);

  FCL_POS = FCD_087d1_AdvString1__PositionOf(FCL_STRDATA, FCLsz_STRDATA, FCL_STRSEARCH, FCLsz_STRSEARCH, 0);

  while (FCL_POS >= 0)
  {
    if (FCL_LENSEARCH == FCL_LENREPLACE)
    {    

      for (FCL_IDX=0; (FCL_IDX)<(FCL_LENSEARCH); (FCL_IDX)++)
      {
        FCL_STRDATA[FCL_POS + FCL_IDX] = FCL_STRREPLACE[FCL_IDX];

      }

    } else {

      if (FCL_LENSEARCH > FCL_LENREPLACE)
      {      

        for (FCL_IDX=0; (FCL_IDX)<(FCL_LENREPLACE); (FCL_IDX)++)
        {
          FCL_STRDATA[FCL_POS + FCL_IDX] = FCL_STRREPLACE[FCL_IDX];

        }

        for (FCL_IDX=0; (FCL_IDX)<(FCL_LENSTR - (FCL_POS + FCL_LENREPLACE)); (FCL_IDX)++)
        {
          FCL_STRDATA[FCL_POS + FCL_LENREPLACE + FCL_IDX] = FCL_STRDATA[FCL_POS + FCL_LENSEARCH + FCL_IDX];

        }

      } else {

        FCL_STRDATA[(FCL_LENSTR) + (FCL_LENREPLACE - FCL_LENSEARCH)] = 0;

        for (FCL_IDX=0; (FCL_IDX)<(FCL_LENSTR - (FCL_POS + FCL_LENSEARCH)); (FCL_IDX)++)
        {
          FCL_STRDATA[(FCL_LENSTR - 1) + (FCL_LENREPLACE - FCL_LENSEARCH) - FCL_IDX] = FCL_STRDATA[(FCL_LENSTR - 1) - FCL_IDX];

        }

        for (FCL_IDX=0; (FCL_IDX)<(FCL_LENREPLACE); (FCL_IDX)++)
        {
          FCL_STRDATA[FCL_POS + FCL_IDX] = FCL_STRREPLACE[FCL_IDX];

        }

      }

    }

    FCL_POS = FCD_087d1_AdvString1__PositionOf(FCL_STRDATA, FCLsz_STRDATA, FCL_STRSEARCH, FCLsz_STRSEARCH, FCL_POS + FCL_LENREPLACE);

    FCR_RETVAL = FCR_RETVAL + 1;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Takes an ASCII string and using a delimiter converts it into an array of bytes.
       :Returns the number of values discovered and placed into the DataArray,
       :e.g. "1,2,3,4" would become {1,2,3,4}
       :
       :Parameters for macro ExplodeToByteArray:
       :  StringInput[20] : Data string e.g. "1,2,3,4"
       :  Delimiter : Delimiting character byte for example ','
       :  DataArray[100] : Data array to hold the numberic values found
       :  MaxCount : Maximum number of values to return
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_087d1_AdvString1__ExplodeToByteArray(MX_CHAR *FCL_STRINGINPUT, MX_UINT16 FCLsz_STRINGINPUT, MX_UINT8 FCL_DELIMITER, MX_UINT8 *FCL_DATAARRAY, MX_UINT16 FCLsz_DATAARRAY, MX_UINT16 FCL_MAXCOUNT)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_LEN;
  MX_UINT8 FCL_TSIDX = (0x0);
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCL_LEN = FCI_GETLENGTH(FCL_STRINGINPUT, FCLsz_STRINGINPUT);

  while (FCL_IDX < FCL_LEN)
  {
    if (FCL_STRINGINPUT[FCL_IDX] == FCL_DELIMITER)
    {    

      FCL_TEMPSTR[FCL_TSIDX] = 0;
      FCL_TSIDX = 0;

      FCL_DATAARRAY[FCR_RETVAL] = FCI_STRING_TO_INT(FCL_TEMPSTR, FCLsz_TEMPSTR);
      FCR_RETVAL = FCR_RETVAL + 1;

      if (FCR_RETVAL == FCL_MAXCOUNT)
      {      

        goto FCC_ExplodeToByteArray_A;

      // } else {

      }

    } else {

      if (FCL_TSIDX < 19)
      {      

        FCL_TEMPSTR[FCL_TSIDX] = FCL_STRINGINPUT[FCL_IDX];
        FCL_TSIDX = FCL_TSIDX + 1;

      // } else {

      }

    }

    FCL_IDX = FCL_IDX + 1;

  }

  if (FCL_TSIDX > 0)
  {  

    FCL_TEMPSTR[FCL_TSIDX] = 0;
    FCL_TSIDX = 0;

    FCL_DATAARRAY[FCR_RETVAL] = FCI_STRING_TO_INT(FCL_TEMPSTR, FCLsz_TEMPSTR);
    FCR_RETVAL = FCR_RETVAL + 1;

  // } else {

  }

FCC_ExplodeToByteArray_A:
  ;

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Converts a floating point value to a string of a fixed size.
       :The value 5 with a length of 3 and a character of '0' would generate "003"
       :
       :Parameters for macro FormattedStringFloat:
       :  Value : value to format
       :  MinLength : The minimum length you want the string to be
       :  PaddChar : Added character to padd the string with e.g. ' ' or '0'
       :  Precision : Number of decimal points to add
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__FormattedStringFloat(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_FLOAT FCL_VALUE, MX_UINT8 FCL_MINLENGTH, MX_UINT8 FCL_PADDCHAR, MX_UINT8 FCL_PRECISION)
{
  //Local variable definitions
  MX_UINT8 FCL_LEN;
  MX_UINT8 FCL_IDX = (0x0);
  #define FCLsz_TEMP 20
  MX_CHAR FCL_TEMP[FCLsz_TEMP];


  FCI_FLOAT_TO_STRING(FCL_VALUE, FCL_PRECISION, FCL_TEMP, FCLsz_TEMP);

  FCL_LEN = FCI_GETLENGTH(FCL_TEMP, FCLsz_TEMP);

  while ((FCL_LEN + FCL_IDX) < FCL_MINLENGTH)
  {
    FCR_RETVAL[FCL_IDX] = FCL_PADDCHAR;

    FCL_IDX = FCL_IDX + 1;

  }

  FCR_RETVAL[FCL_IDX] = 0;

  FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMP,FCLsz_TEMP, FCR_RETVAL,2000);

  //Local variable definitions
  #undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Takes an ASCII string and using a delimiter converts it into an array of strings.
       :Returns the number of values discovered and placed into the DataArray,
       :e.g. "1,2,3,4" would become {"1","2","3","4"}
       :
       :Parameters for macro ExplodeToStringArray:
       :  StringInput[20] : Data string e.g. "1,2,3,4"
       :  Delimiter : Delimiting character byte for example ','
       :  DataArray[100][20] : Data array to hold the numberic values found
       :  MaxCount : Maximum number of values to return
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_087d1_AdvString1__ExplodeToStringArray(MX_CHAR *FCL_STRINGINPUT, MX_UINT16 FCLsz_STRINGINPUT, MX_UINT8 FCL_DELIMITER, MX_CHAR FCL_DATAARRAY[][20], MX_UINT16 FCLsz_DATAARRAY_1, MX_UINT16 FCL_MAXCOUNT)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_LEN;
  MX_UINT8 FCL_TSIDX = (0x0);
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCL_LEN = FCI_GETLENGTH(FCL_STRINGINPUT, FCLsz_STRINGINPUT);

  while (FCL_IDX < FCL_LEN)
  {
    if (FCL_STRINGINPUT[FCL_IDX] == FCL_DELIMITER)
    {    

      FCL_TEMPSTR[FCL_TSIDX] = 0;
      FCL_TSIDX = 0;

      FCI_SCOPY(FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_DATAARRAY[FCR_RETVAL],FCLsz_DATAARRAY_1);
      FCR_RETVAL = FCR_RETVAL + 1;

      if (FCR_RETVAL == FCL_MAXCOUNT)
      {      

        goto FCC_ExplodeToStringArray_A;

      // } else {

      }

    } else {

      if (FCL_TSIDX < 19)
      {      

        FCL_TEMPSTR[FCL_TSIDX] = FCL_STRINGINPUT[FCL_IDX];
        FCL_TSIDX = FCL_TSIDX + 1;

      // } else {

      }

    }

    FCL_IDX = FCL_IDX + 1;

  }

  if (FCL_TSIDX > 0)
  {  

    FCL_TEMPSTR[FCL_TSIDX] = 0;
    FCL_TSIDX = 0;

    FCI_SCOPY(FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_DATAARRAY[FCR_RETVAL],FCLsz_DATAARRAY_1);
    FCR_RETVAL = FCR_RETVAL + 1;

  // } else {

  }

FCC_ExplodeToStringArray_A:
  ;

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Creates an ASCII string from an array of byte values.
       :Places a delimiter in between each value.
       :e.g. {1,2,3,4} would become "1,2,3,4"
       :
       :Parameters for macro ImplodeFromByteArray:
       :  DataArray[100] : MX_UINT8
       :  Count : Number of values held in the array
       :  Delimiter : Delimiter to add between values
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__ImplodeFromByteArray(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 *FCL_DATAARRAY, MX_UINT16 FCLsz_DATAARRAY, MX_UINT16 FCL_COUNT, MX_UINT8 FCL_DELIMITER)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);


  FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

  while (FCL_IDX < FCL_COUNT)
  {
    FCI_TOSTRING(FCL_DATAARRAY[FCL_IDX], FCL_TEMPSTR,20);

    FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    FCL_IDX = FCL_IDX + 1;

    if (FCL_IDX < FCL_COUNT)
    {    

      FCL_TEMPSTR[0] = FCL_DELIMITER;
      FCL_TEMPSTR[1] = 0;

      FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    // } else {

    }

  }

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Scans a string to see if it contains a specific substring.
       :Returns 1 if found, otherwise returns 0.
       :
       :Parameters for macro Contains:
       :  StrData[1000] : Data string to scan
       :  StrMatch[1000] : String to look for in the data
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_087d1_AdvString1__Contains(MX_CHAR *FCL_STRDATA, MX_UINT16 FCLsz_STRDATA, MX_CHAR *FCL_STRMATCH, MX_UINT16 FCLsz_STRMATCH)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_SUBIDX = (0x0);
  MX_UINT16 FCL_LEN;
  MX_UINT16 FCL_SUBLEN;
  MX_BOOL FCR_RETVAL;


  FCR_RETVAL = 0;

  FCL_LEN = FCI_GETLENGTH(FCL_STRDATA, FCLsz_STRDATA);
  FCL_SUBLEN = FCI_GETLENGTH(FCL_STRMATCH, FCLsz_STRMATCH);

  while (FCL_IDX < FCL_LEN)
  {
    if (FCL_STRDATA[FCL_IDX] == FCL_STRMATCH[FCL_SUBIDX])
    {    

      FCL_SUBIDX = FCL_SUBIDX + 1;

      if (FCL_SUBIDX == FCL_SUBLEN)
      {      

        FCR_RETVAL = 1;

        goto FCC_Contains_A;

      // } else {

      }

    } else {

      if (FCL_SUBIDX)
      {      

        FCL_IDX = FCL_IDX - FCL_SUBIDX;

      // } else {

      }

      FCL_SUBIDX = 0;

    }

    FCL_IDX = FCL_IDX + 1;

  }

FCC_Contains_A:
  ;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows a set number of characters to be removed from a starting location in a string.
       :
       :Parameters for macro RemoveFrom:
       :  DataString[1000] : Data string to ammend
       :  CharsToRemove : Number of characters to remove from the string
       :  StartingIndex : Index location in the string to delete the data
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__RemoveFrom(MX_CHAR *FCL_DATASTRING, MX_UINT16 FCLsz_DATASTRING, MX_UINT16 FCL_CHARSTOREMOVE, MX_UINT16 FCL_STARTINGINDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_STRLEN;
  MX_UINT16 FCL_IDX;


  FCL_STRLEN = FCI_GETLENGTH(FCL_DATASTRING, FCLsz_DATASTRING);

  if (FCL_STARTINGINDEX < FCL_STRLEN)
  {  

    if (FCL_CHARSTOREMOVE <= (FCL_STRLEN - FCL_STARTINGINDEX))
    {    

    } else {

      FCL_CHARSTOREMOVE = FCL_STRLEN - FCL_STARTINGINDEX;

    }

    for (FCL_IDX=0; (FCL_IDX)<(FCL_STRLEN - FCL_STARTINGINDEX); (FCL_IDX)++)
    {
      FCL_DATASTRING[FCL_STARTINGINDEX + FCL_IDX] = FCL_DATASTRING[FCL_STARTINGINDEX + FCL_CHARSTOREMOVE + FCL_IDX];

    }

    FCL_DATASTRING[FCL_STARTINGINDEX + FCL_IDX] = 0;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Scans a string to see if it contains a specific substring.
       :Returns the location in the string if found, otherwise returns -1.
       :
       :Parameters for macro PositionOf:
       :  StrData[1000] : Data string to scan
       :  StrMatch[1000] : String to look for in the data
       :  SearchFrom : Starting index for the search, default 0.
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_087d1_AdvString1__PositionOf(MX_CHAR *FCL_STRDATA, MX_UINT16 FCLsz_STRDATA, MX_CHAR *FCL_STRMATCH, MX_UINT16 FCLsz_STRMATCH, MX_UINT16 FCL_SEARCHFROM)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_SUBIDX = (0x0);
  MX_UINT16 FCL_LEN;
  MX_UINT16 FCL_SUBLEN;
  MX_SINT16 FCR_RETVAL;


  FCR_RETVAL = -1;

  FCL_LEN = FCI_GETLENGTH(FCL_STRDATA, FCLsz_STRDATA);
  FCL_SUBLEN = FCI_GETLENGTH(FCL_STRMATCH, FCLsz_STRMATCH);

  FCL_IDX = FCL_SEARCHFROM;

  while (FCL_IDX < FCL_LEN)
  {
    if (FCL_STRDATA[FCL_IDX] == FCL_STRMATCH[FCL_SUBIDX])
    {    

      FCL_SUBIDX = FCL_SUBIDX + 1;

      if (FCL_SUBIDX == FCL_SUBLEN)
      {      

        FCR_RETVAL = FCL_IDX - (FCL_SUBLEN - 1);

        goto FCC_PositionOf_A;

      // } else {

      }

    } else {

      if (FCL_SUBIDX)
      {      

        FCL_IDX = FCL_IDX - FCL_SUBIDX;

      // } else {

      }

      FCL_SUBIDX = 0;

    }

    FCL_IDX = FCL_IDX + 1;

  }

FCC_PositionOf_A:
  ;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows an array of bytes to be copied into another array of bytes at the chosen start address.
       :
       :Parameters for macro MemCopy:
       :  SourceData[1024] : Source data to copy from
       :  SourceStartAddress : Address in the source to start copying data
       :  DestinationData[1024] : Data to copy the values into
       :  DestinationStartAddress : Address in the destination to start inserting data
       :  NumBytes : Number of values to copy from the source to the destination
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__MemCopy(MX_UINT8 *FCL_SOURCEDATA, MX_UINT16 FCLsz_SOURCEDATA, MX_UINT16 FCL_SOURCESTARTADDRESS, MX_UINT8 *FCL_DESTINATIONDATA, MX_UINT16 FCLsz_DESTINATIONDATA, MX_UINT16 FCL_DESTINATIONSTARTADDRESS, MX_UINT16 FCL_NUMBYTES)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;


  for (FCL_IDX=0; (FCL_IDX)<(FCL_NUMBYTES); (FCL_IDX)++)
  {
    FCL_DESTINATIONDATA[FCL_DESTINATIONSTARTADDRESS + FCL_IDX] = FCL_SOURCEDATA[FCL_SOURCESTARTADDRESS + FCL_IDX];

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Takes an ASCII string and using a delimiter converts it into an array of integers.
       :Returns the number of values discovered and placed into the DataArray,
       :e.g. "1,2,3,4" would become {1,2,3,4}
       :
       :Parameters for macro ExplodeToINTArray:
       :  StringInput[20] : Data string e.g. "1,2,3,4"
       :  Delimiter : Delimiting character byte for example ','
       :  DataArray[100] : Data array to hold the numberic values found
       :  MaxCount : Maximum number of values to return
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_087d1_AdvString1__ExplodeToINTArray(MX_CHAR *FCL_STRINGINPUT, MX_UINT16 FCLsz_STRINGINPUT, MX_UINT8 FCL_DELIMITER, MX_UINT16 *FCL_DATAARRAY, MX_UINT16 FCLsz_DATAARRAY, MX_UINT16 FCL_MAXCOUNT)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_LEN;
  MX_UINT8 FCL_TSIDX = (0x0);
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCL_LEN = FCI_GETLENGTH(FCL_STRINGINPUT, FCLsz_STRINGINPUT);

  while (FCL_IDX < FCL_LEN)
  {
    if (FCL_STRINGINPUT[FCL_IDX] == FCL_DELIMITER)
    {    

      FCL_TEMPSTR[FCL_TSIDX] = 0;
      FCL_TSIDX = 0;

      FCL_DATAARRAY[FCR_RETVAL] = FCI_STRING_TO_INT(FCL_TEMPSTR, FCLsz_TEMPSTR);
      FCR_RETVAL = FCR_RETVAL + 1;

      if (FCR_RETVAL == FCL_MAXCOUNT)
      {      

        goto FCC_ExplodeToINTArray_A;

      // } else {

      }

    } else {

      if (FCL_TSIDX < 19)
      {      

        FCL_TEMPSTR[FCL_TSIDX] = FCL_STRINGINPUT[FCL_IDX];
        FCL_TSIDX = FCL_TSIDX + 1;

      // } else {

      }

    }

    FCL_IDX = FCL_IDX + 1;

  }

  if (FCL_TSIDX > 0)
  {  

    FCL_TEMPSTR[FCL_TSIDX] = 0;
    FCL_TSIDX = 0;

    FCL_DATAARRAY[FCR_RETVAL] = FCI_STRING_TO_INT(FCL_TEMPSTR, FCLsz_TEMPSTR);
    FCR_RETVAL = FCR_RETVAL + 1;

  // } else {

  }

FCC_ExplodeToINTArray_A:
  ;

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Creates an ASCII string from an array of string values.
       :Places a delimiter in between each value.
       :e.g. {"1","2","3","4"} would become "1,2,3,4"
       :
       :Parameters for macro ImplodeFromStringArray:
       :  DataArray[100][20] : MX_CHAR (by-ref)
       :  Count : Number of values held in the array
       :  Delimiter : Delimiter to add between values
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__ImplodeFromStringArray(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_CHAR FCL_DATAARRAY[][20], MX_UINT16 FCLsz_DATAARRAY_1, MX_UINT16 FCL_COUNT, MX_UINT8 FCL_DELIMITER)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);


  FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

  while (FCL_IDX < FCL_COUNT)
  {
    FCI_SCOPY(FCL_DATAARRAY[FCL_IDX],FCLsz_DATAARRAY_1, FCL_TEMPSTR,FCLsz_TEMPSTR);

    FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    FCL_IDX = FCL_IDX + 1;

    if (FCL_IDX < FCL_COUNT)
    {    

      FCL_TEMPSTR[0] = FCL_DELIMITER;
      FCL_TEMPSTR[1] = 0;

      FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    // } else {

    }

  }

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Creates an ASCII string from an array of float values.
       :Places a delimiter in between each value.
       :e.g. {1.1,2.2,3.3,4.4} would become "1.1,2.2,3.3,4.4"
       :
       :Parameters for macro ImplodeFromFloatArray:
       :  DataArray[100] : MX_FLOAT
       :  Count : Number of values held in the array
       :  Delimiter : Delimiter to add between values
       :  Precision : Number of decimal points to add to each float value
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__ImplodeFromFloatArray(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_FLOAT *FCL_DATAARRAY, MX_UINT16 FCLsz_DATAARRAY, MX_UINT16 FCL_COUNT, MX_UINT8 FCL_DELIMITER, MX_UINT8 FCL_PRECISION)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);


  FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

  while (FCL_IDX < FCL_COUNT)
  {
    FCI_FLOAT_TO_STRING(FCL_DATAARRAY[FCL_IDX], FCL_PRECISION, FCL_TEMPSTR, FCLsz_TEMPSTR);

    FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    FCL_IDX = FCL_IDX + 1;

    if (FCL_IDX < FCL_COUNT)
    {    

      FCL_TEMPSTR[0] = FCL_DELIMITER;
      FCL_TEMPSTR[1] = 0;

      FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    // } else {

    }

  }

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Takes an ASCII string and using a delimiter converts it into an array of floats
       :Returns the number of values discovered and placed into the DataArray,
       :e.g. "1.1,2.2,3.3,4.4" would become {1.1,2.2,3.3,4.4}
       :
       :Parameters for macro ExplodeToFloatArray:
       :  StringInput[20] : Data string e.g. "1,2,3,4"
       :  Delimiter : Delimiting character byte for example ','
       :  DataArray[100] : Data array to hold the numberic values found
       :  MaxCount : Maximum number of values to return
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_087d1_AdvString1__ExplodeToFloatArray(MX_CHAR *FCL_STRINGINPUT, MX_UINT16 FCLsz_STRINGINPUT, MX_UINT8 FCL_DELIMITER, MX_FLOAT *FCL_DATAARRAY, MX_UINT16 FCLsz_DATAARRAY, MX_UINT16 FCL_MAXCOUNT)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_LEN;
  MX_UINT8 FCL_TSIDX = (0x0);
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  FCL_LEN = FCI_GETLENGTH(FCL_STRINGINPUT, FCLsz_STRINGINPUT);

  while (FCL_IDX < FCL_LEN)
  {
    if (FCL_STRINGINPUT[FCL_IDX] == FCL_DELIMITER)
    {    

      FCL_TEMPSTR[FCL_TSIDX] = 0;
      FCL_TSIDX = 0;

      FCL_DATAARRAY[FCR_RETVAL] = FCI_STRING_TO_FLOAT(FCL_TEMPSTR, FCLsz_TEMPSTR);
      FCR_RETVAL = FCR_RETVAL + 1;

      if (FCR_RETVAL == FCL_MAXCOUNT)
      {      

        goto FCC_ExplodeToFloatArray_A;

      // } else {

      }

    } else {

      if (FCL_TSIDX < 19)
      {      

        FCL_TEMPSTR[FCL_TSIDX] = FCL_STRINGINPUT[FCL_IDX];
        FCL_TSIDX = FCL_TSIDX + 1;

      // } else {

      }

    }

    FCL_IDX = FCL_IDX + 1;

  }

  if (FCL_TSIDX > 0)
  {  

    FCL_TEMPSTR[FCL_TSIDX] = 0;
    FCL_TSIDX = 0;

    FCL_DATAARRAY[FCR_RETVAL] = FCI_STRING_TO_FLOAT(FCL_TEMPSTR, FCLsz_TEMPSTR);
    FCR_RETVAL = FCR_RETVAL + 1;

  // } else {

  }

FCC_ExplodeToFloatArray_A:
  ;

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Converts a signed int to a string of a fixed size.
       :The value 5 with a length of 3 and a character of '0' would generate "003"
       :
       :Parameters for macro FormattedStringINT:
       :  Value : value to format
       :  MinLength : The minimum length you want the string to be
       :  PaddChar : Added character to padd the string with e.g. ' ' or '0'
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__FormattedStringINT(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_SINT16 FCL_VALUE, MX_UINT8 FCL_MINLENGTH, MX_UINT8 FCL_PADDCHAR)
{
  //Local variable definitions
  MX_UINT8 FCL_LEN;
  MX_UINT8 FCL_IDX = (0x0);
  #define FCLsz_TEMP 20
  MX_CHAR FCL_TEMP[FCLsz_TEMP];


  FCI_TOSTRING(FCL_VALUE, FCL_TEMP,20);

  FCL_LEN = FCI_GETLENGTH(FCL_TEMP, FCLsz_TEMP);

  while ((FCL_LEN + FCL_IDX) < FCL_MINLENGTH)
  {
    FCR_RETVAL[FCL_IDX] = FCL_PADDCHAR;

    FCL_IDX = FCL_IDX + 1;

  }

  FCR_RETVAL[FCL_IDX] = 0;

  FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMP,FCLsz_TEMP, FCR_RETVAL,2000);

  //Local variable definitions
  #undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Creates an ASCII string from an array of integer values.
       :Places a delimiter in between each value.
       :e.g. {1,2,3,4} would become "1,2,3,4"
       :
       :Parameters for macro ImplodeFromINTArray:
       :  DataArray[100] : MX_UINT16
       :  Count : Number of values held in the array
       :  Delimiter : Delimiter to add between values
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_087d1_AdvString1__ImplodeFromINTArray(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT16 *FCL_DATAARRAY, MX_UINT16 FCLsz_DATAARRAY, MX_UINT16 FCL_COUNT, MX_UINT8 FCL_DELIMITER)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_IDX = (0x0);


  FCI_SCOPY("",1, FCR_RETVAL,FCRsz_RETVAL);

  while (FCL_IDX < FCL_COUNT)
  {
    FCI_TOSTRING(FCL_DATAARRAY[FCL_IDX], FCL_TEMPSTR,20);

    FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    FCL_IDX = FCL_IDX + 1;

    if (FCL_IDX < FCL_COUNT)
    {    

      FCL_TEMPSTR[0] = FCL_DELIMITER;
      FCL_TEMPSTR[1] = 0;

      FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCL_TEMPSTR,FCLsz_TEMPSTR, FCR_RETVAL,2000);

    // } else {

    }

  }

  //Local variable definitions
  #undef FCLsz_TEMPSTR
}


/*========================================================================*\
   Use :JSONEncoder1
       :GUID: f2ad060d-0ae3-43d2-9d82-f49eb4215240
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\JSONEncoder.fcpx
       :Version: 5.0 (0x100028)
       :Timestamp: 26\02\2024
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_03ce1_JSONEncoder1__ELEMENTDATA 60
MX_GLOBAL MX_CHAR FCV_03ce1_JSONEncoder1__ELEMENTDATA[FCVsz_03ce1_JSONEncoder1__ELEMENTDATA];

/*=----------------------------------------------------------------------=*\
   Use :Generates a JSON data string with the current specified values.
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_03ce1_JSONEncoder1__GenerateJSON(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;


  FCI_SCOPY("{",2, FCR_RETVAL,FCRsz_RETVAL);

  FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, FCV_03ce1_JSONEncoder1__ELEMENTDATA,FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, FCR_RETVAL,2000);

  FCI_SHEAD(FCR_RETVAL,FCRsz_RETVAL, "}\n",3, FCR_RETVAL,2000);

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a data value as a string
       :
       :Parameters for macro AssignDataAsString:
       :  Element : Index of the element to assign the data to
       :  Data[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_03ce1_JSONEncoder1__AssignDataAsString(MX_UINT16 FCL_ELEMENT, MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{

  FCD_03ce1_JSONEncoder1__PutData(FCL_ELEMENT, FCL_DATA, FCLsz_DATA, 1, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a data value as a floating point value
       :
       :Parameters for macro AssignDataAsFloat:
       :  Element : Index of the element to assign the data to
       :  Data : MX_FLOAT
       :  NumDP : Number of decimal points
\*=----------------------------------------------------------------------=*/
void FCD_03ce1_JSONEncoder1__AssignDataAsFloat(MX_UINT16 FCL_ELEMENT, MX_FLOAT FCL_DATA, MX_UINT8 FCL_NUMDP)
{
  //Local variable definitions
  #define FCLsz_STRDATA 20
  MX_CHAR FCL_STRDATA[FCLsz_STRDATA];


  FCI_FLOAT_TO_STRING(FCL_DATA, FCL_NUMDP, FCL_STRDATA, FCLsz_STRDATA);

  FCD_03ce1_JSONEncoder1__PutData(FCL_ELEMENT, FCL_STRDATA, FCLsz_STRDATA, 0, 1);

  //Local variable definitions
  #undef FCLsz_STRDATA
}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a name value as a string.
       :Call this macro first before assigning data to the element.
       :
       :Parameters for macro AssignName:
       :  Element : Index of the element to assign the data to
       :  Name[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_03ce1_JSONEncoder1__AssignName(MX_UINT16 FCL_ELEMENT, MX_CHAR *FCL_NAME, MX_UINT16 FCLsz_NAME)
{

  FCD_03ce1_JSONEncoder1__PutData(FCL_ELEMENT, FCL_NAME, FCLsz_NAME, 1, 0);

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a data value as a integer value
       :
       :Parameters for macro AssignDataAsNumber:
       :  Element : Index of the element to assign the data to
       :  Data : MX_SINT32
\*=----------------------------------------------------------------------=*/
void FCD_03ce1_JSONEncoder1__AssignDataAsNumber(MX_UINT16 FCL_ELEMENT, MX_SINT32 FCL_DATA)
{
  //Local variable definitions
  #define FCLsz_STRDATA 20
  MX_CHAR FCL_STRDATA[FCLsz_STRDATA];


  FCI_TOSTRING(FCL_DATA, FCL_STRDATA,20);

  FCD_03ce1_JSONEncoder1__PutData(FCL_ELEMENT, FCL_STRDATA, FCLsz_STRDATA, 0, 1);

  //Local variable definitions
  #undef FCLsz_STRDATA
}

/*=----------------------------------------------------------------------=*\
   Use :Clears all the names and data values out of the buffer
\*=----------------------------------------------------------------------=*/
void FCD_03ce1_JSONEncoder1__ClearAll()
{

  FCI_SCOPY("",1, FCV_03ce1_JSONEncoder1__ELEMENTDATA,FCVsz_03ce1_JSONEncoder1__ELEMENTDATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Puts data into the buffer at the specified location in the data buffer
       :
       :Parameters for macro PutData:
       :  Element : Index of the element to write data to
       :  Data[20] : MX_CHAR (by-ref)
       :  AddQuotes : MX_BOOL
       :  IsData : MX_BOOL
\*=----------------------------------------------------------------------=*/
void FCD_03ce1_JSONEncoder1__PutData(MX_UINT16 FCL_ELEMENT, MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_BOOL FCL_ADDQUOTES, MX_BOOL FCL_ISDATA)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_LENGTH;
  MX_UINT16 FCL_DATALENGTH;
  MX_UINT16 FCL_NEXTIDX;
  MX_BOOL FCL_FOUND = (0);


  FCL_LENGTH = FCI_GETLENGTH(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA);
  FCL_DATALENGTH = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);

  //Comment:
  //First scan through the data to find the start of the data
  //do this by counting commas.

  while ((FCL_IDX < FCL_LENGTH) && (FCL_ELEMENT > 0))
  {
    if (FCV_03ce1_JSONEncoder1__ELEMENTDATA[FCL_IDX] == ',')
    {    

      FCL_ELEMENT = FCL_ELEMENT - 1;

    // } else {

    }

    FCL_IDX = FCL_IDX + 1;

  }

  if (FCL_ELEMENT)
  {  

    while ((FCL_ELEMENT > 0) && (FCL_LENGTH < 60))
    {
      FCI_SHEAD(FCV_03ce1_JSONEncoder1__ELEMENTDATA,FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, ",",2, FCV_03ce1_JSONEncoder1__ELEMENTDATA,100);

      FCL_IDX = FCL_IDX + 1;
      FCL_LENGTH = FCL_LENGTH + 1;

      FCL_ELEMENT = FCL_ELEMENT - 1;

    }

  // } else {

  }

  if (FCL_ISDATA)
  {  

  FCC_PutData_A:
    ;

    FCL_NEXTIDX = FCL_IDX;
    FCL_FOUND = 0;

    while ((FCL_IDX < FCL_LENGTH) && (FCL_FOUND == 0))
    {
      if (FCV_03ce1_JSONEncoder1__ELEMENTDATA[FCL_IDX] == ':')
      {      

        FCL_FOUND = 1;

      // } else {

      }

      if (FCV_03ce1_JSONEncoder1__ELEMENTDATA[FCL_IDX] == ',')
      {      

        FCL_IDX = FCL_LENGTH;

      // } else {

      }

      FCL_IDX = FCL_IDX + 1;

    }

    if (FCL_FOUND == 0)
    {    

      FCL_IDX = FCL_NEXTIDX;

      if (FCL_IDX == FCL_LENGTH)
      {      

        FCI_SHEAD(FCV_03ce1_JSONEncoder1__ELEMENTDATA,FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, "\"\":",4, FCV_03ce1_JSONEncoder1__ELEMENTDATA,100);

      } else {

        FCD_087d1_AdvString1__InsertInto(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, " \"\":", 5, FCL_IDX);

      }

      FCL_LENGTH = FCI_GETLENGTH(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA);

      goto FCC_PutData_A;

    // } else {

    }

    FCL_NEXTIDX = FCL_IDX;
    FCL_FOUND = 0;

    while ((FCL_NEXTIDX < FCL_LENGTH) && (FCL_FOUND == 0))
    {
      if (FCV_03ce1_JSONEncoder1__ELEMENTDATA[FCL_NEXTIDX] == ',')
      {      

        FCL_FOUND = 1;

      } else {

        FCL_NEXTIDX = FCL_NEXTIDX + 1;

      }

    }

  } else {

    FCL_NEXTIDX = FCL_IDX;

    while ((FCL_NEXTIDX < FCL_LENGTH) && (FCL_FOUND == 0))
    {
      if ((FCV_03ce1_JSONEncoder1__ELEMENTDATA[FCL_NEXTIDX] == ':') || (FCV_03ce1_JSONEncoder1__ELEMENTDATA[FCL_NEXTIDX] == ','))
      {      

        FCL_FOUND = 1;

      } else {

        FCL_NEXTIDX = FCL_NEXTIDX + 1;

      }

    }

  }

  if ((FCL_FOUND) || (FCL_NEXTIDX != FCL_IDX))
  {  

    FCD_087d1_AdvString1__RemoveFrom(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, FCL_NEXTIDX - FCL_IDX, FCL_IDX);

  // } else {

  }

  if (FCL_ADDQUOTES)
  {  

    FCD_087d1_AdvString1__InsertInto(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, "\"", 2, FCL_IDX);

    FCD_087d1_AdvString1__InsertInto(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, FCL_DATA, FCLsz_DATA, FCL_IDX + 1);

    FCD_087d1_AdvString1__InsertInto(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, "\"", 2, FCL_IDX + 1 + FCL_DATALENGTH);

    if (FCL_ISDATA == 0)
    {    

      FCD_087d1_AdvString1__InsertInto(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, ":", 2, FCL_IDX + 2 + FCL_DATALENGTH);

    // } else {

    }

  } else {

    FCD_087d1_AdvString1__InsertInto(FCV_03ce1_JSONEncoder1__ELEMENTDATA, FCVsz_03ce1_JSONEncoder1__ELEMENTDATA, FCL_DATA, FCLsz_DATA, FCL_IDX);

  }

}


/*========================================================================*\
   Use :gLCD_EB3_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawBitmapScaled:
       :  Filename[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Orientation : MX_UINT8
       :  Transparency : MX_UINT8
       :  Flip : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_019f1_gLCD_EB3_Dummy1__DrawBitmapScaled(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X1, MX_UINT16 FCL_X2, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawQRCode:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  Scaler : MX_UINT8
       :  Text[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_019f1_gLCD_EB3_Dummy1__DrawQRCode(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_SCALER, MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns the colour to use as the transparent mask. 
       :Anything in this specific colour will not be drawn when the DrawBitmap->Transparent parameter is set.
       :
       :Parameters for macro SetBitmapTransparency:
       :  R : Colour channel. Range: 0 to 255
       :  G : Colour channel. Range: 0 to 255
       :  B : Colour channel. Range: 0 to 255
\*=----------------------------------------------------------------------=*/
void FCD_019f1_gLCD_EB3_Dummy1__SetBitmapTransparency(MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawBitmap:
       :  Filename[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Orientation : MX_UINT8
       :  Transparency : MX_UINT8
       :  Flip : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_019f1_gLCD_EB3_Dummy1__DrawBitmap(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X1, MX_UINT16 FCL_X2, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SendBinaryScene:
       :  Data[2048] : MX_UINT8
       :  Length : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_019f1_gLCD_EB3_Dummy1__SendBinaryScene(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_LENGTH)
{

}


/*========================================================================*\
   Use :LEDMatrixHT16K33_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Prints an ASCII string onto the LED Matrix a column at a time.
       :
       :Parameters for macro DisplayString:
       :  Data[20] : Data string to display on the LEDs
       :  Animation_Delay : Delay in milliseconds between writing to the next column
       :  Leadout : Allows the text to scroll completely off the display before returning 0=No, 1=Yes
       :  Add_Spaces : Add spaces between each ASCII character 0=No, 1=Yes
       :  Orientation : 0=Normal, 1=Rotated 90 Degrees
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__DisplayString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_ANIMATION_DELAY, MX_UINT8 FCL_LEADOUT, MX_UINT8 FCL_ADD_SPACES, MX_UINT8 FCL_ORIENTATION)
{
  //Local variable definitions
  MX_UINT8 FCL_LEN_STR;
  MX_UINT8 FCL_IDX = (0x0);
  MX_UINT8 FCL_POS_STR;
  MX_UINT8 FCL_COUNT;
  MX_UINT8 FCL_DBYTE;


}

/*=----------------------------------------------------------------------=*\
   Use :Configures the brightness of the LEDs by varying the On portion of the duty.
       :
       :Parameters for macro SetBrightness:
       :  Brightness : Range: 0-15 - 0 = Min Brightness, 15 = Full Brightness
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__SetBrightness(MX_UINT8 FCL_BRIGHTNESS)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Shifts the columns one place left or right. 
       :Used for things like displaying scrolling text.
       :
       :Parameters for macro ShiftColumns:
       :  Direction : 0 = Shift Left, 1 = Shift Right
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__ShiftColumns(MX_UINT8 FCL_DIRECTION)
{
  //Local variable definitions
  MX_UINT8 FCL_IDX = (0x0);
  MX_UINT8 FCL_TEMP;


}

/*=----------------------------------------------------------------------=*\
   Use :Sets all of the LEDs in the matrix to the off state.
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__ClearLEDs()
{
  //Local variable definitions
  MX_UINT8 FCL_COL_IDX = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Allows a single LED to be controlled using the basic column / row coordinate system.
       :Each column is comprised of 8 rows.
       :
       :Parameters for macro WriteLED:
       :  Column : Range: 0-15
       :  Row : Range: 0-7
       :  Data : 0 = LED Off, 1 = LED On
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__WriteLED(MX_UINT8 FCL_COLUMN, MX_UINT8 FCL_ROW, MX_UINT8 FCL_DATA)
{
  //Local variable definitions
  MX_UINT8 FCL_ROW_IDX = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Allows a single LED to be controlled using a more standard X, Y coordinate system.
       :0,0 refers to the bottom left hand LED.
       :Only works with the fixed display modules, custom module not supported.
       :
       :Parameters for macro WriteLEDXY:
       :  X : X coordinate. Range: 0-15
       :  Y : Y coordinate. Range: 0-15
       :  State : State 0=Off, 1=On
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__WriteLEDXY(MX_UINT8 FCL_X, MX_UINT8 FCL_Y, MX_UINT8 FCL_STATE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Writes a command.
       :
       :Parameters for macro WriteCommand:
       :  Command : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__WriteCommand(MX_UINT8 FCL_COMMAND)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Allows a single column of 8 LEDs to be controlled in a single action.
       :
       :Parameters for macro WriteColumn:
       :  Column : Range: 0-15
       :  Data : Data to display on the column of LEDs
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__WriteColumn(MX_UINT8 FCL_COLUMN, MX_UINT8 FCL_DATA)
{
  //Local variable definitions
  MX_UINT8 FCL_ROW_IDX = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Writes a value to a register.
       :
       :Parameters for macro WriteRegister:
       :  Address : MX_UINT8
       :  Value : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__WriteRegister(MX_UINT8 FCL_ADDRESS, MX_UINT8 FCL_VALUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Configures the I2C peripheral and sets up the HT16K33 IC ready to drive the LEDs.
\*=----------------------------------------------------------------------=*/
void FCD_08902_LEDMatrixHT16K33_Dummy1__Initialise()
{
  //Local variable definitions
  MX_UINT8 FCL_IDX = (0x0);


}


/*========================================================================*\
   Use :FATDummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Attempts to move to the next sector in the file.
       :When reading a file you would leave force next sector set to 0.
       :When writing a file you would  leave force next sector set to 1 to allow new sectors to be created as the file grows.
       :Returns 0 for success
       :
       :Parameters for macro MoveToNextFileSector:
       :  Force_Next_Sector : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__MoveToNextFileSector(MX_UINT8 FCL_FORCE_NEXT_SECTOR)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro WriteByteToBuffer:
       :  Address : MX_UINT16
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02372_FATDummy1__WriteByteToBuffer(MX_UINT16 FCL_ADDRESS, MX_UINT8 FCL_DATA)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro AppendByteToFile:
       :  Data : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__AppendByteToFile(MX_UINT8 FCL_DATA)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_02372_FATDummy1__CloseFile()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Reads a byte from the currently open file. Auto increments the position in the file.
       :A return value of 0 may signify the end of the file has been reached (depending on the contents of the file).
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_02372_FATDummy1__ReadByteFromFile()
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT8 FCL_DATA_BYTE;
  MX_UINT16 FCL_SECTOR_SIZE;
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads a byte of data from the local sector buffer.
       :Return = Data byte read from the local sector buffer.
       :
       :Parameters for macro ReadByteFromIndex:
       :  Address : MX_UINT32
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__ReadByteFromIndex(MX_UINT32 FCL_ADDRESS)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DeleteFile:
       :  Filename[13] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__DeleteFile(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro CreateFile:
       :  Filename[13] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__CreateFile(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro OpenFolder:
       :  Folder_Name[20] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__OpenFolder(MX_CHAR *FCL_FOLDER_NAME, MX_UINT16 FCLsz_FOLDER_NAME)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the number of bytes in the current sector that are used by the current open file.
       :Return = 512 - Sector is filled with file data
       :Return < 512 - Last sector of the file, Retval specifies how many bytes of data are remaining in the sector
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_02372_FATDummy1__ReadFileLength()
{
  //Local variable definitions
  MX_SINT32 FCL_TEMP;
  MX_SINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Searches for and opens a file for reading or writing from within the current directory on the disk.
       :Returns 0 for success.
       :
       :Parameters for macro OpenFile:
       :  Filename[12] : 8.3 filename of the file we are trying to open e.g. "file.txt"
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__OpenFile(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
  //Local variable definitions
  MX_UINT8 FCL_I;
  #define FCLsz_NAME_COMP 12
  MX_CHAR FCL_NAME_COMP[FCLsz_NAME_COMP];
  MX_UINT16 FCL_IDX_FAT;
  MX_UINT16 FCL_IDX;
  MX_UINT32 FCL_FAT_POINTER;
  MX_UINT32 FCL_FAT_ADDRESS;
  MX_UINT8 FCL_J;
  MX_UINT16 FCL_TEMP;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_NAME_COMP
}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__WriteFileSector()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro AppendStringToFile:
       :  Data_String[20] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02372_FATDummy1__AppendStringToFile(MX_CHAR *FCL_DATA_STRING, MX_UINT16 FCLsz_DATA_STRING)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the entire size of the current file in bytes.
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_02372_FATDummy1__ReadFileSize()
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut10
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb23_lut10__FLOATFIXEDLIST 1
#define FCD_00fb23_lut10__INTFIXEDLIST(ix) FCD_00fb23_lut10__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb23_lut10__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb23_lut10__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut8
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb22_lut8__FLOATFIXEDLIST 1
#define FCD_00fb22_lut8__INTFIXEDLIST(ix) FCD_00fb22_lut8__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb22_lut8__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb22_lut8__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut7
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb21_lut7__FLOATFIXEDLIST 1
#define FCD_00fb21_lut7__INTFIXEDLIST(ix) FCD_00fb21_lut7__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb21_lut7__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb21_lut7__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut6
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb20_lut6__FLOATFIXEDLIST 1
#define FCD_00fb20_lut6__INTFIXEDLIST(ix) FCD_00fb20_lut6__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb20_lut6__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb20_lut6__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut5
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1f_lut5__FLOATFIXEDLIST 1
#define FCD_00fb1f_lut5__INTFIXEDLIST(ix) FCD_00fb1f_lut5__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1f_lut5__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1f_lut5__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut4
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1e_lut4__FLOATFIXEDLIST 1
#define FCD_00fb1e_lut4__INTFIXEDLIST(ix) FCD_00fb1e_lut4__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1e_lut4__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1e_lut4__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut3
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1d_lut3__FLOATFIXEDLIST 1
#define FCD_00fb1d_lut3__INTFIXEDLIST(ix) FCD_00fb1d_lut3__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1d_lut3__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1d_lut3__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut2
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1c_lut2__FLOATFIXEDLIST 1
#define FCD_00fb1c_lut2__INTFIXEDLIST(ix) FCD_00fb1c_lut2__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1c_lut2__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1c_lut2__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :LED_WS2811_Dummy
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the colour of a single LED in RAM as a 1D array.
       :
       :Parameters for macro SetLEDColour:
       :  LED : LED to change the colour / Range: 0 to (LED Count - 1)
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_03fc2_LED_WS2811_Dummy__SetLEDColour(MX_UINT16 FCL_LED, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the index of a single LED in RAM as a 2D array.
       :
       :Parameters for macro GetLEDIndex2D:
       :  X : LED Column to change the colour / Range: 0 to (LED Column - 1)
       :  Y : LED Row to change the colour / Range: 0 to (LED Row - 1)
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_03fc2_LED_WS2811_Dummy__GetLEDIndex2D(MX_UINT16 FCL_X, MX_UINT16 FCL_Y)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle2D:
       :  X1 : MX_UINT8
       :  Y1 : MX_UINT8
       :  X2 : MX_UINT8
       :  Y2 : MX_UINT8
       :  DrawStyle : MX_UINT8
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_03fc2_LED_WS2811_Dummy__DrawRectangle2D(MX_UINT8 FCL_X1, MX_UINT8 FCL_Y1, MX_UINT8 FCL_X2, MX_UINT8 FCL_Y2, MX_UINT8 FCL_DRAWSTYLE, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

}


/*========================================================================*\
   Use :Glcd_MIAC_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Prints the given character string to the display at the current cursor position and moves the cursor position.
       :
       :Parameters for macro PrintString:
       :  Str[20] : The string to send to the display.
\*=----------------------------------------------------------------------=*/
void FCD_05452_Glcd_MIAC_Dummy1__PrintString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{
  //Local variable definitions
  MX_UINT8 FCL_IDX;
  MX_UINT16 FCL_LEN;


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRect:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  state : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_05452_Glcd_MIAC_Dummy1__DrawRect(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_STATE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawPixel:
       :  px : MX_UINT8
       :  py : MX_UINT8
       :  state : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_05452_Glcd_MIAC_Dummy1__DrawPixel(MX_UINT8 FCL_PX, MX_UINT8 FCL_PY, MX_UINT8 FCL_STATE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the display cursor to the given position.
       :If the cursor is set to the origin at x=0, y=0, then the next character sent to the display will appear in the top left corner.
       :
       :Parameters for macro DisplayCursor:
       :  x : Position of the cursor in characters from left to right.
       :  y : The line to move the cursor to.
\*=----------------------------------------------------------------------=*/
void FCD_05452_Glcd_MIAC_Dummy1__DisplayCursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

}


/*========================================================================*\
   Use :Glcd_Mon_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawEllipse:
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  XRadius : MX_UINT16
       :  YRadius : MX_UINT16
       :  Transparent : MX_UINT8
       :  Soild : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOILD)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_FLOAT FCL_STARTANGLE, MX_FLOAT FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetDisplayOrientation:
       :  Orientation : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Print:
       :  Str[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  Font : MX_UINT8
       :  Transparent : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__ClearDisplay()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetBackgroundColour:
       :  Pixel_Colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__SetBackgroundColour(MX_UINT8 FCL_PIXEL_COLOUR)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_D;
  MX_SINT16 FCL_CURX;
  MX_SINT16 FCL_CURY;
  MX_UINT32 FCL_BGCOL;
  MX_UINT32 FCL_FGCOL;
  MX_UINT8 FCL_REP = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  #define FCLsz_COLSAVE 3
  MX_UINT8 FCL_COLSAVE[FCLsz_COLSAVE];
  MX_SINT16 FCL_G;
  MX_SINT16 FCL_HEIGHT;
  MX_SINT16 FCL_OXX1 = (0);
  MX_SINT16 FCL_OXX2 = (0);
  MX_SINT16 FCL_R;
  MX_SINT16 FCL_WIDTH;
  MX_SINT16 FCL_XX1;
  MX_SINT16 FCL_XX2;
  MX_SINT16 FCL_Y;
  MX_UINT16 FCL_COLSAVE16;


  //Local variable definitions
  #undef FCLsz_COLSAVE
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetForegroundColour:
       :  Pixel_Colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__SetForegroundColour(MX_UINT8 FCL_PIXEL_COLOUR)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d73_Glcd_Mon_Dummy1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}


/*========================================================================*\
   Use :Glcd_Col_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawEllipse:
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  XRadius : MX_UINT16
       :  YRadius : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at current pixel location.
       :Not compatible with orientations other than 0.
       :Currently does not simulate.
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__FastPlot()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_FLOAT FCL_STARTANGLE, MX_FLOAT FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetDisplayOrientation:
       :  Orientation : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies a full screen or sub window of pixels to draw.
       :Useful when used with the FastPlot function to draw bitmaps at high speed.
       :Does not simulate.
       :
       :Parameters for macro Window:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Print:
       :  Str[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  Font : MX_UINT8
       :  Transparent : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__ClearDisplay()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetBackgroundColour:
       :  Red : MX_UINT8
       :  Green : MX_UINT8
       :  Blue : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_D;
  MX_SINT16 FCL_CURX;
  MX_SINT16 FCL_CURY;
  MX_UINT32 FCL_BGCOL;
  MX_UINT32 FCL_FGCOL;
  MX_UINT8 FCL_REP = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  #define FCLsz_COLSAVE 3
  MX_UINT8 FCL_COLSAVE[FCLsz_COLSAVE];
  MX_SINT16 FCL_G;
  MX_SINT16 FCL_HEIGHT;
  MX_SINT16 FCL_OXX1 = (0);
  MX_SINT16 FCL_OXX2 = (0);
  MX_SINT16 FCL_R;
  MX_SINT16 FCL_WIDTH;
  MX_SINT16 FCL_XX1;
  MX_SINT16 FCL_XX2;
  MX_SINT16 FCL_Y;
  MX_UINT16 FCL_COLSAVE16;


  //Local variable definitions
  #undef FCLsz_COLSAVE
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetForegroundColour:
       :  Red : MX_UINT8
       :  Green : MX_UINT8
       :  Blue : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02153_Glcd_Col_Dummy1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}


/*========================================================================*\
   Use :lut1
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1b_lut1__FLOATFIXEDLIST 1
#define FCD_00fb1b_lut1__INTFIXEDLIST(ix) FCD_00fb1b_lut1__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1b_lut1__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1b_lut1__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :BitmapDrawerFATDummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image onto the display at the corrdinates X and Y.
       :Scales the bitmap to the specified width and height.
       :Return Values: 0=OK, 1=ColourDepthNotSupported, 237=FileNotFound
       :
       :Parameters for macro Display_Scaled_BMP:
       :  Filename[13] : Bitmap file to open from current directory on SD card 8.3 format
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Width : The size in pixels to draw the bitmap image
       :  Height : The size in pixels to draw the bitmap image
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_080c1_BitmapDrawerFATDummy1__Display_Scaled_BMP(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image onto the display at the corrdinates X and Y.
       :Scales the bitmap to the specified width and height.
       :Speeds up drawing by not assigning X/Y coordinate for each pixel.
       :Return Values: 0=OK, 1=ColourDepthNotSupported, 237=FileNotFound
       :
       :Parameters for macro Display_Scaled_BMP_Fast:
       :  Filename[13] : Bitmap file to open from current directory on SD card 8.3 format
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Width : The size in pixels to draw the bitmap image
       :  Height : The size in pixels to draw the bitmap image
       :  Mode : 0=RowByRow, 1=FullWindow(Y Flipped)
       :  Orientation : 0=Default, 1=Rotated 90 Degrees (only works with Mode 0)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_080c1_BitmapDrawerFATDummy1__Display_Scaled_BMP_Fast(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_BOOL FCL_MODE, MX_BOOL FCL_ORIENTATION)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the height of the loaded bitmap file in pixels.
       :
       :Parameters for macro GetHeight:
       :  Filename[20] : The filename of the bitmap we want to measure
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_080c1_BitmapDrawerFATDummy1__GetHeight(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the width of the loaded bitmap file in pixels.
       :
       :Parameters for macro GetWidth:
       :  Filename[20] : The filename of the bitmap we want to measure
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_080c1_BitmapDrawerFATDummy1__GetWidth(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the transparency colour, the colour that is not drawn when transparency is enabled.
       :
       :Parameters for macro SetTransparentColour:
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_080c1_BitmapDrawerFATDummy1__SetTransparentColour(MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image onto the display at the corrdinates X and Y.
       :Return Values: 0=OK, 1=ColourDepthNotSupported, 237=FileNotFound
       :
       :Parameters for macro Display_BMP:
       :  Filename[13] : Bitmap file to open from current directory on SD card 8.3 format
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_080c1_BitmapDrawerFATDummy1__Display_BMP(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image onto the display at the corrdinates X and Y.
       :Speeds up drawing by not assigning X/Y coordinate for each pixel.
       :Return Values: 0=OK, 1=ColourDepthNotSupported, 237=FileNotFound
       :
       :Parameters for macro Display_BMP_Fast:
       :  Filename[13] : Bitmap file to open from current directory on SD card 8.3 format
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Mode : 0=RowByRow, 1=FullWindow(Y Flipped)
       :  Orientation : 0=Default, 1=Rotated 90 Degrees (only works with Mode 0)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_080c1_BitmapDrawerFATDummy1__Display_BMP_Fast(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_BOOL FCL_MODE, MX_BOOL FCL_ORIENTATION)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :LEDMatrixHT16K33_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Prints an ASCII string onto the LED Matrix a column at a time.
       :
       :Parameters for macro DisplayString:
       :  Data[20] : Data string to display on the LEDs
       :  Animation_Delay : Delay in milliseconds between writing to the next column
       :  Leadout : Allows the text to scroll completely off the display before returning 0=No, 1=Yes
       :  Add_Spaces : Add spaces between each ASCII character 0=No, 1=Yes
       :  Orientation : 0=Normal, 1=Rotated 90 Degrees
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__DisplayString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_ANIMATION_DELAY, MX_UINT8 FCL_LEADOUT, MX_UINT8 FCL_ADD_SPACES, MX_UINT8 FCL_ORIENTATION)
{
  //Local variable definitions
  MX_UINT8 FCL_LEN_STR;
  MX_UINT8 FCL_IDX = (0x0);
  MX_UINT8 FCL_POS_STR;
  MX_UINT8 FCL_COUNT;
  MX_UINT8 FCL_DBYTE;


}

/*=----------------------------------------------------------------------=*\
   Use :Configures the brightness of the LEDs by varying the On portion of the duty.
       :
       :Parameters for macro SetBrightness:
       :  Brightness : Range: 0-15 - 0 = Min Brightness, 15 = Full Brightness
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__SetBrightness(MX_UINT8 FCL_BRIGHTNESS)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Shifts the columns one place left or right. 
       :Used for things like displaying scrolling text.
       :
       :Parameters for macro ShiftColumns:
       :  Direction : 0 = Shift Left, 1 = Shift Right
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__ShiftColumns(MX_UINT8 FCL_DIRECTION)
{
  //Local variable definitions
  MX_UINT8 FCL_IDX = (0x0);
  MX_UINT8 FCL_TEMP;


}

/*=----------------------------------------------------------------------=*\
   Use :Sets all of the LEDs in the matrix to the off state.
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__ClearLEDs()
{
  //Local variable definitions
  MX_UINT8 FCL_COL_IDX = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Allows a single LED to be controlled using the basic column / row coordinate system.
       :Each column is comprised of 8 rows.
       :
       :Parameters for macro WriteLED:
       :  Column : Range: 0-15
       :  Row : Range: 0-7
       :  Data : 0 = LED Off, 1 = LED On
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__WriteLED(MX_UINT8 FCL_COLUMN, MX_UINT8 FCL_ROW, MX_UINT8 FCL_DATA)
{
  //Local variable definitions
  MX_UINT8 FCL_ROW_IDX = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Allows a single LED to be controlled using a more standard X, Y coordinate system.
       :0,0 refers to the bottom left hand LED.
       :Only works with the fixed display modules, custom module not supported.
       :
       :Parameters for macro WriteLEDXY:
       :  X : X coordinate. Range: 0-15
       :  Y : Y coordinate. Range: 0-15
       :  State : State 0=Off, 1=On
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__WriteLEDXY(MX_UINT8 FCL_X, MX_UINT8 FCL_Y, MX_UINT8 FCL_STATE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Writes a command.
       :
       :Parameters for macro WriteCommand:
       :  Command : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__WriteCommand(MX_UINT8 FCL_COMMAND)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Allows a single column of 8 LEDs to be controlled in a single action.
       :
       :Parameters for macro WriteColumn:
       :  Column : Range: 0-15
       :  Data : Data to display on the column of LEDs
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__WriteColumn(MX_UINT8 FCL_COLUMN, MX_UINT8 FCL_DATA)
{
  //Local variable definitions
  MX_UINT8 FCL_ROW_IDX = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Writes a value to a register.
       :
       :Parameters for macro WriteRegister:
       :  Address : MX_UINT8
       :  Value : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__WriteRegister(MX_UINT8 FCL_ADDRESS, MX_UINT8 FCL_VALUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Configures the I2C peripheral and sets up the HT16K33 IC ready to drive the LEDs.
\*=----------------------------------------------------------------------=*/
void FCD_08901_LEDMatrixHT16K33_Dummy1__Initialise()
{
  //Local variable definitions
  MX_UINT8 FCL_IDX = (0x0);


}


/*========================================================================*\
   Use :lut10
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1a_lut10__FLOATFIXEDLIST 1
#define FCD_00fb1a_lut10__INTFIXEDLIST(ix) FCD_00fb1a_lut10__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1a_lut10__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1a_lut10__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut9
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb19_lut9__FLOATFIXEDLIST 1
#define FCD_00fb19_lut9__INTFIXEDLIST(ix) FCD_00fb19_lut9__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb19_lut9__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb19_lut9__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut8
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb18_lut8__FLOATFIXEDLIST 1
#define FCD_00fb18_lut8__INTFIXEDLIST(ix) FCD_00fb18_lut8__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb18_lut8__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb18_lut8__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut7
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb17_lut7__FLOATFIXEDLIST 1
#define FCD_00fb17_lut7__INTFIXEDLIST(ix) FCD_00fb17_lut7__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb17_lut7__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb17_lut7__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut6
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb16_lut6__FLOATFIXEDLIST 1
#define FCD_00fb16_lut6__INTFIXEDLIST(ix) FCD_00fb16_lut6__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb16_lut6__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb16_lut6__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut5
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb15_lut5__FLOATFIXEDLIST 1
#define FCD_00fb15_lut5__INTFIXEDLIST(ix) FCD_00fb15_lut5__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb15_lut5__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb15_lut5__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut4
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb14_lut4__FLOATFIXEDLIST 1
#define FCD_00fb14_lut4__INTFIXEDLIST(ix) FCD_00fb14_lut4__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb14_lut4__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb14_lut4__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut3
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb13_lut3__FLOATFIXEDLIST 1
#define FCD_00fb13_lut3__INTFIXEDLIST(ix) FCD_00fb13_lut3__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb13_lut3__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb13_lut3__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :lut2
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb12_lut2__FLOATFIXEDLIST 1
#define FCD_00fb12_lut2__INTFIXEDLIST(ix) FCD_00fb12_lut2__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb12_lut2__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb12_lut2__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :LED_WS2811_Dummy
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the colour of a single LED in RAM as a 1D array.
       :
       :Parameters for macro SetLEDColour:
       :  LED : LED to change the colour / Range: 0 to (LED Count - 1)
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_03fc1_LED_WS2811_Dummy__SetLEDColour(MX_UINT16 FCL_LED, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the index of a single LED in RAM as a 2D array.
       :
       :Parameters for macro GetLEDIndex2D:
       :  X : LED Column to change the colour / Range: 0 to (LED Column - 1)
       :  Y : LED Row to change the colour / Range: 0 to (LED Row - 1)
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_03fc1_LED_WS2811_Dummy__GetLEDIndex2D(MX_UINT16 FCL_X, MX_UINT16 FCL_Y)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle2D:
       :  X1 : MX_UINT8
       :  Y1 : MX_UINT8
       :  X2 : MX_UINT8
       :  Y2 : MX_UINT8
       :  DrawStyle : MX_UINT8
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_03fc1_LED_WS2811_Dummy__DrawRectangle2D(MX_UINT8 FCL_X1, MX_UINT8 FCL_Y1, MX_UINT8 FCL_X2, MX_UINT8 FCL_Y2, MX_UINT8 FCL_DRAWSTYLE, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

}


/*========================================================================*\
   Use :Glcd_MIAC_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Prints the given character string to the display at the current cursor position and moves the cursor position.
       :
       :Parameters for macro PrintString:
       :  Str[20] : The string to send to the display.
\*=----------------------------------------------------------------------=*/
void FCD_05451_Glcd_MIAC_Dummy1__PrintString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{
  //Local variable definitions
  MX_UINT8 FCL_IDX;
  MX_UINT16 FCL_LEN;


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRect:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  state : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_05451_Glcd_MIAC_Dummy1__DrawRect(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_STATE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawPixel:
       :  px : MX_UINT8
       :  py : MX_UINT8
       :  state : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_05451_Glcd_MIAC_Dummy1__DrawPixel(MX_UINT8 FCL_PX, MX_UINT8 FCL_PY, MX_UINT8 FCL_STATE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the display cursor to the given position.
       :If the cursor is set to the origin at x=0, y=0, then the next character sent to the display will appear in the top left corner.
       :
       :Parameters for macro DisplayCursor:
       :  x : Position of the cursor in characters from left to right.
       :  y : The line to move the cursor to.
\*=----------------------------------------------------------------------=*/
void FCD_05451_Glcd_MIAC_Dummy1__DisplayCursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

}


/*========================================================================*\
   Use :Glcd_Mon_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawEllipse:
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  XRadius : MX_UINT16
       :  YRadius : MX_UINT16
       :  Transparent : MX_UINT8
       :  Soild : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOILD)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_FLOAT FCL_STARTANGLE, MX_FLOAT FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetDisplayOrientation:
       :  Orientation : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Print:
       :  Str[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  Font : MX_UINT8
       :  Transparent : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__ClearDisplay()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetBackgroundColour:
       :  Pixel_Colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__SetBackgroundColour(MX_UINT8 FCL_PIXEL_COLOUR)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_D;
  MX_SINT16 FCL_CURX;
  MX_SINT16 FCL_CURY;
  MX_UINT32 FCL_BGCOL;
  MX_UINT32 FCL_FGCOL;
  MX_UINT8 FCL_REP = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  #define FCLsz_COLSAVE 3
  MX_UINT8 FCL_COLSAVE[FCLsz_COLSAVE];
  MX_SINT16 FCL_G;
  MX_SINT16 FCL_HEIGHT;
  MX_SINT16 FCL_OXX1 = (0);
  MX_SINT16 FCL_OXX2 = (0);
  MX_SINT16 FCL_R;
  MX_SINT16 FCL_WIDTH;
  MX_SINT16 FCL_XX1;
  MX_SINT16 FCL_XX2;
  MX_SINT16 FCL_Y;
  MX_UINT16 FCL_COLSAVE16;


  //Local variable definitions
  #undef FCLsz_COLSAVE
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetForegroundColour:
       :  Pixel_Colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__SetForegroundColour(MX_UINT8 FCL_PIXEL_COLOUR)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d72_Glcd_Mon_Dummy1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}


/*========================================================================*\
   Use :Glcd_Col_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawEllipse:
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  XRadius : MX_UINT16
       :  YRadius : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at current pixel location.
       :Not compatible with orientations other than 0.
       :Currently does not simulate.
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__FastPlot()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_FLOAT FCL_STARTANGLE, MX_FLOAT FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetDisplayOrientation:
       :  Orientation : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies a full screen or sub window of pixels to draw.
       :Useful when used with the FastPlot function to draw bitmaps at high speed.
       :Does not simulate.
       :
       :Parameters for macro Window:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Print:
       :  Str[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  Font : MX_UINT8
       :  Transparent : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__ClearDisplay()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetBackgroundColour:
       :  Red : MX_UINT8
       :  Green : MX_UINT8
       :  Blue : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_D;
  MX_SINT16 FCL_CURX;
  MX_SINT16 FCL_CURY;
  MX_UINT32 FCL_BGCOL;
  MX_UINT32 FCL_FGCOL;
  MX_UINT8 FCL_REP = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  #define FCLsz_COLSAVE 3
  MX_UINT8 FCL_COLSAVE[FCLsz_COLSAVE];
  MX_SINT16 FCL_G;
  MX_SINT16 FCL_HEIGHT;
  MX_SINT16 FCL_OXX1 = (0);
  MX_SINT16 FCL_OXX2 = (0);
  MX_SINT16 FCL_R;
  MX_SINT16 FCL_WIDTH;
  MX_SINT16 FCL_XX1;
  MX_SINT16 FCL_XX2;
  MX_SINT16 FCL_Y;
  MX_UINT16 FCL_COLSAVE16;


  //Local variable definitions
  #undef FCLsz_COLSAVE
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetForegroundColour:
       :  Red : MX_UINT8
       :  Green : MX_UINT8
       :  Blue : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02152_Glcd_Col_Dummy1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}


/*========================================================================*\
   Use :lut1
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb11_lut1__FLOATFIXEDLIST 1
#define FCD_00fb11_lut1__INTFIXEDLIST(ix) FCD_00fb11_lut1__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb11_lut1__INTFIXEDLIST_LUT ROMARRAY_E =
{

};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb11_lut1__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 0;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :BitmapDrawerDummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image from ROM onto the display at the corrdinates X and Y.
       :Scales the bitmap to the specified width and height.
       :
       :Parameters for macro Display_Scaled_BMP:
       :  BitmapIndex : Selects from attached bitmaps. Range: 0-9
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Width : The size in pixels to draw the bitmap image
       :  Height : The size in pixels to draw the bitmap image
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
\*=----------------------------------------------------------------------=*/
void FCD_08a51_BitmapDrawerDummy1__Display_Scaled_BMP(MX_UINT8 FCL_BITMAPINDEX, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image from ROM onto the display at the corrdinates X and Y.
       :Scales the bitmap to the specified width and height.
       :Speeds up drawing by not assigning X/Y coordinate for each pixel.
       :Currently only supports colour displays.
       :
       :Parameters for macro Display_Scaled_BMP_Fast:
       :  BitmapIndex : Selects from attached bitmaps. Range: 0-9
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Width : The size in pixels to draw the bitmap image
       :  Height : The size in pixels to draw the bitmap image
       :  Mode : 0=RowByRow, 1=FullWindow(Y Flipped)
\*=----------------------------------------------------------------------=*/
void FCD_08a51_BitmapDrawerDummy1__Display_Scaled_BMP_Fast(MX_UINT8 FCL_BITMAPINDEX, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_BOOL FCL_MODE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the height of the loaded bitmap file in pixels.
       :
       :Parameters for macro GetHeight:
       :  BitmapIndex : Selects from attached bitmaps. Range: 0-9
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08a51_BitmapDrawerDummy1__GetHeight(MX_UINT8 FCL_BITMAPINDEX)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the width of the loaded bitmap file in pixels.
       :
       :Parameters for macro GetWidth:
       :  BitmapIndex : Selects from attached bitmaps. Range: 0-9
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08a51_BitmapDrawerDummy1__GetWidth(MX_UINT8 FCL_BITMAPINDEX)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Checks to see if one of the loaded files matches the supplied filename.
       :If a match is found then returns the bitmap index 0-9.
       :If no match is found then returns 255.
       :
       :Parameters for macro LookupFilename:
       :  Filename[20] : Filename without the included path e.g. "sprite.bmp", not case sensitive
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08a51_BitmapDrawerDummy1__LookupFilename(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the transparency colour, the colour that is not drawn when transparency is enabled.
       :
       :Parameters for macro SetTransparentColour:
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_08a51_BitmapDrawerDummy1__SetTransparentColour(MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image from ROM onto the display at the corrdinates X and Y.
       :
       :Parameters for macro Display_BMP:
       :  BitmapIndex : Selects from attached bitmaps. Range: 0-9
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
\*=----------------------------------------------------------------------=*/
void FCD_08a51_BitmapDrawerDummy1__Display_BMP(MX_UINT8 FCL_BITMAPINDEX, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws the bitmap image from ROM onto the display at the corrdinates X and Y.
       :Speeds up drawing by not assigning X/Y coordinate for each pixel.
       :Currently only supports colour displays.
       :
       :Parameters for macro Display_BMP_Fast:
       :  BitmapIndex : Selects from attached bitmaps. Range: 0-9
       :  X : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Mode : 0=RowByRow, 1=FullWindow(Y Flipped)
\*=----------------------------------------------------------------------=*/
void FCD_08a51_BitmapDrawerDummy1__Display_BMP_Fast(MX_UINT8 FCL_BITMAPINDEX, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_BOOL FCL_MODE)
{

}


/*========================================================================*\
   Use :Glcd_Col_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawEllipse:
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  XRadius : MX_UINT16
       :  YRadius : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at current pixel location.
       :Not compatible with orientations other than 0.
       :Currently does not simulate.
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__FastPlot()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_FLOAT FCL_STARTANGLE, MX_FLOAT FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetDisplayOrientation:
       :  Orientation : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies a full screen or sub window of pixels to draw.
       :Useful when used with the FastPlot function to draw bitmaps at high speed.
       :Does not simulate.
       :
       :Parameters for macro Window:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Print:
       :  Str[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  Font : MX_UINT8
       :  Transparent : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__ClearDisplay()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetBackgroundColour:
       :  Red : MX_UINT8
       :  Green : MX_UINT8
       :  Blue : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_D;
  MX_SINT16 FCL_CURX;
  MX_SINT16 FCL_CURY;
  MX_UINT32 FCL_BGCOL;
  MX_UINT32 FCL_FGCOL;
  MX_UINT8 FCL_REP = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  #define FCLsz_COLSAVE 3
  MX_UINT8 FCL_COLSAVE[FCLsz_COLSAVE];
  MX_SINT16 FCL_G;
  MX_SINT16 FCL_HEIGHT;
  MX_SINT16 FCL_OXX1 = (0);
  MX_SINT16 FCL_OXX2 = (0);
  MX_SINT16 FCL_R;
  MX_SINT16 FCL_WIDTH;
  MX_SINT16 FCL_XX1;
  MX_SINT16 FCL_XX2;
  MX_SINT16 FCL_Y;
  MX_UINT16 FCL_COLSAVE16;


  //Local variable definitions
  #undef FCLsz_COLSAVE
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetForegroundColour:
       :  Red : MX_UINT8
       :  Green : MX_UINT8
       :  Blue : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_02151_Glcd_Col_Dummy1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}


/*========================================================================*\
   Use :Glcd_Mon_Dummy1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawEllipse:
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  XRadius : MX_UINT16
       :  YRadius : MX_UINT16
       :  Transparent : MX_UINT8
       :  Soild : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOILD)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_FLOAT FCL_STARTANGLE, MX_FLOAT FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetDisplayOrientation:
       :  Orientation : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Print:
       :  Str[20] : MX_CHAR (by-ref)
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  Font : MX_UINT8
       :  Transparent : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__ClearDisplay()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetBackgroundColour:
       :  Pixel_Colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__SetBackgroundColour(MX_UINT8 FCL_PIXEL_COLOUR)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_D;
  MX_SINT16 FCL_CURX;
  MX_SINT16 FCL_CURY;
  MX_UINT32 FCL_BGCOL;
  MX_UINT32 FCL_FGCOL;
  MX_UINT8 FCL_REP = (0x0);


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  #define FCLsz_COLSAVE 3
  MX_UINT8 FCL_COLSAVE[FCLsz_COLSAVE];
  MX_SINT16 FCL_G;
  MX_SINT16 FCL_HEIGHT;
  MX_SINT16 FCL_OXX1 = (0);
  MX_SINT16 FCL_OXX2 = (0);
  MX_SINT16 FCL_R;
  MX_SINT16 FCL_WIDTH;
  MX_SINT16 FCL_XX1;
  MX_SINT16 FCL_XX2;
  MX_SINT16 FCL_Y;
  MX_UINT16 FCL_COLSAVE16;


  //Local variable definitions
  #undef FCLsz_COLSAVE
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SetForegroundColour:
       :  Pixel_Colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__SetForegroundColour(MX_UINT8 FCL_PIXEL_COLOUR)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : MX_UINT8
       :  Solid : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_09d71_Glcd_Mon_Dummy1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

}


/*========================================================================*\
   Use :IsSim1
       :GUID: 5f7b77e5-e979-4010-93f1-e6d98f83bd71
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\IsSim.fcpx
       :Version: 6.0 (0x100028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Returns 0 if running on an embedded target or 1 if running in simulation runtime.
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_0b4c1_IsSim1__Check()
{
  //Local variable definitions
  MX_BOOL FCR_RETVAL;


  FCR_RETVAL = 0;

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :TypeConversions1
       :GUID: 6508c7be-063a-4f9f-bae5-4a41cf977a86
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\TypeConversions.fcpx
       :Version: 6.0 (0x100028)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets a single 16-bit INT value.
       :Index is in little endian, 0 is the LSW and 1 is the MSW
       :
       :Parameters for macro SetInt:
       :  Index : Range: 0-1
       :  Value : Range: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_08941_TypeConversions1__SetInt(MX_UINT8 FCL_INDEX, MX_UINT16 FCL_VALUE)
{

  if (FCL_INDEX < 2)
  {  

    // C Code
    MX_Conv_Var.AsInt[FCL_INDEX] = FCL_VALUE;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 32-bit LONG value
       :
       :Parameters for macro SetLong:
       :  Value : Range: 0-4294967295
\*=----------------------------------------------------------------------=*/
void FCD_08941_TypeConversions1__SetLong(MX_UINT32 FCL_VALUE)
{

  // C Code
  MX_Conv_Var.AsLong = FCL_VALUE;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 32-bit FLOAT value
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08941_TypeConversions1__GetFloat()
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  // C Code
  FCR_RETVAL = MX_Conv_Var.AsFloat;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 32-bit LONG value
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_08941_TypeConversions1__GetLong()
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  // C Code
  FCR_RETVAL = MX_Conv_Var.AsLong;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows all bytes to be set using a single macro
       :
       :Parameters for macro SetBytes:
       :  Byte0 : MX_UINT8
       :  Byte1 : MX_UINT8
       :  Byte2 : MX_UINT8
       :  Byte3 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_08941_TypeConversions1__SetBytes(MX_UINT8 FCL_BYTE0, MX_UINT8 FCL_BYTE1, MX_UINT8 FCL_BYTE2, MX_UINT8 FCL_BYTE3)
{

  // C Code
  MX_Conv_Var.AsByte[0] = FCL_BYTE0;
  MX_Conv_Var.AsByte[1] = FCL_BYTE1;
  MX_Conv_Var.AsByte[2] = FCL_BYTE2;
  MX_Conv_Var.AsByte[3] = FCL_BYTE3;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 16-bit INT value
       :Index is in little endian, 0 is the LSW and 1 is the MSW
       :
       :Parameters for macro GetInt:
       :  Index : Range: 0-1
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08941_TypeConversions1__GetInt(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  if (FCL_INDEX < 2)
  {  

    // C Code
    FCR_RETVAL = MX_Conv_Var.AsInt[FCL_INDEX];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 8-bit BYTE value
       :Index is in little endian, 0 is the LSB and 3 is the MSB
       :
       :Parameters for macro SetByte:
       :  Index : Range: 0-3
       :  Value : Range: 0-255
\*=----------------------------------------------------------------------=*/
void FCD_08941_TypeConversions1__SetByte(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_VALUE)
{

  if (FCL_INDEX < 4)
  {  

    // C Code
    MX_Conv_Var.AsByte[FCL_INDEX] = FCL_VALUE;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 8-bit BYTE value.
       :Index is in little endian, 0 is the LSB and 3 is the MSB
       :
       :Parameters for macro GetByte:
       :  Index : Range: 0-3
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08941_TypeConversions1__GetByte(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX < 4)
  {  

    // C Code
    FCR_RETVAL = MX_Conv_Var.AsByte[FCL_INDEX];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 32-bit FLOAT value
       :
       :Parameters for macro SetFloat:
       :  Value : Range: 0-4294967295
\*=----------------------------------------------------------------------=*/
void FCD_08941_TypeConversions1__SetFloat(MX_FLOAT FCL_VALUE)
{

  // C Code
  MX_Conv_Var.AsFloat = FCL_VALUE;

}

#define FCA_DISPLAYMANAGER1 0xa401
#define FCV_DISPLAYMANAGER1 0x0823

/*========================================================================*\
   Use :DisplayManager1
       :GUID: cbfb3c21-f13d-488d-9b90-400c8d4fc605
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\DisplayManager.fcpx
       :Version: 34.0 (0x1800028)
       :Timestamp: 20\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_0a401_DisplayManager1__H 40
#define FCVsz_0a401_DisplayManager1__WIDGETCOLOUR 20
#define FCVsz_0a401_DisplayManager1__WIDGETCOLOUR_1 4
#define FCVsz_0a401_DisplayManager1__WIDGETCOLOUR_2 3
#define FCVsz_0a401_DisplayManager1__VALUE 20
#define FCVsz_0a401_DisplayManager1__BITMAPFILENAME 20
#define FCVsz_0a401_DisplayManager1__OLDVALUE 20
#define FCVsz_0a401_DisplayManager1__OBJECTCOLOUR 20
#define FCVsz_0a401_DisplayManager1__OBJECTCOLOUR_1 3
#define FCVsz_0a401_DisplayManager1__OBJECTCOLOUR_2 3
#define FCVsz_0a401_DisplayManager1__WIDGETHANDLES 20
#define FCVsz_0a401_DisplayManager1__Y 40
#define FCVsz_0a401_DisplayManager1__X 40
#define FCVsz_0a401_DisplayManager1__TYPE 40
#define FCVsz_0a401_DisplayManager1__W 40
#define FCVsz_0a401_DisplayManager1__DRAWHIGHLIGHT 20
#define FCVsz_0a401_DisplayManager1__LINEWIDTH 40
#define FCV_0a401_DisplayManager1__OBJECT_ROUNDEDRECTANGLE (0x2)
#define FCV_0a401_DisplayManager1__WIDGET_RECTANGULAR (0x1)
#define FCV_0a401_DisplayManager1__WIDGET_ELLIPSE (0x3)
#define FCV_0a401_DisplayManager1__OBJECT_LINE (0x4)
#define FCV_0a401_DisplayManager1__OBJECT_HIDDEN (0x0)
#define FCV_0a401_DisplayManager1__OBJECT_RECTANGLE (0x1)
#define FCV_0a401_DisplayManager1__WIDGET_BITMAP (0x8)
#define FCV_0a401_DisplayManager1__WIDGET_HSLIDER_ROUND (0x7)
#define FCV_0a401_DisplayManager1__WIDGET_HSLIDER (0x5)
#define FCV_0a401_DisplayManager1__WIDGET_VSLIDER_ROUND (0x6)
#define FCV_0a401_DisplayManager1__WIDGET_HIDDEN (0x0)
#define FCV_0a401_DisplayManager1__WIDGET_VSLIDER (0x4)
#define FCV_0a401_DisplayManager1__WIDGET_ROUNDEDRECTANGLE (0x2)
#define FCV_0a401_DisplayManager1__OBJECT_ELLIPSE (0x3)
#define FCV_0a401_DisplayManager1__OBJECT_BITMAP (0x8)
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__H[FCVsz_0a401_DisplayManager1__H];
MX_GLOBAL MX_SINT16 FCV_0a401_DisplayManager1__LASTWIDGETPRESS = (-1);
MX_GLOBAL MX_UINT8 FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCVsz_0a401_DisplayManager1__WIDGETCOLOUR][FCVsz_0a401_DisplayManager1__WIDGETCOLOUR_1][FCVsz_0a401_DisplayManager1__WIDGETCOLOUR_2];
MX_GLOBAL MX_UINT8 FCV_0a401_DisplayManager1__SCENEIDX = (0x0);
MX_GLOBAL MX_FLOAT FCV_0a401_DisplayManager1__VALUE[FCVsz_0a401_DisplayManager1__VALUE];
MX_GLOBAL MX_CHAR FCV_0a401_DisplayManager1__BITMAPFILENAME[FCVsz_0a401_DisplayManager1__BITMAPFILENAME] = "";
MX_GLOBAL MX_FLOAT FCV_0a401_DisplayManager1__OLDVALUE[FCVsz_0a401_DisplayManager1__OLDVALUE];
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__NUMWIDGETS = (0x0);
MX_GLOBAL MX_UINT8 FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCVsz_0a401_DisplayManager1__OBJECTCOLOUR][FCVsz_0a401_DisplayManager1__OBJECTCOLOUR_1][FCVsz_0a401_DisplayManager1__OBJECTCOLOUR_2];
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__WIDGETHANDLES[FCVsz_0a401_DisplayManager1__WIDGETHANDLES] = {0};
MX_GLOBAL MX_BOOL FCV_0a401_DisplayManager1__SENDINGSCENE = (0);
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__NUMOBJECTS = (0x0);
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__Y[FCVsz_0a401_DisplayManager1__Y];
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__X[FCVsz_0a401_DisplayManager1__X];
MX_GLOBAL MX_UINT8 FCV_0a401_DisplayManager1__TYPE[FCVsz_0a401_DisplayManager1__TYPE];
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__W[FCVsz_0a401_DisplayManager1__W];
MX_GLOBAL MX_UINT8 FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCVsz_0a401_DisplayManager1__DRAWHIGHLIGHT] = {0};
MX_GLOBAL MX_UINT8 FCV_0a401_DisplayManager1__LINEWIDTH[FCVsz_0a401_DisplayManager1__LINEWIDTH] = {0};
MX_GLOBAL MX_UINT16 FCV_0a401_DisplayManager1__TOUCHINTERVAL = (0x0);
MX_GLOBAL MX_UINT32 FCV_0a401_DisplayManager1__CONSOLE;

/*=----------------------------------------------------------------------=*\
   Use :Clears the screen and adds and draws the objects and widgets from the layout editor.
       :
       :Parameters for macro DrawScene:
       :  SceneIndex : Select which screen to draw. Range: 0 to Scene Count - 1
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__DrawScene(MX_UINT8 FCL_SCENEINDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);
  #define FCLsz_DATA 25
  MX_UINT8 FCL_DATA[FCLsz_DATA];
  #define FCLsz_STR 100
  MX_CHAR FCL_STR[FCLsz_STR];
  MX_UINT8 FCL_STRIDX;
  MX_UINT16 FCL_LASTID = (0xff);
  MX_UINT16 FCL_COUNT;
  #define FCLsz_COLOURS 12
  MX_UINT8 FCL_COLOURS[FCLsz_COLOURS] = {0};


  #if (1) // 1 == 1
    FCV_0a401_DisplayManager1__SENDINGSCENE = 1;

    if (FCL_SCENEINDEX < 2)
    {    

      FCV_0a401_DisplayManager1__SCENEIDX = FCL_SCENEINDEX;

      // Code
      unsigned char * ptr;

      #if (0) // 0 == 1
      //Code has been optimised out by the pre-processor
      #else
        // Read Length of layout
        FCL_COUNT = DC_COUNT[FCL_SCENEINDEX];

        switch (FCL_SCENEINDEX)
        {
          case 1:
          {

            #if (1) // 2 > 1
              // Code
              ptr = LAYOUT1;

            // #else
            //Code has been optimised out by the pre-processor
            #endif

            break;
          }
          case 2:
          {

            #if (0) // 2 > 2
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 3:
          {

            #if (0) // 2 > 3
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 4:
          {

            #if (0) // 2 > 4
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 5:
          {

            #if (0) // 2 > 5
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 6:
          {

            #if (0) // 2 > 6
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 7:
          {

            #if (0) // 2 > 7
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 8:
          {

            #if (0) // 2 > 8
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 9:
          {

            #if (0) // 2 > 9
            //Code has been optimised out by the pre-processor
            // #else
            #endif

            break;
          }
          case 0:
          {

            // Code
            ptr = LAYOUT0;

            break;
          }
          // default:

        }

        #if (0) // 2 > 10
        //Code has been optimised out by the pre-processor
        // #else
        #endif

        #if (0) // 2 > 20
        //Code has been optimised out by the pre-processor
        // #else
        #endif

      #endif

      while (FCL_IDX < FCL_COUNT)
      {
        #if (0) // 0 == 1
        //Code has been optimised out by the pre-processor
        #else
          // Code
          FCL_DATA[0] = ptr[FCL_IDX];

        #endif

        FCL_IDX = FCL_IDX + 1;

        if (FCL_DATA[0] == 'C')
        {        

          #if (0) // 0 == 1
          //Code has been optimised out by the pre-processor
          #else
            // Code
            FCL_DATA[0] = ptr[FCL_IDX + 0]; //BgColour R
            FCL_DATA[1] = ptr[FCL_IDX + 1]; //BgColour G
            FCL_DATA[2] = ptr[FCL_IDX + 2]; //BgColour B

          #endif

          #if (1) // 0 == 0
            FCD_029f1_gLCD_EB3__SetBackgroundColour(FCL_DATA[0], FCL_DATA[1], FCL_DATA[2]);

            FCD_029f1_gLCD_EB3__ClearDisplay();

          #else
          //Code has been optimised out by the pre-processor
          #endif

          FCD_0a401_DisplayManager1__ClearAll(0);

          FCL_IDX = FCL_IDX + 3;

        // } else {

        }

        if (FCL_DATA[0] == 'O')
        {        

          #if (0) // 0 == 1
          //Code has been optimised out by the pre-processor
          #else
            // Code
            FCL_DATA[0] = ptr[FCL_IDX + 0];   //SubType
            FCL_DATA[1] = ptr[FCL_IDX + 1];   //XL
            FCL_DATA[2] = ptr[FCL_IDX + 2];   //XH
            FCL_DATA[3] = ptr[FCL_IDX + 3];   //YL
            FCL_DATA[4] = ptr[FCL_IDX + 4];   //YH
            FCL_DATA[5] = ptr[FCL_IDX + 5];   //WidthL
            FCL_DATA[6] = ptr[FCL_IDX + 6];   //WidthH
            FCL_DATA[7] = ptr[FCL_IDX + 7];   //HeightL
            FCL_DATA[8] = ptr[FCL_IDX + 8];   //HeightH
            FCL_DATA[9] = ptr[FCL_IDX + 9];   //Line Width
            FCL_DATA[10] = ptr[FCL_IDX + 10]; //FgColour R
            FCL_DATA[11] = ptr[FCL_IDX + 11]; //FgColour G
            FCL_DATA[12] = ptr[FCL_IDX + 12]; //FgColour B
            FCL_DATA[13] = ptr[FCL_IDX + 13]; //BgColour R
            FCL_DATA[14] = ptr[FCL_IDX + 14]; //BgColour G
            FCL_DATA[15] = ptr[FCL_IDX + 15]; //BgColour B
            FCL_DATA[16] = ptr[FCL_IDX + 16]; //TxColour R
            FCL_DATA[17] = ptr[FCL_IDX + 17]; //TxColour G
            FCL_DATA[18] = ptr[FCL_IDX + 18]; //TxColour B

          #endif

          FCL_COLOURS[0] = FCL_DATA[10];
          FCL_COLOURS[1] = FCL_DATA[11];
          FCL_COLOURS[2] = FCL_DATA[12];
          FCL_COLOURS[3] = FCL_DATA[13];
          FCL_COLOURS[4] = FCL_DATA[14];
          FCL_COLOURS[5] = FCL_DATA[15];
          FCL_COLOURS[6] = FCL_DATA[16];
          FCL_COLOURS[7] = FCL_DATA[17];
          FCL_COLOURS[8] = FCL_DATA[18];

          FCL_LASTID = FCD_0a401_DisplayManager1__CreateObject(FCL_DATA[0], FCL_DATA[1] + (FCL_DATA[2] << 8), FCL_DATA[3] + (FCL_DATA[4] << 8), FCL_DATA[5] + (FCL_DATA[6] << 8), FCL_DATA[7] + (FCL_DATA[8] << 8), FCL_DATA[9], FCL_COLOURS, 12, 1);

          FCL_IDX = FCL_IDX + 19;

        // } else {

        }

        if (FCL_DATA[0] == 'W')
        {        

          #if (0) // 0 == 1
          //Code has been optimised out by the pre-processor
          #else
            // Code
            FCL_DATA[0] = ptr[FCL_IDX + 0];   //SubType
            FCL_DATA[1] = ptr[FCL_IDX + 1];   //XL
            FCL_DATA[2] = ptr[FCL_IDX + 2];   //XH
            FCL_DATA[3] = ptr[FCL_IDX + 3];   //YL
            FCL_DATA[4] = ptr[FCL_IDX + 4];   //YH
            FCL_DATA[5] = ptr[FCL_IDX + 5];   //WidthL
            FCL_DATA[6] = ptr[FCL_IDX + 6];   //WidthH
            FCL_DATA[7] = ptr[FCL_IDX + 7];   //HeightL
            FCL_DATA[8] = ptr[FCL_IDX + 8];   //HeightL
            FCL_DATA[9] = ptr[FCL_IDX + 9];   //Line Width
            FCL_DATA[10] = ptr[FCL_IDX + 10]; //FgColour R
            FCL_DATA[11] = ptr[FCL_IDX + 11]; //FgColour G
            FCL_DATA[12] = ptr[FCL_IDX + 12]; //FgColour B
            FCL_DATA[13] = ptr[FCL_IDX + 13]; //BgColour R
            FCL_DATA[14] = ptr[FCL_IDX + 14]; //BgColour G
            FCL_DATA[15] = ptr[FCL_IDX + 15]; //BgColour B
            FCL_DATA[16] = ptr[FCL_IDX + 16]; //HlColour R
            FCL_DATA[17] = ptr[FCL_IDX + 17]; //HlColour G
            FCL_DATA[18] = ptr[FCL_IDX + 18]; //HlColour B
            FCL_DATA[19] = ptr[FCL_IDX + 19]; //LlColour R
            FCL_DATA[20] = ptr[FCL_IDX + 20]; //LlColour G
            FCL_DATA[21] = ptr[FCL_IDX + 21]; //LlColour B
            FCL_DATA[22] = ptr[FCL_IDX + 22]; //Draw Highlight
            FCL_DATA[23] = ptr[FCL_IDX + 23]; //HandleL
            FCL_DATA[24] = ptr[FCL_IDX + 24]; //HandleH

          #endif

          FCL_COLOURS[0] = FCL_DATA[10];
          FCL_COLOURS[1] = FCL_DATA[11];
          FCL_COLOURS[2] = FCL_DATA[12];
          FCL_COLOURS[3] = FCL_DATA[13];
          FCL_COLOURS[4] = FCL_DATA[14];
          FCL_COLOURS[5] = FCL_DATA[15];
          FCL_COLOURS[6] = FCL_DATA[16];
          FCL_COLOURS[7] = FCL_DATA[17];
          FCL_COLOURS[8] = FCL_DATA[18];
          FCL_COLOURS[9] = FCL_DATA[19];
          FCL_COLOURS[10] = FCL_DATA[20];
          FCL_COLOURS[11] = FCL_DATA[21];

          if (FCV_0a401_DisplayManager1__NUMWIDGETS < 20)
          {          

            FCV_0a401_DisplayManager1__WIDGETHANDLES[FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_DATA[23] + (FCL_DATA[24] << 8);

          // } else {

          }

          FCL_LASTID = FCD_0a401_DisplayManager1__CreateWidget(FCL_DATA[0], FCL_DATA[1] + (FCL_DATA[2] << 8), FCL_DATA[3] + (FCL_DATA[4] << 8), FCL_DATA[5] + (FCL_DATA[6] << 8), FCL_DATA[7] + (FCL_DATA[8] << 8), FCL_DATA[9], FCL_COLOURS, 12, FCL_DATA[22], 1);

          FCL_IDX = FCL_IDX + 25;

        // } else {

        }

        if (FCL_DATA[0] == 'B')
        {        

          #if (0) // 0 == 1
          //Code has been optimised out by the pre-processor
          #else
            // Code
            FCL_DATA[0] = ptr[FCL_IDX + 0];    //Type Object / Widget
            FCL_DATA[1] = ptr[FCL_IDX + 1];    //Scaling Native / Stretch 
            FCL_DATA[2] = ptr[FCL_IDX + 2];    //XL
            FCL_DATA[3] = ptr[FCL_IDX + 3];    //XH
            FCL_DATA[4] = ptr[FCL_IDX + 4];    //YL
            FCL_DATA[5] = ptr[FCL_IDX + 5];    //YH
            FCL_DATA[6] = ptr[FCL_IDX + 6];    //WidthL
            FCL_DATA[7] = ptr[FCL_IDX + 7];    //WidthH
            FCL_DATA[8] = ptr[FCL_IDX + 8];    //HeightL
            FCL_DATA[9] = ptr[FCL_IDX + 9];    //HeightH
            FCL_DATA[10] = ptr[FCL_IDX + 10];  //Use Transparency
            FCL_DATA[11] = ptr[FCL_IDX + 11];  //Transparency R
            FCL_DATA[12] = ptr[FCL_IDX + 12];  //Transparency G
            FCL_DATA[13] = ptr[FCL_IDX + 13];  //Transparency B
            FCL_DATA[14] = ptr[FCL_IDX + 14];  //Text R
            FCL_DATA[15] = ptr[FCL_IDX + 15];  //Text G
            FCL_DATA[16] = ptr[FCL_IDX + 16];  //Text B
            FCL_DATA[17] = ptr[FCL_IDX + 17];  //Handle L
            FCL_DATA[18] = ptr[FCL_IDX + 18];  //Handle H

          #endif

          FCL_IDX = FCL_IDX + 19;

          #if (0) // 0 == 1
          //Code has been optimised out by the pre-processor
          #else
            // Code
            FCL_STRIDX = 0;
            while (ptr[FCL_IDX] > 0)
            {
                FCL_STR[FCL_STRIDX++] = ptr[FCL_IDX++];
            }
            FCL_STR[FCL_STRIDX++] = ptr[FCL_IDX++];

          #endif

          FCI_SCOPY(FCL_STR,FCLsz_STR, FCV_0a401_DisplayManager1__BITMAPFILENAME,FCVsz_0a401_DisplayManager1__BITMAPFILENAME);

          FCL_COLOURS[0] = FCL_DATA[1];
          FCL_COLOURS[1] = FCL_DATA[10];
          FCL_COLOURS[2] = 0;
          FCL_COLOURS[3] = FCL_DATA[11];
          FCL_COLOURS[4] = FCL_DATA[12];
          FCL_COLOURS[5] = FCL_DATA[13];
          FCL_COLOURS[6] = FCL_DATA[14];
          FCL_COLOURS[7] = FCL_DATA[15];
          FCL_COLOURS[8] = FCL_DATA[16];
          FCL_COLOURS[9] = 0;
          FCL_COLOURS[10] = 0;
          FCL_COLOURS[11] = 0;

          if (FCL_DATA[0])
          {          

            if (FCV_0a401_DisplayManager1__NUMWIDGETS < 20)
            {            

              FCV_0a401_DisplayManager1__WIDGETHANDLES[FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_DATA[17] + (FCL_DATA[18] << 8);

            // } else {

            }

            FCL_LASTID = FCD_0a401_DisplayManager1__CreateWidget(8, FCL_DATA[2] + (FCL_DATA[3] << 8), FCL_DATA[4] + (FCL_DATA[5] << 8), FCL_DATA[6] + (FCL_DATA[7] << 8), FCL_DATA[8] + (FCL_DATA[9] << 8), 0, FCL_COLOURS, 12, 0, 1);

          } else {

            FCL_LASTID = FCD_0a401_DisplayManager1__CreateObject(8, FCL_DATA[2] + (FCL_DATA[3] << 8), FCL_DATA[4] + (FCL_DATA[5] << 8), FCL_DATA[6] + (FCL_DATA[7] << 8), FCL_DATA[8] + (FCL_DATA[9] << 8), 0, FCL_COLOURS, 12, 1);

          }

        // } else {

        }

        if (FCL_DATA[0] == 'S')
        {        

          #if (0) // 0 == 1
          //Code has been optimised out by the pre-processor
          #else
            // Code
            FCL_DATA[0] = ptr[FCL_IDX + 0];  //Font Index
            FCL_DATA[1] = ptr[FCL_IDX + 1];  //HAlign
            FCL_DATA[2] = ptr[FCL_IDX + 2];  //VAlign

          #endif

          FCL_IDX = FCL_IDX + 3;

          #if (0) // 0 == 1
          //Code has been optimised out by the pre-processor
          #else
            // Code
            FCL_STRIDX = 0;
            while (ptr[FCL_IDX] > 0)
            {
                FCL_STR[FCL_STRIDX++] = ptr[FCL_IDX++];
            }
            FCL_STR[FCL_STRIDX++] = ptr[FCL_IDX++];

          #endif

          FCD_0a401_DisplayManager1__SetTextLabel(FCL_LASTID, FCL_STR, FCLsz_STR, FCL_DATA[0], FCL_DATA[1], FCL_DATA[2], 1);

        // } else {

        }

      }

      #if (0) // 1 && 0
      //Code has been optimised out by the pre-processor
      // #else
      #endif

    // } else {

    }

    FCV_0a401_DisplayManager1__SENDINGSCENE = 0;

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  //Local variable definitions
  #undef FCLsz_DATA
  #undef FCLsz_STR
  #undef FCLsz_COLOURS
}

/*=----------------------------------------------------------------------=*\
   Use :Define an interactive Widget or slider.
       :Returns the Widget ID.
       :
       :Parameters for macro CreateWidget:
       :  WidgetType : 0=WidgetHidden, 1=WidgetRect, 2=WidgetRoundedRect, 3=WidgetEllipse, 4=VSlider, 5=HSlider, 6=VSliderRound, 7=HSliderRound, 8=Bitmap
       :  X : X Pixel Coordinate
       :  Y : Y Pixel Coordinate
       :  Width : Pixel Width or X Radius
       :  Height : Pixel Height or Y Radius
       :  LineWidth : Number of pixels thick to draw outer border lines
       :  Colours[12] : Byte array containing FgColour RGB [0-2], Bg Colour RGB [3-5], Text Colour RGB [6-8], Hl Colour RGB [9-11]
       :  DrawHighlight : Draws the highlight on buttons, also used for thumb width on sliders
       :  DrawWidget : 0=Do not draw Widget yet, 1=Draw Widget now  (Does not apply to hidden widgets)
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0a401_DisplayManager1__CreateWidget(MX_UINT8 FCL_WIDGETTYPE, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_LINEWIDTH, MX_UINT8 *FCL_COLOURS, MX_UINT16 FCLsz_COLOURS, MX_UINT8 FCL_DRAWHIGHLIGHT, MX_BOOL FCL_DRAWWIDGET)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCV_0a401_DisplayManager1__NUMWIDGETS < 20)
  {  

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    FCV_0a401_DisplayManager1__TYPE[20 + FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_WIDGETTYPE;
    FCV_0a401_DisplayManager1__X[20 + FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_X;
    FCV_0a401_DisplayManager1__Y[20 + FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_Y;
    FCV_0a401_DisplayManager1__W[20 + FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_WIDTH;
    FCV_0a401_DisplayManager1__H[20 + FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_HEIGHT;
    FCV_0a401_DisplayManager1__LINEWIDTH[20 + FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_LINEWIDTH;
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][0][0] = FCL_COLOURS[0];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][0][1] = FCL_COLOURS[1];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][0][2] = FCL_COLOURS[2];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][1][0] = FCL_COLOURS[3];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][1][1] = FCL_COLOURS[4];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][1][2] = FCL_COLOURS[5];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][2][0] = FCL_COLOURS[6];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][2][1] = FCL_COLOURS[7];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][2][2] = FCL_COLOURS[8];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][3][0] = FCL_COLOURS[9];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][3][1] = FCL_COLOURS[10];
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCV_0a401_DisplayManager1__NUMWIDGETS][3][2] = FCL_COLOURS[11];
    FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCV_0a401_DisplayManager1__NUMWIDGETS] = FCL_DRAWHIGHLIGHT;
    FCV_0a401_DisplayManager1__VALUE[FCV_0a401_DisplayManager1__NUMWIDGETS] = 0.0;
    FCV_0a401_DisplayManager1__OLDVALUE[FCV_0a401_DisplayManager1__NUMWIDGETS] = 2.0;

    FCV_0a401_DisplayManager1__NUMWIDGETS = FCV_0a401_DisplayManager1__NUMWIDGETS + 1;

    FCR_RETVAL = 20 + FCV_0a401_DisplayManager1__NUMWIDGETS;

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if (FCL_DRAWWIDGET)
    {    

      FCD_0a401_DisplayManager1__DrawItem(FCR_RETVAL);

    // } else {

    }

  } else {

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Changes the theme index of the selected Object or Widget.
       :
       :Parameters for macro ModifyColour:
       :  ID : Unique ID of the object or Widget
       :  Index : 0=Foreground, 1=Background, 2=TextColour, 3=Highlight(Widgets Only)
       :  R : Colour Channels
       :  G : Colour Channels
       :  B : Colour Channels
       :  Redraw : Redraws the component straight away in the new colours
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__ModifyColour(MX_UINT16 FCL_ID, MX_UINT8 FCL_INDEX, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B, MX_BOOL FCL_REDRAW)
{
  //Local variable definitions
  #define FCLsz_MQTT_STR 30
  MX_CHAR FCL_MQTT_STR[FCLsz_MQTT_STR] = "";


  if (FCL_ID > 0)
  {  

    FCL_ID = FCL_ID - 1;

    if (FCL_ID < FCV_0a401_DisplayManager1__NUMOBJECTS)
    {    

      if (FCL_INDEX < 3)
      {      

        FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][FCL_INDEX][0] = FCL_R;
        FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][FCL_INDEX][1] = FCL_G;
        FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][FCL_INDEX][2] = FCL_B;

      // } else {

      }

    // } else {

    }

    if ((FCL_ID >= 20) && (FCL_ID < (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
    {    

      if (FCL_INDEX < 4)
      {      

        FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][FCL_INDEX][0] = FCL_R;
        FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][FCL_INDEX][1] = FCL_G;
        FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][FCL_INDEX][2] = FCL_B;

      // } else {

      }

    // } else {

    }

    if (FCL_REDRAW)
    {    

      FCD_0a401_DisplayManager1__DrawItem(FCL_ID + 1);

    // } else {

    }

    #if (0) // 1 && 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // } else {

  }

  //Local variable definitions
  #undef FCLsz_MQTT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Reads the value of one of the sliders ranging between 0 and 1.
       :
       :Parameters for macro GetSliderValue:
       :  WidgetID : MX_UINT16
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_0a401_DisplayManager1__GetSliderValue(MX_UINT16 FCL_WIDGETID)
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_WIDGETID > 0)
  {  

    FCL_WIDGETID = FCL_WIDGETID - 1;

    if ((FCL_WIDGETID >= 20) && (FCL_WIDGETID < (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
    {    

      FCR_RETVAL = FCV_0a401_DisplayManager1__VALUE[FCL_WIDGETID - 20];

    // } else {

    }

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Uses the X and Y coordinates from a touch sensor to check for Widget presses.
       :Returns 0 for no Widgets pressed. Returns ID for a valid Widget press.
       :Any touched slider Widgets will automatically move their thumb and value to the touch position.
       :
       :Parameters for macro CheckForTouch:
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0a401_DisplayManager1__CheckForTouch(MX_UINT16 FCL_X, MX_UINT16 FCL_Y)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_ID;
  MX_SINT16 FCL_COORD;
  MX_UINT16 FCL_WHANDLE = (0x0);
  MX_FLOAT FCL_FVAL = (0.0);
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  for (FCL_IDX=0; (FCL_IDX)<(FCV_0a401_DisplayManager1__NUMWIDGETS); (FCL_IDX)++)
  {
    FCL_ID = FCL_IDX + 20;

    if ((FCL_X >= FCV_0a401_DisplayManager1__X[FCL_ID]) && (FCL_X <= (FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID])))
    {    

      if ((FCL_Y >= FCV_0a401_DisplayManager1__Y[FCL_ID]) && (FCL_Y <= (FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID])))
      {      

        if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] < 4)
        {        

          if (FCV_0a401_DisplayManager1__TOUCHINTERVAL == 0)
          {          

            FCV_0a401_DisplayManager1__LASTWIDGETPRESS = FCL_ID + 1;
            FCR_RETVAL = FCV_0a401_DisplayManager1__LASTWIDGETPRESS;
            FCV_0a401_DisplayManager1__TOUCHINTERVAL = 10;

            #if (0)
            //Code has been optimised out by the pre-processor
            // #else
            #endif

          } else {

            FCV_0a401_DisplayManager1__TOUCHINTERVAL = FCV_0a401_DisplayManager1__TOUCHINTERVAL - 1;

            FCR_RETVAL = 0;

            goto FCC_CheckForTouch_A;

          }

        } else {

          FCV_0a401_DisplayManager1__LASTWIDGETPRESS = FCL_ID + 1;
          FCR_RETVAL = FCV_0a401_DisplayManager1__LASTWIDGETPRESS;
          FCV_0a401_DisplayManager1__TOUCHINTERVAL = 0;

          #if (0)
          //Code has been optimised out by the pre-processor
          // #else
          #endif

        }

        if ((FCV_0a401_DisplayManager1__TYPE[FCL_ID] == 4) || (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == 6))
        {        

          FCL_COORD = FCL_Y - FCV_0a401_DisplayManager1__Y[FCL_ID] - (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1);

          FCL_FVAL = flt_div(flt_fromi(FCL_COORD), flt_fromi((FCV_0a401_DisplayManager1__H[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])));
          FCL_FVAL = flt_sub(1.0, FCL_FVAL);

          FCD_0a401_DisplayManager1__SetSliderValue(FCL_ID + 1, FCL_FVAL, 1);

        // } else {

        }

        if ((FCV_0a401_DisplayManager1__TYPE[FCL_ID] == 5) || (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == 7))
        {        

          FCL_COORD = FCL_X - FCV_0a401_DisplayManager1__X[FCL_ID] - (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1);

          FCL_FVAL = flt_div(flt_fromi(FCL_COORD), flt_fromi((FCV_0a401_DisplayManager1__W[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])));

          FCD_0a401_DisplayManager1__SetSliderValue(FCL_ID + 1, FCL_FVAL, 1);

        // } else {

        }

        goto FCC_CheckForTouch_A;

      // } else {

      }

    // } else {

    }

  }

FCC_CheckForTouch_A:
  ;

  if (FCR_RETVAL)
  {  

    #if (1)
      #if (0)
      //Code has been optimised out by the pre-processor
      #else
        //Comment:
        //Check for embedded callback

        FCL_ID = FCR_RETVAL - (20 + 1);

        FCL_WHANDLE = FCV_0a401_DisplayManager1__WIDGETHANDLES[FCL_ID];

        if (FCV_0a401_DisplayManager1__SCENEIDX == 0)
        {        

          // Code
          DC_CB_Func0[FCL_ID](FCL_WHANDLE);

        } else {

          #if (1) // 2 > 1
            if (FCV_0a401_DisplayManager1__SCENEIDX == 1)
            {            

              // Code
              DC_CB_Func1[FCL_ID](FCL_WHANDLE);

            } else {

              #if (0) // 2 > 2
              //Code has been optimised out by the pre-processor
              // #else
              #endif

            }

          // #else
          //Code has been optimised out by the pre-processor
          #endif

        }

      #endif

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Creates a text field consisting of a rectangular border containing a single line of text
       :
       :Parameters for macro CreateTextField:
       :  Text[20] : Text string to set as the label
       :  X : X Pixel Coordinate
       :  Y : Y Pixel Coordinate
       :  Width : Pixel Width
       :  Height : Pixel Height
       :  Font : GLCD Font Index to use
       :  Colours[9] : Byte array containing FgColour RGB [0-2], Bg Colour RGB [3-5], Text Colour RGB [6-8]
       :  HAlignment : 0=Left, 1=Center, 2=Right
       :  VAlignment : 0=Top, 1=Middle, 2=Bottom
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0a401_DisplayManager1__CreateTextField(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_FONT, MX_UINT8 *FCL_COLOURS, MX_UINT16 FCLsz_COLOURS, MX_UINT8 FCL_HALIGNMENT, MX_UINT8 FCL_VALIGNMENT)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = FCD_0a401_DisplayManager1__CreateObject(0, FCL_X, FCL_Y, FCL_WIDTH, FCL_HEIGHT, 0, FCL_COLOURS, 9, 0);

  FCD_0a401_DisplayManager1__SetTextLabel(FCR_RETVAL, FCL_TEXT, FCLsz_TEXT, FCL_FONT, FCL_HALIGNMENT, FCL_VALIGNMENT, 1);

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Changes the width and height of the selected Object or Widget.
       :
       :Parameters for macro ModifyScale:
       :  ID : Unique ID of the object or Widget
       :  Width : MX_UINT16
       :  Height : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__ModifyScale(MX_UINT16 FCL_ID, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT)
{
  //Local variable definitions
  #define FCLsz_MQTT_STR 30
  MX_CHAR FCL_MQTT_STR[FCLsz_MQTT_STR] = "";


  if (FCL_ID > 0)
  {  

    FCL_ID = FCL_ID - 1;

    if (FCL_ID < FCV_0a401_DisplayManager1__NUMOBJECTS)
    {    

      FCV_0a401_DisplayManager1__W[FCL_ID] = FCL_WIDTH;
      FCV_0a401_DisplayManager1__H[FCL_ID] = FCL_HEIGHT;

    // } else {

    }

    if ((FCL_ID >= 20) && (FCL_ID < (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
    {    

      FCV_0a401_DisplayManager1__W[FCL_ID] = FCL_WIDTH;
      FCV_0a401_DisplayManager1__H[FCL_ID] = FCL_HEIGHT;

    // } else {

    }

    #if (0) // 1 && 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // } else {

  }

  //Local variable definitions
  #undef FCLsz_MQTT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a single object or Widget onto the display without clearing the display.
       :Doesn't draw text, this is done using the SetText macros.
       :
       :Parameters for macro DrawItem:
       :  ID : Unique ID of the Object or Widget
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__DrawItem(MX_UINT16 FCL_ID)
{
  //Local variable definitions
  MX_UINT16 FCL_PIXELWIDTH = (0x0);
  MX_UINT16 FCL_PIXELHEIGHT = (0x0);
  MX_UINT16 FCL_DIFFERENCE;
  MX_SINT16 FCL_IDX = (0);


  //Comment:
  //TODO - Line width needs adding for Widget Ellipse
  // - Also needs adding for Object Line

  if ((FCL_ID > 0) && (FCL_ID <= FCV_0a401_DisplayManager1__NUMOBJECTS))
  {  

    FCL_ID = FCL_ID - 1;

    #if (1) // 0 == 0
      FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][2]);

      FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][2]);

    #else
    //Code has been optimised out by the pre-processor
    #endif

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__OBJECT_HIDDEN)
    {    

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__OBJECT_RECTANGLE)
    {    

      FCL_IDX = 0;

      if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] == 0)
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][2]);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      } else {

        if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] > 1)
        {        

          FCL_IDX = 0 - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          for (FCLV_LOOP6=0; (FCLV_LOOP6)<(FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] - 1); (FCLV_LOOP6)++)
          {
            #if (1) // 0 == 0
              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, 1, 0);

            #else
            //Code has been optimised out by the pre-processor
            #endif

            FCL_IDX = FCL_IDX + 1;

          }

        // } else {

        }

      }

      #if (1) // 0 == 0
        FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, 0, 0);

      #else
      //Code has been optimised out by the pre-processor
      #endif

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__OBJECT_ROUNDEDRECTANGLE)
    {    

      FCL_IDX = 0;

      if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] == 0)
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][2]);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      } else {

        if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] > 1)
        {        

          FCL_IDX = 0 - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          for (FCLV_LOOP7=0; (FCLV_LOOP7)<(FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] - 1); (FCLV_LOOP7)++)
          {
            #if (1) // 0 == 0
              FCD_029f1_gLCD_EB3__DrawRoundedRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 2, 1, 0);

            #else
            //Code has been optimised out by the pre-processor
            #endif

            FCL_IDX = FCL_IDX + 1;

          }

        // } else {

        }

      }

      #if (1) // 0 == 0
        FCD_029f1_gLCD_EB3__DrawRoundedRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 2, 0, 0);

      #else
      //Code has been optimised out by the pre-processor
      #endif

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__OBJECT_ELLIPSE)
    {    

      FCL_IDX = 0;

      if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] == 0)
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][2]);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      } else {

        if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] > 1)
        {        

          FCL_IDX = 0 - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          for (FCLV_LOOP8=0; (FCLV_LOOP8)<(FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] - 1); (FCLV_LOOP8)++)
          {
            #if (1) // 0 == 0
              FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX) >> 1, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 1, 1, 0);

            #else
            //Code has been optimised out by the pre-processor
            #endif

            FCL_IDX = FCL_IDX + 1;

          }

        // } else {

        }

      }

      #if (1) // 0 == 0
        FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX) >> 1, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 1, 0, 0);

      #else
      //Code has been optimised out by the pre-processor
      #endif

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__OBJECT_LINE)
    {    

      FCL_IDX = 0 - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

      for (FCLV_LOOP9=0; (FCLV_LOOP9)<(FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID]); (FCLV_LOOP9)++)
      {
        if ((FCV_0a401_DisplayManager1__H[FCL_ID] == 0) || (FCV_0a401_DisplayManager1__W[FCL_ID] > FCV_0a401_DisplayManager1__H[FCL_ID]))
        {        

          #if (1) // 0 == 0
            FCD_029f1_gLCD_EB3__DrawLine(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + FCL_IDX);

          #else
          //Code has been optimised out by the pre-processor
          #endif

        } else {

          #if (1) // 0 == 0
            FCD_029f1_gLCD_EB3__DrawLine(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID]);

          #else
          //Code has been optimised out by the pre-processor
          #endif

        }

        FCL_IDX = FCL_IDX + 1;

      }

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__OBJECT_BITMAP)
    {    

      #if (1)
        FCD_029f1_gLCD_EB3__SetBitmapTransparency(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][2]);

        if (FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][0])
        {        

          FCD_029f1_gLCD_EB3__DrawBitmapScaled(FCV_0a401_DisplayManager1__BITMAPFILENAME, FCVsz_0a401_DisplayManager1__BITMAPFILENAME, FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__H[FCL_ID], 0, FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][1], 0);

        } else {

          FCD_029f1_gLCD_EB3__DrawBitmap(FCV_0a401_DisplayManager1__BITMAPFILENAME, FCVsz_0a401_DisplayManager1__BITMAPFILENAME, FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID], 0, FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][1], 0);

        }

      #else
      //Code has been optimised out by the pre-processor
      #endif

    // } else {

    }

  // } else {

  }

  if ((FCL_ID > 20) && (FCL_ID <= (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
  {  

    FCL_ID = FCL_ID - 1;

    #if (1) // 0 == 0
      FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

      FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

    #else
    //Code has been optimised out by the pre-processor
    #endif

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_HIDDEN)
    {    

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_RECTANGULAR)
    {    

      FCL_IDX = 0;

      if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] == 0)
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][2]);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      } else {

        if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] > 1)
        {        

          FCL_IDX = 0 - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          for (FCLV_LOOP10=0; (FCLV_LOOP10)<(FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] - 1); (FCLV_LOOP10)++)
          {
            #if (1) // 0 == 0
              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, 1, 0);

            #else
            //Code has been optimised out by the pre-processor
            #endif

            FCL_IDX = FCL_IDX + 1;

          }

        // } else {

        }

      }

      #if (1) // 0 == 0
        FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, 0, 0);

      #else
      //Code has been optimised out by the pre-processor
      #endif

      if (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][2]);

          FCL_IDX = (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          FCD_029f1_gLCD_EB3__DrawLine(FCV_0a401_DisplayManager1__X[FCL_ID] + 1 - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 1 + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 1 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 1 + FCL_IDX);

          FCD_029f1_gLCD_EB3__DrawLine(FCV_0a401_DisplayManager1__X[FCL_ID] + 2 - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 2 + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 2 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 2 + FCL_IDX);

          FCD_029f1_gLCD_EB3__DrawLine(FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 1 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + 1 - FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 1 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 1 + FCL_IDX);

          FCD_029f1_gLCD_EB3__DrawLine(FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 2 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + 2 - FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 2 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 2 + FCL_IDX);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      // } else {

      }

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_ROUNDEDRECTANGLE)
    {    

      if (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][2]);

          FCL_IDX = (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          FCD_029f1_gLCD_EB3__DrawRoundedRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + 1 - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + 1 - FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 1 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 1 + FCL_IDX, (FCV_0a401_DisplayManager1__H[FCL_ID] + FCL_IDX) >> 2, 1, 0);

          FCD_029f1_gLCD_EB3__DrawRoundedRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + 2 - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + 2 - FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] + 2 + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] + 2 + FCL_IDX, (FCV_0a401_DisplayManager1__H[FCL_ID] + FCL_IDX) >> 2, 1, 0);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      // } else {

      }

      FCL_IDX = 0;

      if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] == 0)
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][2]);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      } else {

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][0][2]);

        #else
        //Code has been optimised out by the pre-processor
        #endif

        if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] > 1)
        {        

          FCL_IDX = 0 - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          for (FCLV_LOOP11=0; (FCLV_LOOP11)<(FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] - 1); (FCLV_LOOP11)++)
          {
            #if (1) // 0 == 0
              FCD_029f1_gLCD_EB3__DrawRoundedRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 2, 1, 0);

            #else
            //Code has been optimised out by the pre-processor
            #endif

            FCL_IDX = FCL_IDX + 1;

          }

        // } else {

        }

      }

      #if (1) // 0 == 0
        FCD_029f1_gLCD_EB3__DrawRoundedRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_IDX, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 2, 0, 0);

      #else
      //Code has been optimised out by the pre-processor
      #endif

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_ELLIPSE)
    {    

      if (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][3][2]);

          FCL_IDX = (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + 2, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + 2, ((FCV_0a401_DisplayManager1__W[FCL_ID] + FCL_IDX) >> 1), ((FCV_0a401_DisplayManager1__H[FCL_ID] + FCL_IDX) >> 1), 0, 1);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      // } else {

      }

      FCL_IDX = 0;

      if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] == 0)
      {      

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][2]);

        #else
        //Code has been optimised out by the pre-processor
        #endif

      } else {

        if (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] > 1)
        {        

          FCL_IDX = 0 - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1);

          for (FCLV_LOOP12=0; (FCLV_LOOP12)<(FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] - 1); (FCLV_LOOP12)++)
          {
            #if (1) // 0 == 0
              FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX) >> 1, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 1, 1, 0);

            #else
            //Code has been optimised out by the pre-processor
            #endif

            FCL_IDX = FCL_IDX + 1;

          }

        // } else {

        }

      }

      #if (1) // 0 == 0
        FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_IDX) >> 1, (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_IDX) >> 1, 0, 0);

      #else
      //Code has been optimised out by the pre-processor
      #endif

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_VSLIDER)
    {    

      if (!flt_eq(FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20], FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20]))
      {      

        FCL_PIXELHEIGHT = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__H[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), (flt_sub(1.0, FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20]))));

        FCL_PIXELWIDTH = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__H[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), (flt_sub(1.0, FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20]))));

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          if (flt_gt(FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20], 1.0))
          {          

            //Comment:
            //First Redraw

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 0);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT) + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20]), 0, 1);

          } else {

            if (FCL_PIXELHEIGHT > FCL_PIXELWIDTH)
            {            

              FCL_DIFFERENCE = FCL_PIXELHEIGHT - FCL_PIXELWIDTH;

            } else {

              FCL_DIFFERENCE = FCL_PIXELWIDTH - FCL_PIXELHEIGHT;

            }

            if (FCL_DIFFERENCE >= FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])
            {            

              //Comment:
              //Full Thumb Clear and Redraw

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH) + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20]), 0, 1);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH) + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20]), 0, 1);

              if (FCL_PIXELHEIGHT > FCL_PIXELWIDTH)
              {              

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT, 0, 1);

              } else {

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT) + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20]), FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

              }

              FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT) + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20]), 0, 1);

            } else {

              if (FCL_PIXELHEIGHT > FCL_PIXELWIDTH)
              {              

                //Comment:
                //Partial Shift Up

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH) + FCL_DIFFERENCE), 0, 1);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH) + FCL_DIFFERENCE), 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + FCL_DIFFERENCE, 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE), FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT) + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20]), 0, 1);

              } else {

                //Comment:
                //Partial Shift Down

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE, 0, 1);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE, FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], ((FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELHEIGHT) + FCL_DIFFERENCE), 0, 1);

              }

            }

          }

        #else
        //Code has been optimised out by the pre-processor
        #endif

        FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20] = FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20];

      // } else {

      }

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_HSLIDER)
    {    

      if (!flt_eq(FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20], FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20]))
      {      

        FCL_PIXELWIDTH = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__W[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20]));

        FCL_PIXELHEIGHT = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__W[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20]));

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          if (flt_gt(FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20], 1.0))
          {          

            //Comment:
            //First Redraw

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 0);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

          } else {

            if (FCL_PIXELWIDTH > FCL_PIXELHEIGHT)
            {            

              FCL_DIFFERENCE = FCL_PIXELWIDTH - FCL_PIXELHEIGHT;

            } else {

              FCL_DIFFERENCE = FCL_PIXELHEIGHT - FCL_PIXELWIDTH;

            }

            if (FCL_DIFFERENCE >= FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])
            {            

              //Comment:
              //Full Thumb Clear and Redraw

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

              if (FCL_PIXELWIDTH > FCL_PIXELHEIGHT)
              {              

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

              } else {

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

              }

              FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

            } else {

              if (FCL_PIXELWIDTH > FCL_PIXELHEIGHT)
              {              

                //Comment:
                //Partial Shift Right

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCL_DIFFERENCE, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCL_DIFFERENCE, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCL_DIFFERENCE, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE), FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

              } else {

                //Comment:
                //Partial Shift Left

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] - FCL_DIFFERENCE, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELHEIGHT + FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

                FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

                FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + FCL_DIFFERENCE, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

              }

            }

          }

        #else
        //Code has been optimised out by the pre-processor
        #endif

        FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20] = FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20];

      // } else {

      }

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_VSLIDER_ROUND)
    {    

      if (!flt_eq(FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20], FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20]))
      {      

        FCL_PIXELWIDTH = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__H[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), flt_sub(1.0, FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20])));

        FCL_PIXELHEIGHT = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__H[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), flt_sub(1.0, FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20])));

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          if (flt_gt(FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20], 1.0))
          {          

            //Comment:
            //First Redraw

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

            FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__W[FCL_ID] >> 1, (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__W[FCL_ID] >> 1, (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

            FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1) + FCL_PIXELWIDTH, (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1, 0, 1);

          } else {

            //Comment:
            //Full Thumb Clear and Redraw

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1) + FCL_PIXELHEIGHT, (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1, 0, 1);

            if (FCL_PIXELWIDTH > FCL_PIXELHEIGHT)
            {            

              FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

              FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), 0, 1);

            } else {

              FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][2]);

              FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_PIXELWIDTH + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID] - (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), 0, 1);

            }

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1) + FCL_PIXELWIDTH, (FCV_0a401_DisplayManager1__W[FCL_ID] >> 1), FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1, 0, 1);

          }

        #else
        //Code has been optimised out by the pre-processor
        #endif

        FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20] = FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20];

      // } else {

      }

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_HSLIDER_ROUND)
    {    

      if (!flt_eq(FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20], FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20]))
      {      

        FCL_PIXELWIDTH = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__W[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20]));

        FCL_PIXELHEIGHT = flt_toi(flt_mul(flt_fromi((FCV_0a401_DisplayManager1__W[FCL_ID] - FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20])), FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20]));

        #if (1) // 0 == 0
          FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

          if (flt_gt(FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20], 1.0))
          {          

            //Comment:
            //First Redraw

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

            FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][1][2]);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + FCV_0a401_DisplayManager1__H[FCL_ID], 0, 1);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__H[FCL_ID] >> 1, 0, 1);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__H[FCL_ID] >> 1, 0, 1);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

            FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1) + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1, (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), 0, 1);

          } else {

            //Comment:
            //Full Thumb Clear and Redraw

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1) + FCL_PIXELHEIGHT, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1, (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), 0, 1);

            if (FCL_PIXELWIDTH > FCL_PIXELHEIGHT)
            {            

              FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][2][2]);

              FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            } else {

              FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][3][2]);

              FCD_029f1_gLCD_EB3__DrawCircle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

              FCD_029f1_gLCD_EB3__DrawRectangle(FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_PIXELWIDTH + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) - (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), FCV_0a401_DisplayManager1__X[FCL_ID] + FCV_0a401_DisplayManager1__W[FCL_ID] - (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1) + (FCV_0a401_DisplayManager1__LINEWIDTH[FCL_ID] >> 1), 0, 1);

            }

            FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][2]);

            FCD_029f1_gLCD_EB3__DrawEllipse(FCV_0a401_DisplayManager1__X[FCL_ID] + (FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1) + FCL_PIXELWIDTH, FCV_0a401_DisplayManager1__Y[FCL_ID] + (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), FCV_0a401_DisplayManager1__DRAWHIGHLIGHT[FCL_ID - 20] >> 1, (FCV_0a401_DisplayManager1__H[FCL_ID] >> 1), 0, 1);

          }

        #else
        //Code has been optimised out by the pre-processor
        #endif

        FCV_0a401_DisplayManager1__OLDVALUE[FCL_ID - 20] = FCV_0a401_DisplayManager1__VALUE[FCL_ID - 20];

      // } else {

      }

    // } else {

    }

    if (FCV_0a401_DisplayManager1__TYPE[FCL_ID] == FCV_0a401_DisplayManager1__WIDGET_BITMAP)
    {    

      #if (1)
        FCD_029f1_gLCD_EB3__SetBitmapTransparency(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][2]);

        if (FCV_0a401_DisplayManager1__WIDGETCOLOUR[(FCL_ID - 20)][0][0])
        {        

          FCD_029f1_gLCD_EB3__DrawBitmapScaled(FCV_0a401_DisplayManager1__BITMAPFILENAME, FCVsz_0a401_DisplayManager1__BITMAPFILENAME, FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID], FCV_0a401_DisplayManager1__W[FCL_ID], FCV_0a401_DisplayManager1__H[FCL_ID], 0, FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][0][1], 0);

        } else {

          FCD_029f1_gLCD_EB3__DrawBitmap(FCV_0a401_DisplayManager1__BITMAPFILENAME, FCVsz_0a401_DisplayManager1__BITMAPFILENAME, FCV_0a401_DisplayManager1__X[FCL_ID], FCV_0a401_DisplayManager1__Y[FCL_ID], 0, FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][0][1], 0);

        }

      #else
      //Code has been optimised out by the pre-processor
      #endif

    // } else {

    }

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a single line of text onto an object or Widget location.
       :Useful for labelling Widgets such as buttons or having name, value statistics.
       :Drawn using the object themes.
       :
       :Parameters for macro SetTextLabel:
       :  ID : Unique identifier of object or Widget.
       :  Text[20] : Text string to set as the label
       :  Font : GLCD Font Index to use
       :  HAlignment : 0=Left, 1=Center, 2=Right
       :  VAlignment : 0=Top, 1=Middle, 2=Bottom
       :  Transparent : 0=Background Colour Drawn, 1=Don't Draw Background Colour
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__SetTextLabel(MX_UINT16 FCL_ID, MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT, MX_UINT8 FCL_FONT, MX_UINT8 FCL_HALIGNMENT, MX_UINT8 FCL_VALIGNMENT, MX_BOOL FCL_TRANSPARENT)
{
  //Local variable definitions
  MX_BOOL FCL_VALIDID = (0);
  MX_UINT8 FCL_PIXELHEIGHT;
  MX_SINT16 FCL_Y = (0);
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_LEN;
  MX_SINT16 FCL_X = (0);
  MX_UINT16 FCL_TEXTPIXELWIDTH;
  MX_BOOL FCL_ISWIDGET = (0);
  #define FCLsz_MQTT_STR 60
  MX_CHAR FCL_MQTT_STR[FCLsz_MQTT_STR] = "";


  if ((FCL_ID > 0) && (FCL_ID <= FCV_0a401_DisplayManager1__NUMOBJECTS))
  {  

    FCL_VALIDID = 1;
    FCL_ISWIDGET = 0;

  } else {

    if ((FCL_ID >= 20) && (FCL_ID <= (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
    {    

      FCL_VALIDID = 1;
      FCL_ISWIDGET = 1;

    // } else {

    }

  }

  if (FCL_VALIDID)
  {  

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    FCD_0a401_DisplayManager1__DrawItem(FCL_ID);

    FCL_ID = FCL_ID - 1;

    #if (1) // 0 == 0
      if (FCL_ISWIDGET)
      {      

        FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][2][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][2][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][2][2]);

        FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][0], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][1], FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][1][2]);

      } else {

        FCD_029f1_gLCD_EB3__SetForegroundColour(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][2][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][2][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][2][2]);

        FCD_029f1_gLCD_EB3__SetBackgroundColour(FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][0], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][1], FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][1][2]);

      }

      if (FCL_HALIGNMENT)
      {      

        FCL_LEN = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);
        FCL_TEXTPIXELWIDTH = 0;

        for (FCL_IDX=0; (FCL_IDX)<(FCL_LEN); (FCL_IDX)++)
        {
          FCL_PIXELHEIGHT = ReadFontWidth(FCL_FONT, FCL_TEXT[FCL_IDX]);

          FCL_TEXTPIXELWIDTH = FCL_TEXTPIXELWIDTH + FCL_PIXELHEIGHT;

          if ((FCL_IDX + 1) < FCL_LEN)
          {          

            FCL_PIXELHEIGHT = ReadFontStat(FCL_FONT, 0);

            FCL_TEXTPIXELWIDTH = FCL_TEXTPIXELWIDTH + FCL_PIXELHEIGHT;

          // } else {

          }

        }

        switch (FCL_HALIGNMENT)
        {
          case 1:
          {

            FCL_X = (FCV_0a401_DisplayManager1__W[FCL_ID] - FCL_TEXTPIXELWIDTH) >> 1;

            break;
          }
          case 2:
          {

            FCL_X = FCV_0a401_DisplayManager1__W[FCL_ID] - (FCL_TEXTPIXELWIDTH + 4);

            break;
          }
          // default:

        }

      } else {

        FCL_X = 4;

      }

      FCL_PIXELHEIGHT = ReadFontStat(FCL_FONT, 1);

      switch (FCL_VALIGNMENT)
      {
        case 1:
        {

          FCL_Y = (FCV_0a401_DisplayManager1__H[FCL_ID] - FCL_PIXELHEIGHT) >> 1;

          break;
        }
        case 2:
        {

          FCL_Y = FCV_0a401_DisplayManager1__H[FCL_ID] - (FCL_PIXELHEIGHT + 4);

          break;
        }
        default:
        {
          FCL_Y = 4;

        }
      }

      FCD_029f1_gLCD_EB3__Print(FCL_TEXT, FCLsz_TEXT, FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_X, FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_Y, FCL_FONT, FCL_TRANSPARENT);

    #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 1 && 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  } else {

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  }

  //Local variable definitions
  #undef FCLsz_MQTT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_FindSceneCompCallback:
       :  ID : MX_UINT16
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0a401_DisplayManager1__Prv_FindSceneCompCallback(MX_UINT16 FCL_ID)
{
  //Local variable definitions
  MX_UINT32 FCL_PANELIDX = (0x0);
  MX_UINT16 FCL_IDTEST = (0x0);
  MX_BOOL FCL_USECALLBACK = (0);
  #define FCLsz_MACROCALL 20
  MX_CHAR FCL_MACROCALL[FCLsz_MACROCALL] = "";
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  // .PanelIdx=::Component.Property.GetValue(this, "Scene" + ToString$(SceneIdx))

  // .Return=::Panel.FindFirstPanelComp(.PanelIdx, 0)

  while (FCR_RETVAL)
  {
    // .IDTest=::Component.Property.GetValue(.Return, "ID")

    if (FCL_ID == FCL_IDTEST)
    {    

      // .UseCallback=::Component.Property.GetValue(.Return, "UseCallback")

      if (FCL_USECALLBACK)
      {      

        // .MacroCall=::Component.Property.GetValue(.Return, "TouchCallback")

        // ::Debug.Print("Calling Macro: " + .MacroCall + "(" + STRING .Return + ")")

        // ::System.Call.CallMacro_H(.MacroCall, .Return)

      // } else {

      }

      goto FCC_Prv_FindSceneCompCallback_A;

    // } else {

    }

    // .Return=::Panel.FindNextPanelComp(.PanelIdx)

  }

FCC_Prv_FindSceneCompCallback_A:
  ;

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_MACROCALL
}

/*=----------------------------------------------------------------------=*\
   Use :Redraws all of the defined Objects and Widgets.
       :Doesn't draw text, this is done using the SetText macros.
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__DrawAll()
{
  //Local variable definitions
  MX_UINT16 FCL_INDEX = (0x0);


  #if (1) // 0 == 0
    FCD_029f1_gLCD_EB3__SetBackgroundColour(16777215, 16777215 >> 8, 16777215 >> 16);

    FCD_029f1_gLCD_EB3__ClearDisplay();

  #else
  //Code has been optimised out by the pre-processor
  #endif

  while (FCL_INDEX <= FCV_0a401_DisplayManager1__NUMOBJECTS)
  {
    FCD_0a401_DisplayManager1__DrawItem(FCL_INDEX + 1);

    FCL_INDEX = FCL_INDEX + 1;

  }

  while (FCL_INDEX <= (FCV_0a401_DisplayManager1__NUMOBJECTS + FCV_0a401_DisplayManager1__NUMWIDGETS))
  {
    FCD_0a401_DisplayManager1__DrawItem(FCL_INDEX + 20);

    FCL_INDEX = FCL_INDEX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the ID of the last Widget that returned a valid press via the CheckForTouch macro.
       :Returns 0  for no valid touch recorded.
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_0a401_DisplayManager1__GetLastTouchID()
{
  //Local variable definitions
  MX_SINT16 FCR_RETVAL;


  if (FCV_0a401_DisplayManager1__LASTWIDGETPRESS >= 0)
  {  

    FCR_RETVAL = FCV_0a401_DisplayManager1__LASTWIDGETPRESS;

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the value of one of the sliders and optionally redraws the slider to reflect the value change.
       :
       :Parameters for macro SetSliderValue:
       :  WidgetID : MX_UINT16
       :  Value : Range: 0 to 1
       :  RedrawSlider : 0=Do not redraw, 1=Redraw
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__SetSliderValue(MX_UINT16 FCL_WIDGETID, MX_FLOAT FCL_VALUE, MX_BOOL FCL_REDRAWSLIDER)
{
  //Local variable definitions
  #define FCLsz_MQTT_STR 30
  MX_CHAR FCL_MQTT_STR[FCLsz_MQTT_STR] = "";


  if (FCL_WIDGETID > 0)
  {  

    FCL_WIDGETID = FCL_WIDGETID - 1;

    if ((FCL_WIDGETID >= 20) && (FCL_WIDGETID < (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
    {    

      if (flt_lt(FCL_VALUE, 0.0))
      {      

        FCL_VALUE = 0.0;

      // } else {

      }

      if (flt_gt(FCL_VALUE, 1.0))
      {      

        FCL_VALUE = 1.0;

      // } else {

      }

      FCV_0a401_DisplayManager1__VALUE[FCL_WIDGETID - 20] = FCL_VALUE;

      if (FCL_REDRAWSLIDER)
      {      

        FCD_0a401_DisplayManager1__DrawItem(FCL_WIDGETID + 1);

        #if (0) // 1 && 0
        //Code has been optimised out by the pre-processor
        // #else
        #endif

      // } else {

      }

    // } else {

    }

  // } else {

  }

  //Local variable definitions
  #undef FCLsz_MQTT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Checks to see if two objects bounding boxes are colliding,
       :Useful when implementing 2D games.
       :
       :Parameters for macro CheckCollision:
       :  ID1 : ID of Object or Widget to check
       :  ID2 : ID of Object or Widget to check
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_0a401_DisplayManager1__CheckCollision(MX_UINT16 FCL_ID1, MX_UINT16 FCL_ID2)
{
  //Local variable definitions
  MX_UINT8 FCL_TEST = (0x0);
  MX_BOOL FCR_RETVAL;


  FCR_RETVAL = 0;

  FCL_ID1 = FCL_ID1 - 1;
  FCL_ID2 = FCL_ID2 - 1;

  if (FCV_0a401_DisplayManager1__X[FCL_ID1] > FCV_0a401_DisplayManager1__X[FCL_ID2])
  {  

    if (FCV_0a401_DisplayManager1__X[FCL_ID1] <= (FCV_0a401_DisplayManager1__X[FCL_ID2] + FCV_0a401_DisplayManager1__W[FCL_ID2]))
    {    

      FCL_TEST = 1;

    // } else {

    }

  } else {

    if (FCV_0a401_DisplayManager1__X[FCL_ID2] <= (FCV_0a401_DisplayManager1__X[FCL_ID1] + FCV_0a401_DisplayManager1__W[FCL_ID1]))
    {    

      FCL_TEST = 1;

    // } else {

    }

  }

  if (FCL_TEST)
  {  

    if (FCV_0a401_DisplayManager1__Y[FCL_ID1] > FCV_0a401_DisplayManager1__Y[FCL_ID2])
    {    

      if (FCV_0a401_DisplayManager1__Y[FCL_ID1] <= (FCV_0a401_DisplayManager1__Y[FCL_ID2] + FCV_0a401_DisplayManager1__H[FCL_ID2]))
      {      

        FCL_TEST = 2;

      // } else {

      }

    } else {

      if (FCV_0a401_DisplayManager1__Y[FCL_ID2] <= (FCV_0a401_DisplayManager1__Y[FCL_ID1] + FCV_0a401_DisplayManager1__H[FCL_ID1]))
      {      

        FCL_TEST = 2;

      // } else {

      }

    }

    if (FCL_TEST == 2)
    {    

      FCR_RETVAL = 1;

    // } else {

    }

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Moves an existing object or Widget to absolute coordinates on the screen.
       :
       :Parameters for macro ModifyPosition:
       :  ID : Unique ID of the object or Widget
       :  X : MX_SINT16
       :  Y : MX_SINT16
       :  Relative : 0=Absolute Positioning, 1=Relative Positioning
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__ModifyPosition(MX_UINT16 FCL_ID, MX_SINT16 FCL_X, MX_SINT16 FCL_Y, MX_BOOL FCL_RELATIVE)
{
  //Local variable definitions
  #define FCLsz_MQTT_STR 30
  MX_CHAR FCL_MQTT_STR[FCLsz_MQTT_STR] = "";


  if (FCL_ID > 0)
  {  

    FCL_ID = FCL_ID - 1;

    if (FCL_ID < FCV_0a401_DisplayManager1__NUMOBJECTS)
    {    

      if (FCL_RELATIVE)
      {      

        FCV_0a401_DisplayManager1__X[FCL_ID] = FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_X;
        FCV_0a401_DisplayManager1__Y[FCL_ID] = FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_Y;

      } else {

        FCV_0a401_DisplayManager1__X[FCL_ID] = FCL_X;
        FCV_0a401_DisplayManager1__Y[FCL_ID] = FCL_Y;

      }

    // } else {

    }

    if ((FCL_ID >= 20) && (FCL_ID < (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
    {    

      if (FCL_RELATIVE)
      {      

        FCV_0a401_DisplayManager1__X[FCL_ID] = FCV_0a401_DisplayManager1__X[FCL_ID] + FCL_X;
        FCV_0a401_DisplayManager1__Y[FCL_ID] = FCV_0a401_DisplayManager1__Y[FCL_ID] + FCL_Y;

      } else {

        FCV_0a401_DisplayManager1__X[FCL_ID] = FCL_X;
        FCV_0a401_DisplayManager1__Y[FCL_ID] = FCL_Y;

      }

    // } else {

    }

    #if (0) // 1 && 0
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // } else {

  }

  //Local variable definitions
  #undef FCLsz_MQTT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Removes all objects and Widgets from memory.
       :Also clears the screen if required.
       :
       :Parameters for macro ClearAll:
       :  ClearScreen : 0=Don't clear the screen, 1=Clear the screen
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__ClearAll(MX_BOOL FCL_CLEARSCREEN)
{

  if (FCL_CLEARSCREEN)
  {  

    #if (1) // 0 == 0
      FCD_029f1_gLCD_EB3__SetBackgroundColour(16777215, 16777215 >> 8, 16777215 >> 16);

      FCD_029f1_gLCD_EB3__ClearDisplay();

    #else
    //Code has been optimised out by the pre-processor
    #endif

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  FCV_0a401_DisplayManager1__NUMWIDGETS = 0;
  FCV_0a401_DisplayManager1__NUMOBJECTS = 0;
  FCV_0a401_DisplayManager1__LASTWIDGETPRESS = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :Creates a 2d array of objects that can be used to create things like table data.
       :Returns the ID of the first object, the following objects have incremental IDs going column by column and then row by row.
       :
       :Parameters for macro CreateObjectArray:
       :  ObjectType : 0=Hidden, 1=Rect, 2=Line, 3=Ellipse, 4=FilledEllipse, 5=FilledRect
       :  NumColumns : Number of columns of buttons in the array
       :  NumRows : Number of rows of buttons in the array
       :  InitialPositionX : X location of the initial button
       :  InitialPositionY : Y location of the initial button
       :  ObjectWidth : Widget width in pixels
       :  ObjectHeight : Object height in pixels
       :  SpacingX : Horizontal spacing between the objects
       :  SpacingY : Vertical spacing between the objects
       :  LineWidth : Number of pixels thick to draw outer border lines
       :  Colours[9] : Byte array containing FgColour RGB [0-2], Bg Colour RGB [3-5], Text Colour RGB [6-8]
       :  Font : Font used for the widgets text
       :  ObjectText[1000] : A comma seperated text field with the text for each object e.g. "1,2,3,.."
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0a401_DisplayManager1__CreateObjectArray(MX_UINT8 FCL_OBJECTTYPE, MX_UINT8 FCL_NUMCOLUMNS, MX_UINT8 FCL_NUMROWS, MX_UINT16 FCL_INITIALPOSITIONX, MX_UINT16 FCL_INITIALPOSITIONY, MX_UINT16 FCL_OBJECTWIDTH, MX_UINT16 FCL_OBJECTHEIGHT, MX_UINT16 FCL_SPACINGX, MX_UINT16 FCL_SPACINGY, MX_UINT8 FCL_LINEWIDTH, MX_UINT8 *FCL_COLOURS, MX_UINT16 FCLsz_COLOURS, MX_UINT8 FCL_FONT, MX_CHAR *FCL_OBJECTTEXT, MX_UINT16 FCLsz_OBJECTTEXT)
{
  //Local variable definitions
  MX_UINT8 FCL_ROW = (0x0);
  MX_UINT8 FCL_COL = (0x0);
  MX_UINT16 FCL_WY = (0x0);
  MX_UINT16 FCL_WX = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT16 FCL_ID = (0x0);
  #define FCLsz_TMPSTR 10
  MX_CHAR FCL_TMPSTR[FCLsz_TMPSTR];
  MX_UINT8 FCL_LEN;
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  for (FCLV_LOOP13=0; (FCLV_LOOP13)<(FCL_NUMROWS); (FCLV_LOOP13)++)
  {
    FCL_COL = 0;

    for (FCLV_LOOP14=0; (FCLV_LOOP14)<(FCL_NUMCOLUMNS); (FCLV_LOOP14)++)
    {
      FCL_WX = FCL_INITIALPOSITIONX + FCL_COL * (FCL_OBJECTWIDTH + FCL_SPACINGY);
      FCL_WY = FCL_INITIALPOSITIONY + FCL_ROW * (FCL_OBJECTHEIGHT + FCL_SPACINGX);

      FCL_ID = FCD_0a401_DisplayManager1__CreateObject(FCL_OBJECTTYPE, FCL_WX, FCL_WY, FCL_OBJECTWIDTH, FCL_OBJECTHEIGHT, FCL_LINEWIDTH, FCL_COLOURS, 9, 1);

      if (FCL_COUNT)
      {      

      } else {

        FCR_RETVAL = FCL_ID;

      }

      FCI_SPLITSTRING(FCL_OBJECTTEXT, FCLsz_OBJECTTEXT, ",", 2, FCL_COUNT, FCL_TMPSTR,10);
      FCL_LEN = FCI_GETLENGTH(FCL_TMPSTR, FCLsz_TMPSTR);

      if (FCL_LEN)
      {      

        FCD_0a401_DisplayManager1__SetTextLabel(FCL_ID, FCL_TMPSTR, FCLsz_TMPSTR, FCL_FONT, 1, 1, 1);

      // } else {

      }

      FCL_COUNT = FCL_COUNT + 1;
      FCL_COL = FCL_COL + 1;

    }

    FCL_ROW = FCL_ROW + 1;

  }

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Allows the bitmap image to be swapped out
       :
       :Parameters for macro ModifyBitmap:
       :  ID : Object or Widget ID to update
       :  Filename[20] : Bitmap filename in 8.3 file format
       :  Scaling : 0=Native, 1=Stretch
       :  Transparancy : 0=Disabled, 1=Enabled
       :  Redraw : MX_BOOL
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__ModifyBitmap(MX_UINT16 FCL_ID, MX_CHAR *PFCL_FILENAME, MX_BOOL FCL_SCALING, MX_BOOL FCL_TRANSPARANCY, MX_BOOL FCL_REDRAW)
{
  //Local variable definitions
  #define FCLsz_MQTT_STR 30
  MX_CHAR FCL_MQTT_STR[FCLsz_MQTT_STR] = "";

  #define FCLsz_FILENAME 20
  MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
  FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);


  FCI_SCOPY(FCL_FILENAME,FCLsz_FILENAME, FCV_0a401_DisplayManager1__BITMAPFILENAME,FCVsz_0a401_DisplayManager1__BITMAPFILENAME);

  if ((FCL_ID > 0) && (FCL_ID <= FCV_0a401_DisplayManager1__NUMOBJECTS))
  {  

    FCL_ID = FCL_ID - 1;

    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][0] = FCL_SCALING;
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCL_ID][0][1] = FCL_TRANSPARANCY;

    if (FCL_REDRAW)
    {    

      FCD_0a401_DisplayManager1__DrawItem(FCL_ID + 1);

    // } else {

    }

  // } else {

  }

  if ((FCL_ID > 20) && (FCL_ID <= (20 + FCV_0a401_DisplayManager1__NUMWIDGETS)))
  {  

    FCL_ID = FCL_ID - 1;

    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][0][0] = FCL_SCALING;
    FCV_0a401_DisplayManager1__WIDGETCOLOUR[FCL_ID - 20][0][1] = FCL_TRANSPARANCY;

    if (FCL_REDRAW)
    {    

      FCD_0a401_DisplayManager1__DrawItem(FCL_ID + 1);

    // } else {

    }

  // } else {

  }

  #if (0) // 1 && 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_MQTT_STR
  #undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_GetDCArray:
       :  data[100] : MX_UINT8
       :  Idx : MX_UINT16
       :  Count : MX_UINT8
       :  LayoutIndex : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__Prv_GetDCArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_IDX, MX_UINT8 FCL_COUNT, MX_UINT8 FCL_LAYOUTINDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_POINTER = (0x0);
  #define FCLsz_LAYOUTSTR 20
  MX_CHAR FCL_LAYOUTSTR[FCLsz_LAYOUTSTR] = "";
  #define FCLsz_PROPLAYOUT 20
  MX_CHAR FCL_PROPLAYOUT[FCLsz_PROPLAYOUT];


  {
  MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
  FCI_SHEAD("Layout",7, FCI_TOSTRING(FCL_LAYOUTINDEX, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCL_PROPLAYOUT,20);
  }

  // .LayoutStr=::Component.Property.GetValue(this, .PropLayout)

  while (FCL_IDX)
  {
    if (FCL_LAYOUTSTR[FCL_POINTER] == ',')
    {    

      FCL_IDX = FCL_IDX - 1;

    // } else {

    }

    FCL_POINTER = FCL_POINTER + 1;

  }

  FCL_DATA[FCL_IDX] = 0;

  while (FCL_IDX < FCL_COUNT)
  {
    if (FCL_LAYOUTSTR[FCL_POINTER] == ',')
    {    

      if ((FCL_COUNT == 255) && (FCL_DATA[FCL_IDX] == 0))
      {      

        FCL_COUNT = FCL_IDX;

      // } else {

      }

      FCL_IDX = FCL_IDX + 1;

      FCL_DATA[FCL_IDX] = 0;

    } else {

      FCL_DATA[FCL_IDX] = FCL_DATA[FCL_IDX] * 10;
      FCL_DATA[FCL_IDX] = FCL_DATA[FCL_IDX] + (FCL_LAYOUTSTR[FCL_POINTER] - '0');

    }

    FCL_POINTER = FCL_POINTER + 1;

  }

  //Local variable definitions
  #undef FCLsz_LAYOUTSTR
  #undef FCLsz_PROPLAYOUT
}

/*=----------------------------------------------------------------------=*\
   Use :Called when no touch is present, 
       :Allows the repeat rate counter to be cleared allowing for better responses to fast touches.
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__NoTouch()
{

  FCV_0a401_DisplayManager1__TOUCHINTERVAL = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :Creates a 2d array of buttons that can be used to create things like keypads.
       :Returns the ID of the first button, the following buttons have incremental IDs going column by column and then row by row.
       :
       :Parameters for macro CreateWidgetArray:
       :  WidgetType : 0=WidgetHidden, 1=WidgetRect, 2=WidgetRoundedRect, 3=WidgetEllipse, 4=VSlider, 5=HSlider, 6=VSliderRound, 7=HSliderRound
       :  NumColumns : Number of columns of buttons in the array
       :  NumRows : Number of rows of buttons in the array
       :  InitialPositionX : X location of the initial button
       :  InitialPositionY : Y location of the initial button
       :  WidgetWidth : Widget width in pixels
       :  WidgetHeight : Widget height in pixels
       :  SpacingX : Horizontal spacing between the widgets
       :  SpacingY : Vertical spacing between the widgets
       :  LineWidth : Number of pixels thick to draw outer border lines
       :  Colours[12] : , Hl Colour RGB [9-11]
       :  Font : Font used for the widgets text
       :  WidgetText[1000] : A comma seperated text field with the text for each widget e.g. "1,2,3,.."
       :  DrawHighlight : Draws the highlight on buttons, also used for thumb width on sliders
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0a401_DisplayManager1__CreateWidgetArray(MX_UINT8 FCL_WIDGETTYPE, MX_UINT8 FCL_NUMCOLUMNS, MX_UINT8 FCL_NUMROWS, MX_UINT16 FCL_INITIALPOSITIONX, MX_UINT16 FCL_INITIALPOSITIONY, MX_UINT16 FCL_WIDGETWIDTH, MX_UINT16 FCL_WIDGETHEIGHT, MX_UINT16 FCL_SPACINGX, MX_UINT16 FCL_SPACINGY, MX_UINT8 FCL_LINEWIDTH, MX_UINT8 *FCL_COLOURS, MX_UINT16 FCLsz_COLOURS, MX_UINT8 FCL_FONT, MX_CHAR *FCL_WIDGETTEXT, MX_UINT16 FCLsz_WIDGETTEXT, MX_UINT8 FCL_DRAWHIGHLIGHT)
{
  //Local variable definitions
  MX_UINT8 FCL_ROW = (0x0);
  MX_UINT8 FCL_COL = (0x0);
  MX_UINT16 FCL_WY = (0x0);
  MX_UINT16 FCL_WX = (0x0);
  MX_UINT8 FCL_COUNT = (0x0);
  MX_UINT16 FCL_ID = (0x0);
  #define FCLsz_TMPSTR 10
  MX_CHAR FCL_TMPSTR[FCLsz_TMPSTR];
  MX_UINT8 FCL_LEN;
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  for (FCLV_LOOP15=0; (FCLV_LOOP15)<(FCL_NUMROWS); (FCLV_LOOP15)++)
  {
    FCL_COL = 0;

    for (FCLV_LOOP16=0; (FCLV_LOOP16)<(FCL_NUMCOLUMNS); (FCLV_LOOP16)++)
    {
      FCL_WX = FCL_INITIALPOSITIONX + FCL_COL * (FCL_WIDGETWIDTH + FCL_SPACINGY);
      FCL_WY = FCL_INITIALPOSITIONY + FCL_ROW * (FCL_WIDGETHEIGHT + FCL_SPACINGX);

      FCL_ID = FCD_0a401_DisplayManager1__CreateWidget(FCL_WIDGETTYPE, FCL_WX, FCL_WY, FCL_WIDGETWIDTH, FCL_WIDGETHEIGHT, FCL_LINEWIDTH, FCL_COLOURS, 12, FCL_DRAWHIGHLIGHT, 1);

      if (FCL_COUNT)
      {      

      } else {

        FCR_RETVAL = FCL_ID;

      }

      FCI_SPLITSTRING(FCL_WIDGETTEXT, FCLsz_WIDGETTEXT, ",", 2, FCL_COUNT, FCL_TMPSTR,10);
      FCL_LEN = FCI_GETLENGTH(FCL_TMPSTR, FCLsz_TMPSTR);

      if (FCL_LEN)
      {      

        FCD_0a401_DisplayManager1__SetTextLabel(FCL_ID, FCL_TMPSTR, FCLsz_TMPSTR, FCL_FONT, 1, 1, 1);

      // } else {

      }

      FCL_COUNT = FCL_COUNT + 1;
      FCL_COL = FCL_COL + 1;

    }

    FCL_ROW = FCL_ROW + 1;

  }

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TMPSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Define a none touchable graphical object.
       :Returns the Object ID.
       :
       :Parameters for macro CreateObject:
       :  ObjectType : 0=Hidden, 1=Rect, 2=RoundedRect, 3=Ellipse, 4=Line, 8=Bitmap
       :  X : X Pixel Coordinate
       :  Y : Y Pixel Coordinate
       :  Width : Pixel Width or X Radius
       :  Height : Pixel Height or Y Radius
       :  LineWidth : Number of pixels thick to draw outer border lines
       :  Colours[9] : Byte array containing FgColour RGB [0-2], Bg Colour RGB [3-5], Text Colour RGB [6-8]
       :  DrawObject : 0=Do not draw object yet, 1=Draw object now (Does not apply to hidden objects)
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0a401_DisplayManager1__CreateObject(MX_UINT8 FCL_OBJECTTYPE, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_LINEWIDTH, MX_UINT8 *FCL_COLOURS, MX_UINT16 FCLsz_COLOURS, MX_BOOL FCL_DRAWOBJECT)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCV_0a401_DisplayManager1__NUMOBJECTS < 20)
  {  

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    FCV_0a401_DisplayManager1__TYPE[FCV_0a401_DisplayManager1__NUMOBJECTS] = FCL_OBJECTTYPE;
    FCV_0a401_DisplayManager1__X[FCV_0a401_DisplayManager1__NUMOBJECTS] = FCL_X;
    FCV_0a401_DisplayManager1__Y[FCV_0a401_DisplayManager1__NUMOBJECTS] = FCL_Y;
    FCV_0a401_DisplayManager1__W[FCV_0a401_DisplayManager1__NUMOBJECTS] = FCL_WIDTH;
    FCV_0a401_DisplayManager1__H[FCV_0a401_DisplayManager1__NUMOBJECTS] = FCL_HEIGHT;
    FCV_0a401_DisplayManager1__LINEWIDTH[FCV_0a401_DisplayManager1__NUMOBJECTS] = FCL_LINEWIDTH;
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][0][0] = FCL_COLOURS[0];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][0][1] = FCL_COLOURS[1];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][0][2] = FCL_COLOURS[2];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][1][0] = FCL_COLOURS[3];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][1][1] = FCL_COLOURS[4];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][1][2] = FCL_COLOURS[5];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][2][0] = FCL_COLOURS[6];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][2][1] = FCL_COLOURS[7];
    FCV_0a401_DisplayManager1__OBJECTCOLOUR[FCV_0a401_DisplayManager1__NUMOBJECTS][2][2] = FCL_COLOURS[8];

    FCV_0a401_DisplayManager1__NUMOBJECTS = FCV_0a401_DisplayManager1__NUMOBJECTS + 1;

    FCR_RETVAL = FCV_0a401_DisplayManager1__NUMOBJECTS;

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if (FCL_DRAWOBJECT)
    {    

      FCD_0a401_DisplayManager1__DrawItem(FCR_RETVAL);

    // } else {

    }

  } else {

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Initialises the object and Widget control variables and sets up the default themes.
\*=----------------------------------------------------------------------=*/
void FCD_0a401_DisplayManager1__Initialise()
{
  //Local variable definitions
  MX_UINT8 FCL_COUNT;
  #define FCLsz_RGB 3
  MX_UINT8 FCL_RGB[FCLsz_RGB];
  #define FCLsz_MQTT_STR 30
  MX_CHAR FCL_MQTT_STR[FCLsz_MQTT_STR] = "";


  FCV_0a401_DisplayManager1__NUMWIDGETS = 0;
  FCV_0a401_DisplayManager1__NUMOBJECTS = 0;

  #if (0) // 1 && 0
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_RGB
  #undef FCLsz_MQTT_STR
}


/*========================================================================*\
   Use :RXCB
       :GUID: c34f9b8a-a915-4f75-ad0c-87f2ad670a8a
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\CircularBuffer.fcpx
       :Version: 7.0 (0x100628)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_01211_RXCB__DATA 32
MX_GLOBAL MX_UINT16 FCV_01211_RXCB__DATAEND = (0x0);
MX_GLOBAL MX_UINT8 FCV_01211_RXCB__LOOKFORCOUNTER = (0x0);
MX_GLOBAL MX_UINT8 FCV_01211_RXCB__DATA[FCVsz_01211_RXCB__DATA];
MX_GLOBAL MX_UINT16 FCV_01211_RXCB__DATASTART = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Scans the buffer for an array of specific values.
       :Returns 0 if the value is not found.
       :Returns 1 if the value is found.
       :
       :Parameters for macro LookForValue:
       :  Value[20] : Value to look for, can be a string or byte array,
       :  NumChars : The number of characters you wish to try and match
       :  RemoveContent : 0=Leave data alone, 1=Remove data from buffer
       :  ResetFind : 0=Continue the find from the last operation, 1=Start again
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__LookForValue(MX_CHAR *FCL_VALUE, MX_UINT16 FCLsz_VALUE, MX_UINT8 FCL_NUMCHARS, MX_UINT8 FCL_REMOVECONTENT, MX_UINT8 FCL_RESETFIND)
{
  //Local variable definitions
  MX_UINT8 FCL_COMPAREDATA;
  MX_UINT8 FCL_NUMBYTES;
  MX_UINT16 FCL_DATAINDEX;
  MX_UINT16 FCL_SEARCHINDEX;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_RESETFIND == 1)
  {  

    FCV_01211_RXCB__LOOKFORCOUNTER = 0;

  // } else {

  }

  FCL_SEARCHINDEX = FCV_01211_RXCB__LOOKFORCOUNTER;

  FCL_NUMBYTES = FCD_01211_RXCB__GetNumberBytes();

  while (FCL_NUMCHARS > FCV_01211_RXCB__LOOKFORCOUNTER)
  {
    if (FCL_NUMBYTES > 0)
    {    

      if (FCL_REMOVECONTENT == 1)
      {      

        FCL_COMPAREDATA = FCD_01211_RXCB__GetByte();

      } else {

        FCL_DATAINDEX = FCV_01211_RXCB__DATASTART + FCL_SEARCHINDEX;

        if (FCL_DATAINDEX >= 32)
        {        

          FCL_DATAINDEX = FCL_DATAINDEX - 32;

        // } else {

        }

        FCL_COMPAREDATA = FCV_01211_RXCB__DATA[FCL_DATAINDEX];

        FCL_SEARCHINDEX = FCL_SEARCHINDEX + 1;

      }

      if (FCL_COMPAREDATA == FCL_VALUE[FCV_01211_RXCB__LOOKFORCOUNTER])
      {      

        FCV_01211_RXCB__LOOKFORCOUNTER = FCV_01211_RXCB__LOOKFORCOUNTER + 1;

        if (FCV_01211_RXCB__LOOKFORCOUNTER == FCL_NUMCHARS)
        {        

          FCV_01211_RXCB__LOOKFORCOUNTER = 0;

          FCL_NUMCHARS = 0;
          FCR_RETVAL = 1;

        // } else {

        }

      } else {

        if (FCV_01211_RXCB__LOOKFORCOUNTER > 0)
        {        

          FCV_01211_RXCB__LOOKFORCOUNTER = 0;

          if (FCL_COMPAREDATA == FCL_VALUE[FCV_01211_RXCB__LOOKFORCOUNTER])
          {          

            FCV_01211_RXCB__LOOKFORCOUNTER = FCV_01211_RXCB__LOOKFORCOUNTER + 1;

          // } else {

          }

        // } else {

        }

      }

      FCL_NUMBYTES = FCL_NUMBYTES - 1;

    } else {

      FCL_NUMCHARS = 0;

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads an array of Bytes from the circular buffer.
       :
       :Parameters for macro GetArray:
       :  Data[1000] : Data array to store the data into
       :  NumBytes : Number of bytes to read from the buffer
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__GetArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);


  while (FCL_IDX < FCL_NUMBYTES)
  {
    FCL_DATA[FCL_IDX] = FCD_01211_RXCB__GetByte();

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Reads a string of characters from the circular buffer.
       :
       :Parameters for macro GetString:
       :  MaxLength : Max number of bytes the string can store including the null byte
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT16 FCL_MAXLENGTH)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);


  if (FCL_MAXLENGTH > 1)
  {  

    FCL_MAXLENGTH = FCL_MAXLENGTH - 1;

  // } else {

  }

  while (FCL_IDX < FCL_MAXLENGTH)
  {
    FCR_RETVAL[FCL_IDX] = FCD_01211_RXCB__GetByte();

    if ((FCR_RETVAL[FCL_IDX] == 0) || (FCR_RETVAL[FCL_IDX] == 255))
    {    

      goto FCC_GetString_A;

    } else {

      FCL_IDX = FCL_IDX + 1;

    }

  }

FCC_GetString_A:
  ;

  FCR_RETVAL[FCL_IDX] = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :Writes an array of bytes into the circular buffer.
       :
       :Parameters for macro PutArray:
       :  Data[1000] : Byte array to write into the buffer
       :  NumBytes : Number of bytes to write into the buffer
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__PutArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);


  while (FCL_IDX < FCL_NUMBYTES)
  {
    FCD_01211_RXCB__PutByte(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the value of a single byte at a known location in the buffer.
       :Leaves the buffer contents and pointers untouched.
       :
       :Parameters for macro GetIndexedByte:
       :  address : MX_UINT16
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__GetIndexedByte(MX_UINT16 FCL_ADDRESS)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_ADDRESS < 32)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATA[FCL_ADDRESS];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits for an array of values to appear in the circular buffer.
       :Returns 0 to indicate a timeout.
       :Returns 1 to indicate the data has been found.
       :
       :Parameters for macro WaitForValue:
       :  Value[20] : MX_CHAR (by-ref)
       :  NumChars : Number of characters to try and look for
       :  RemoveContent : 0=Leave the buffer contents untouched, 1=Remove values as you go
       :  Timeout : Max amount of time to wait in milliseconds before returning 0=WaitForever
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__WaitForValue(MX_CHAR *FCL_VALUE, MX_UINT16 FCLsz_VALUE, MX_UINT8 FCL_NUMCHARS, MX_UINT8 FCL_REMOVECONTENT, MX_UINT16 FCL_TIMEOUT)
{
  //Local variable definitions
  MX_UINT8 FCL_WAITFOREVER = (0x0);
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_TIMEOUT == 0)
  {  

    FCL_WAITFOREVER = 1;
    FCL_TIMEOUT = 0xFFFF;

  // } else {

  }

  while ((FCL_TIMEOUT > 0) && (FCR_RETVAL == 0))
  {
    FCI_DELAYBYTE_MS(1);

    if (FCL_WAITFOREVER == 0)
    {    

      FCL_TIMEOUT = FCL_TIMEOUT - 1;

    // } else {

    }

    FCR_RETVAL = FCD_01211_RXCB__LookForValue(FCL_VALUE, FCLsz_VALUE, FCL_NUMCHARS, FCL_REMOVECONTENT, 0);

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the number of valid data bytes currently inside the buffer.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__GetNumberBytes()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  //Comment:
  //Jump directly to the answer

  if (FCV_01211_RXCB__DATAEND > FCV_01211_RXCB__DATASTART)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATAEND - FCV_01211_RXCB__DATASTART;

  } else {

    if (FCV_01211_RXCB__DATAEND < FCV_01211_RXCB__DATASTART)
    {    

      FCR_RETVAL = (32 - FCV_01211_RXCB__DATASTART) + FCV_01211_RXCB__DATAEND;

    } else {

      FCR_RETVAL = 0;

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the next available byte from the circular buffer without advancing the current index,
       :Returns 255/512 if the buffer is empty.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__PeekByte()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT16 FCR_RETVAL;


  if (FCV_01211_RXCB__DATASTART != FCV_01211_RXCB__DATAEND)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATA[FCV_01211_RXCB__DATASTART];

  } else {

    #if (0) // 0 == 1
    //Code has been optimised out by the pre-processor
    #else
      FCR_RETVAL = 255;

    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Writes a string of characters into the circular buffer.
       :
       :Parameters for macro PutString:
       :  Data[20] : String data array to write into the buffer
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__PutString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX = (0x0);
  MX_UINT16 FCL_LEN;


  FCL_LEN = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);

  while (FCL_IDX < FCL_LEN)
  {
    FCD_01211_RXCB__PutByte(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Add byte to the next free location inside the circular buffer.
       :If the data goes into the buffer correctly then return 1.
       :Otherwise the buffer is full and the return value will equal 0.
       :
       :Parameters for macro PutByte:
       :  Data : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_01211_RXCB__PutByte(MX_UINT8 FCL_DATA)
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT16 FCL_TEMP2;
  MX_UINT8 FCR_RETVAL;


  FCL_TEMP = FCV_01211_RXCB__DATAEND + 1;

  if (FCL_TEMP >= 32)
  {  

    FCL_TEMP = 0;

  // } else {

  }

  if (FCL_TEMP != FCV_01211_RXCB__DATASTART)
  {  

    FCV_01211_RXCB__DATA[FCV_01211_RXCB__DATAEND] = FCL_DATA;

    FCV_01211_RXCB__DATAEND = FCL_TEMP;

    FCR_RETVAL = 1;

  } else {

    #if (0) // 0 == 1
    //Code has been optimised out by the pre-processor
    #else
      FCR_RETVAL = 0;

    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the next available byte from the circular buffer,
       :Returns 255 if the buffer is empty.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__GetByte()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;
  MX_UINT16 FCR_RETVAL;


  if (FCV_01211_RXCB__DATASTART != FCV_01211_RXCB__DATAEND)
  {  

    FCR_RETVAL = FCV_01211_RXCB__DATA[FCV_01211_RXCB__DATASTART];

    FCL_TEMP = FCV_01211_RXCB__DATASTART + 1;

    if (FCL_TEMP >= 32)
    {    

      FCL_TEMP = 0;

    // } else {

    }

    FCV_01211_RXCB__DATASTART = FCL_TEMP;

  } else {

    #if (0) // 0 == 1
    //Code has been optimised out by the pre-processor
    #else
      FCR_RETVAL = 255;

    #endif

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the number of bytes that can be stored in the buffer.
       :Either in total or the number of bytes remaining based on Mode.
       :
       :Parameters for macro GetSize:
       :  Mode : 0=TotalBufferSize, 1=BufferFreeSpace
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_01211_RXCB__GetSize(MX_BOOL FCL_MODE)
{
  //Local variable definitions
  MX_UINT16 FCL_NUMBYTES;
  MX_UINT16 FCR_RETVAL;


  FCR_RETVAL = 32 - 1;

  if (FCL_MODE)
  {  

    FCL_NUMBYTES = FCD_01211_RXCB__GetNumberBytes();

    FCR_RETVAL = FCR_RETVAL - FCL_NUMBYTES;

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Clears the contents of the buffer and re-initialises the index locations.
\*=----------------------------------------------------------------------=*/
void FCD_01211_RXCB__FlushBuffer()
{

  FCV_01211_RXCB__DATAEND = 0;
  FCV_01211_RXCB__DATASTART = 0;

}


/*========================================================================*\
   Use :TypeConversionsFree1
       :GUID: 
       :Location: 
       :Version:  (0x0)
       :Timestamp: 
       :Variable declarations
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets a single 16-bit INT value.
       :Index is in little endian, 0 is the LSW and 1 is the MSW
       :
       :Parameters for macro SetInt:
       :  Index : Range: 0-1
       :  Value : Range: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetInt(MX_UINT8 FCL_INDEX, MX_UINT16 FCL_VALUE)
{

  if (FCL_INDEX < 2)
  {  

    // C Code
    MX_Conv_Var.AsInt[FCL_INDEX] = FCL_VALUE;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 32-bit LONG value
       :
       :Parameters for macro SetLong:
       :  Value : Range: 0-4294967295
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetLong(MX_UINT32 FCL_VALUE)
{

  // C Code
  MX_Conv_Var.AsLong = FCL_VALUE;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 32-bit FLOAT value
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_02571_TypeConversionsFree1__GetFloat()
{
  //Local variable definitions
  MX_FLOAT FCR_RETVAL;


  // C Code
  FCR_RETVAL = MX_Conv_Var.AsFloat;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 32-bit LONG value
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_02571_TypeConversionsFree1__GetLong()
{
  //Local variable definitions
  MX_UINT32 FCR_RETVAL;


  // C Code
  FCR_RETVAL = MX_Conv_Var.AsLong;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 16-bit INT value
       :Index is in little endian, 0 is the LSW and 1 is the MSW
       :
       :Parameters for macro GetInt:
       :  Index : Range: 0-1
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_02571_TypeConversionsFree1__GetInt(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  if (FCL_INDEX < 2)
  {  

    // C Code
    FCR_RETVAL = MX_Conv_Var.AsInt[FCL_INDEX];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 8-bit BYTE value
       :Index is in little endian, 0 is the LSB and 3 is the MSB
       :
       :Parameters for macro SetByte:
       :  Index : Range: 0-3
       :  Value : Range: 0-255
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetByte(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_VALUE)
{

  if (FCL_INDEX < 4)
  {  

    // C Code
    MX_Conv_Var.AsByte[FCL_INDEX] = FCL_VALUE;

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single 8-bit BYTE value.
       :Index is in little endian, 0 is the LSB and 3 is the MSB
       :
       :Parameters for macro GetByte:
       :  Index : Range: 0-3
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_02571_TypeConversionsFree1__GetByte(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX < 4)
  {  

    // C Code
    FCR_RETVAL = MX_Conv_Var.AsByte[FCL_INDEX];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a single 32-bit FLOAT value
       :
       :Parameters for macro SetFloat:
       :  Value : Range: 0-4294967295
\*=----------------------------------------------------------------------=*/
void FCD_02571_TypeConversionsFree1__SetFloat(MX_FLOAT FCL_VALUE)
{

  // C Code
  MX_Conv_Var.AsFloat = FCL_VALUE;

}


/*========================================================================*\
   Use :UART1
       :GUID: 91b64b1d-b8b2-40f1-b073-e953a91fa234
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\cal_uart.fcpx
       :Version: 22.0 (0x200328)
       :Timestamp: 18\07\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_BOOL FCV_05481_UART1__RS485_STATE;
MX_GLOBAL MX_UINT32 FCV_05481_UART1__CONSOLE;

/*=----------------------------------------------------------------------=*\
   Use :Allows direct control over the TX and RTS pins
       :Also allows for reading of the state of the RX and CTS pins.
       :Only available when the UART is uninitialised.
       :
       :Parameters for macro ControlPin:
       :  Pin : 0=TX, 1=RX, 2=RTS, 3=CTS
       :  State : MX_UINT8
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__ControlPin(MX_UINT8 FCL_PIN, MX_UINT8 FCL_STATE)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  switch (FCL_PIN)
  {
    case 1:
    {

      #if (1)
        FCR_RETVAL = GET_PORT_PIN(G, 1);

      // #else
      //Code has been optimised out by the pre-processor
      #endif

      break;
    }
    case 2:
    {

      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    case 3:
    {

      #if (0)
      //Code has been optimised out by the pre-processor
      // #else
      #endif

      break;
    }
    default:
    {
      #if (1)
        if (FCL_STATE)
        {        

          SET_PORT_PIN(G, 0, 1);

        } else {

          SET_PORT_PIN(G, 0, 0);

        }

      // #else
      //Code has been optimised out by the pre-processor
      #endif

    }
  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Transmits a string of bytes via the UART peripheral
       :
       :Parameters for macro SendString:
       :  Data[200] : Data String to transmit
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_LEN;


  FCL_LEN = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);
  FCL_IDX = 0;

  while (FCL_IDX < FCL_LEN)
  {
    FC_CAL_UART_Send_1(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_TextConsole:
       :  Str[20] : MX_CHAR (by-ref)
       :  colour : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_COLOUR)
{

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :A simple macro to allow us to test the value of a single property during runtime.
       :
       :Parameters for macro TestProperty:
       :  Property : 0=UseTX, 1=UseRX, 2=UseFlowControl
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__TestProperty(MX_UINT8 FCL_PROPERTY)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_PROPERTY == 0)
  {  

    #if (1)
      FCR_RETVAL = 1;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // } else {

  }

  if (FCL_PROPERTY == 1)
  {  

    #if (1)
      FCR_RETVAL = 1;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // } else {

  }

  if (FCL_PROPERTY == 2)
  {  

    #if (0)
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  // } else {

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Transmits a numeric value as an ASCII string
       :
       :Parameters for macro SendNumber:
       :  Number : Numeric value to send
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__SendNumber(MX_SINT32 FCL_NUMBER)
{
  //Local variable definitions
  #define FCLsz_NUMSTR 20
  MX_CHAR FCL_NUMSTR[FCLsz_NUMSTR];


  FCI_TOSTRING(FCL_NUMBER, FCL_NUMSTR,20);

  FCD_05481_UART1__SendString(FCL_NUMSTR, FCLsz_NUMSTR);

  //Local variable definitions
  #undef FCLsz_NUMSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_SimShowWaveform:
       :  TXRX : MX_UINT8
       :  Data : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__Prv_SimShowWaveform(MX_UINT8 FCL_TXRX, MX_UINT16 FCL_DATA)
{

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Transmits an array of bytes via the UART peripheral
       :
       :Parameters for macro SendByteArray:
       :  Data[32768] : Data to transmit
       :  NumBytes : Number of bytes to send from the array
\*=----------------------------------------------------------------------=*/
void FCD_05481_UART1__SendByteArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;


  FCL_IDX = 0;

  while (FCL_IDX < FCL_NUMBYTES)
  {
    FC_CAL_UART_Send_1(FCL_DATA[FCL_IDX]);

    FCL_IDX = FCL_IDX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Receives an array of bytes and returns the number of bytes received.
       :
       :Parameters for macro ReceiveByteArray:
       :  Data[32768] : MX_UINT8
       :  NumBytes : Maximum number of bytes to try and receive
       :  Timeout : Max amount of time in ms to wait between bytes
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__ReceiveByteArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_NUMBYTES, MX_UINT8 FCL_TIMEOUT)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_IN;
  MX_UINT16 FCL_TOUT;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    FCL_TOUT = 256;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  FCR_RETVAL = 0;

  while (FCR_RETVAL < FCL_NUMBYTES)
  {
    FCL_IN = FC_CAL_UART_Receive_1(FCL_TIMEOUT);

    if (FCL_IN < FCL_TOUT)
    {    

      FCL_DATA[FCR_RETVAL] = FCL_IN;

      FCR_RETVAL = FCR_RETVAL + 1;

    } else {

      goto FCC_ReceiveByteArray_A;

    }

  }

FCC_ReceiveByteArray_A:
  ;

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Receives a string of bytes and returns the number of bytes received.
       :
       :Parameters for macro ReceiveString:
       :  StringData[20] : MX_CHAR (by-ref)
       :  NumBytes : Maximum number of bytes to try and receive
       :  Timeout : Max amount of time in ms to wait between bytes
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05481_UART1__ReceiveString(MX_CHAR *FCL_STRINGDATA, MX_UINT16 FCLsz_STRINGDATA, MX_UINT16 FCL_NUMBYTES, MX_UINT8 FCL_TIMEOUT)
{
  //Local variable definitions
  MX_UINT16 FCL_IDX;
  MX_UINT16 FCL_IN;
  MX_UINT16 FCL_TOUT;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    FCL_TOUT = 256;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  FCR_RETVAL = 0;

  while (FCR_RETVAL < FCL_NUMBYTES)
  {
    FCL_IN = FC_CAL_UART_Receive_1(FCL_TIMEOUT);

    if (FCL_IN < FCL_TOUT)
    {    

      FCL_STRINGDATA[FCR_RETVAL] = FCL_IN;

      FCR_RETVAL = FCR_RETVAL + 1;

    } else {

      goto FCC_ReceiveString_A;

    }

  }

FCC_ReceiveString_A:
  ;

  FCL_STRINGDATA[FCR_RETVAL] = 0;

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :WidthData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb2_WidthData__FLOATFIXEDLIST 1
#define FCVsz_00fb2_WidthData__INTFIXEDLIST 144
#define FCD_00fb2_WidthData__INTFIXEDLIST(ix) FCD_00fb2_WidthData__INTFIXEDLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_WidthData__INTFIXEDLIST_LUT ROMARRAY_E =
{
3,9,14,11,16,16,3,6,6,8,11,3,7,3,7,11,7,11,11,12,11,11,11,11,11,3,3,12,12,12,13,22,17,14,15,14,13,12,16,13,3,11,14,12,17,13,16,13,17,14,14,13,13,17,23,14,15,14,6,7,6,12,14,6,12,12,11,12,11,8,12,11,3,6,10,3,17,11,13,12,12,7,11,7,11,11,19,11,13,10,7,3,7,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8
};

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb2_WidthData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 144;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :ASCIIData
       :GUID: dfb4d07a-3d70-45d5-83ef-07e3c95d86ab
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\lut.fcpx
       :Version: 15.0 (0x100828)
       :Timestamp: 11\04\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_00fb1_ASCIIData__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCIIData__INTFIXEDLIST 3114
#define FCD_00fb1_ASCIIData__INTFIXEDLIST(ix) 0

/*=----------------------------------------------------------------------=*\
   Use :Gets the number of individual data entries stored in the LUT.
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_00fb1_ASCIIData__GetLUTCount()
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  #if (1)
    FCR_RETVAL = 3114;

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :gLCD_Font1
       :GUID: 1b08885c-807e-4631-930e-a4fef06159dc
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_Font.fcpx
       :Version: 37.0 (0x1400028)
       :Timestamp: 12\09\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_09e51_gLCD_Font1__OLDCHAR = (0x0);
MX_GLOBAL MX_UINT32 FCV_09e51_gLCD_Font1__OLDPOSITION = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Adds up all the pixels widths before the selected character to get to the start of the pixel data
       :
       :Parameters for macro SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_09e51_gLCD_Font1__SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH;
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (1)
    #if (1) // 0 == 0
      while (FCL_CHARACTER > 0)
      {
        FCL_CHARACTER = FCL_CHARACTER - 1;

        FCL_WIDTH = FCD_00fb2_WidthData__INTFIXEDLIST(FCL_CHARACTER);

        FCR_RETVAL = FCR_RETVAL + FCL_WIDTH;

      }

      FCR_RETVAL = FCR_RETVAL * 3;

    // #else
    //Code has been optimised out by the pre-processor
    #endif

  // #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets the width of the ASCII character font data
       :
       :Parameters for macro ReadWidth:
       :  Character : ASCII position so A = 'A'
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadWidth(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCL_PWIDTH;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 176 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0)
    //Code has been optimised out by the pre-processor
    #else
      if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 144)))
      {      

        if (FCL_CHARACTER == 32)
        {        

          FCR_RETVAL = 5;

        } else {

          //Comment:
          //Out of range,return 5 character to show the character out of range pattern

          FCR_RETVAL = 5;

        }

      } else {

        FCL_CHARACTER = FCL_CHARACTER - 33;

        FCR_RETVAL = FCD_00fb2_WidthData__INTFIXEDLIST(FCL_CHARACTER);

      }

    #endif

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Collects a stat about the selected font
       :
       :Parameters for macro ReadFontStat:
       :  Index : 0=SpaceColumns, 1=CharacterHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadFontStat(MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  if (FCL_INDEX == 1)
  {  

    FCR_RETVAL = 24;

  } else {

    FCR_RETVAL = 001;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a single pixel column byte from the selected ASCII character font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  Character : ASCII position so A = 'A'
       :  ByteIndex : Range: 0 to ((PixelWidth - 1) * BytesPerColumn)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_09e51_gLCD_Font1__ReadASCIILUT(MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  #if (1)
    #if (1) // 176 < 255
#if 0 // Disabled code
      if ((FCL_CHARACTER == 167) || (FCL_CHARACTER == 248))
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

#endif // Disabled code

      if (FCL_CHARACTER > 127)
      {      

        FCL_CHARACTER = 176;

      // } else {

      }

    // #else
    //Code has been optimised out by the pre-processor
    #endif

    #if (0) // 0 && (FCL_CHARACTER >= 'a')
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    if ((FCL_CHARACTER < 33) || (FCL_CHARACTER > (33 + 144)))
    {    

      if (FCL_CHARACTER == 32)
      {      

        FCR_RETVAL = 0;

      } else {

        //Comment:
        //Out of range

        FCR_RETVAL = 0xAA;

      }

    } else {

      FCL_CHARACTER = FCL_CHARACTER - 33;

      #if (0) // 0 == 1
      //Code has been optimised out by the pre-processor
      #else
        if (FCL_CHARACTER == FCV_09e51_gLCD_Font1__OLDCHAR)
        {        

          FCL_POSITION = FCV_09e51_gLCD_Font1__OLDPOSITION;

        } else {

          FCL_POSITION = FCD_09e51_gLCD_Font1__SumWidths(FCL_CHARACTER);

          FCV_09e51_gLCD_Font1__OLDPOSITION = FCL_POSITION;
          FCV_09e51_gLCD_Font1__OLDCHAR = FCL_CHARACTER;

        }

      #endif

      FCL_POSITION = FCL_POSITION + FCL_BYTEINDEX;

      FCR_RETVAL = FCD_00fb1_ASCIIData__INTFIXEDLIST(FCL_POSITION);

    }

  #else
  //Code has been optimised out by the pre-processor
  #endif

  return (FCR_RETVAL);

}


/*========================================================================*\
   Use :Base_GLCD
       :GUID: 4384cba9-0bea-4359-8c5b-dcd046aa7778
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\Base_GLCD.fcpx
       :Version: 53.0 (0x2300028)
       :Timestamp: 08\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME2 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME1 13
#define FCVsz_0ba71_Base_GLCD__SPACEWIDTH 1
#define FCVsz_0ba71_Base_GLCD__FONTHEADER 16
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME8 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME7 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME6 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME5 13
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME4 13
#define FCVsz_0ba71_Base_GLCD__CHARSPACING 1
#define FCVsz_0ba71_Base_GLCD__FONTFILENAME3 13

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_SumWidths:
       :  Character : MX_UINT8
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCD_0ba71_Base_GLCD__Prv_SumWidths(MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCL_WIDTH = (0x0);
  MX_UINT32 FCR_RETVAL;


  FCR_RETVAL = 0;

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the number of pixel columns used in the selected font
       :
       :Parameters for macro ReadFontWidth:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character to get the pixel width e.g. 'A' or 65
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadFontWidth(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadWidth(FCL_CHARACTER);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Prv_ReadFontFileHeader:
       :  Font : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Prv_ReadFontFileHeader(MX_UINT8 FCL_FONT)
{
  //Local variable definitions
  MX_UINT8 FCL_RETVAL = (0x0);
  MX_UINT8 FCL_IDX = (0x0);
  #define FCLsz_TEST 20
  MX_CHAR FCL_TEST[FCLsz_TEST] = "";


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_TEST
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a stat from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontStat:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Index : 0=SpaceWidth, 1=PixelHeight
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadFontStat(MX_UINT8 FCL_FONT, MX_UINT8 FCL_INDEX)
{
  //Local variable definitions
  MX_UINT16 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0)
  //Code has been optimised out by the pre-processor
  #else
    //Comment:
    //Character Spacing comes from font component properties
    //specified by the user and independent of the font file.

    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadFontStat(FCL_INDEX);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows one of the default external font files to be switched out for a different font file.
       :
       :Parameters for macro SetExternalFont:
       :  Font : Range: 0 to (FontCount - 1)
       :  Filename[20] : New font filename
       :  CharacterSpacing : Number of pixel columns to use between each character
       :  SpaceWidth : Number of pixel columns to use for a space character
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetExternalFont(MX_UINT8 FCL_FONT, MX_CHAR *PFCL_FILENAME, MX_UINT8 FCL_CHARACTERSPACING, MX_UINT8 FCL_SPACEWIDTH)
{
  #define FCLsz_FILENAME 20
  MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
  FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);


  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  //Local variable definitions
  #undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte from the selected embedded ASCII font data.
       :
       :Parameters for macro ReadFontByte:
       :  Font : Font selection range: 0 to (NumFonts - 1)
       :  Character : ASCII character for example 'A' or 65
       :  ByteIndex : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadFontByte(MX_UINT8 FCL_FONT, MX_UINT8 FCL_CHARACTER, MX_UINT16 FCL_BYTEINDEX)
{
  //Local variable definitions
  MX_UINT32 FCL_POSITION;
  MX_UINT8 FCR_RETVAL;


  FCR_RETVAL = 0;

  if (FCL_FONT >= 1)
  {  

    FCL_FONT = 0;

  // } else {

  }

  #if (0) // (0) && (FCL_CHARACTER != ' ')
  //Code has been optimised out by the pre-processor
  #else
    if (FCL_FONT == 0)
    {    

      FCR_RETVAL = FCD_09e51_gLCD_Font1__ReadASCIILUT(FCL_CHARACTER, FCL_BYTEINDEX);

    // } else {

    }

    #if (0) // 1 > 1
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 2
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 3
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 4
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 5
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 6
    //Code has been optimised out by the pre-processor
    // #else
    #endif

    #if (0) // 1 > 7
    //Code has been optimised out by the pre-processor
    // #else
    #endif

  #endif

  return (FCR_RETVAL);

}

#define FCA_GLCD_EB3 0x29f1
#define FCV_GLCD_EB3 0x000d

/*========================================================================*\
   Use :gLCD_EB3
       :GUID: ac3375c7-acf3-4160-8c3e-3011735116aa
       :Location: C:\ProgramData\MatrixTSL\FlowcodeV11\Components\gLCD_EB3.fcpx
       :Version: 25.0 (0x100028)
       :Timestamp: 15\10\2025
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_029f1_gLCD_EB3__TOUCHCOORDS 2
#define FCVsz_029f1_gLCD_EB3__COMMANDTX 20
#define FCV_029f1_gLCD_EB3__TIMEOUT (0x64)
MX_GLOBAL MX_UINT16 FCV_029f1_gLCD_EB3__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_029f1_gLCD_EB3__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_029f1_gLCD_EB3__RXCOUNT;
MX_GLOBAL MX_SINT16 FCV_029f1_gLCD_EB3__TOUCHCOORDS[FCVsz_029f1_gLCD_EB3__TOUCHCOORDS] = {-1, -1};
MX_GLOBAL MX_BOOL FCV_029f1_gLCD_EB3__SIMTOUCHED = (0);
MX_GLOBAL MX_UINT8 FCV_029f1_gLCD_EB3__COMMANDTX[FCVsz_029f1_gLCD_EB3__COMMANDTX];
MX_GLOBAL MX_UINT8 FCV_029f1_gLCD_EB3__TXCOUNT = (0x0);

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__ReceiveReply()
{
  //Local variable definitions
  MX_UINT8 FCL_RETRY = (0x32);
  MX_UINT8 FCL_RXDONE = (0x0);
  MX_UINT8 FCL_RXMODE = (0x0);
  MX_UINT16 FCL_RX;
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Receive Command Reply

  FCD_01211_RXCB__FlushBuffer();

  FCR_RETVAL = 0;

  while (FCL_RXDONE == 0)
  {
    FCL_RX = FC_CAL_UART_Receive_1(FCV_029f1_gLCD_EB3__TIMEOUT);

    if (FCL_RX > 255)
    {    

      if (FCL_RETRY == 0)
      {      

        FCL_RXDONE = 1;

      } else {

        FCL_RETRY = FCL_RETRY - 1;

      }

    } else {

      if (FCL_RXMODE == 0)
      {      

        if (FCL_RX == ':')
        {        

          FCL_RXMODE = 1;

        // } else {

        }

      } else {

        if (FCL_RXMODE == 1)
        {        

          if (FCL_RX == FCV_029f1_gLCD_EB3__COMMANDTX[0])
          {          

            FCL_RXMODE = 2;

          } else {

            FCL_RXMODE = 0;

          }

        } else {

          FCD_01211_RXCB__PutByte(FCL_RX);

          FCR_RETVAL = FCR_RETVAL + 1;

          FCL_RXDONE = FCD_01211_RXCB__LookForValue(";\n", 3, 2, 0, 0);

        }

      }

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__ConnectWifi()
{
  //Local variable definitions
  #define FCLsz_RX 4
  MX_UINT8 FCL_RX[FCLsz_RX];
  MX_UINT8 FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'e';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'g';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 1;

  FCD_029f1_gLCD_EB3__SendCommandWithDualString("", 1, "", 1);

  FCR_RETVAL = FCD_01211_RXCB__GetByte();

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_RX
}

/*=----------------------------------------------------------------------=*\
   Use :Allows the fonts to be scaled up by multiplying the number of pixels on the X and Y.
       :
       :Parameters for macro SetFontScaler:
       :  ScaleX : Sets the horizontal scale of the font, default 1
       :  ScaleY : Sets the vertical scale of the font, default 1
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetFontScaler(MX_UINT8 FCL_SCALEX, MX_UINT8 FCL_SCALEY)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '6';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_SCALEX;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_SCALEY;
  FCV_029f1_gLCD_EB3__TXCOUNT = 3;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a bitmap image loaded from the SD card scaled to the defined width and height.
       :FileInit must be called first to ensure the File System is setup.
       :
       :Parameters for macro DrawBitmapScaled:
       :  Filename[20] : Bitmap file to open from current directory on SD card 8.3 format
       :  X1 : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y1 : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Width : The dimension to draw the bitmap in pixels
       :  Height : The dimension to draw the bitmap in pixels
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__DrawBitmapScaled(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '9';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_WIDTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_WIDTH >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_HEIGHT;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_HEIGHT >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_ORIENTATION;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_TRANSPARENCY;
  FCV_029f1_gLCD_EB3__COMMANDTX[11] = FCL_FLIP;
  FCV_029f1_gLCD_EB3__TXCOUNT = 12;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_FILENAME, FCLsz_FILENAME);

  FCR_RETVAL = FCD_01211_RXCB__GetByte();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommand()
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SendCommandWithArray:
       :  Data[1000] : MX_UINT8
       :  Count : MX_UINT16
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommandWithArray(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_COUNT)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FCD_05481_UART1__SendByteArray(FCL_DATA, 1000, FCL_COUNT);

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function to transfer the display manager edits through to the web mirror.
       :
       :Parameters for macro SendBinaryAction:
       :  Data[60] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SendBinaryAction(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '.';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_DATA, FCLsz_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Parameters for macro PrintNumber:
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Selects which Font to use Range: 0 to Font Count
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
  //Local variable definitions
  #define FCLsz_TEMP 8
  MX_CHAR FCL_TEMP[FCLsz_TEMP];


  FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,8);

  FCD_029f1_gLCD_EB3__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

  //Local variable definitions
  #undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Parameters for macro DrawLine:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
  //Local variable definitions
  MX_SINT16 FCL_C1;
  MX_SINT16 FCL_M1;
  MX_SINT16 FCL_D1 = (0);
  MX_SINT16 FCL_PIXELX;
  MX_SINT16 FCL_PIXELY;
  MX_SINT16 FCL_YINC = (1);
  MX_SINT16 FCL_XINC = (1);
  MX_BOOL FCL_STRAIGHT = (0);


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'E';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_X2;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_X2 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_Y2;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_Y2 >> 8;
  FCV_029f1_gLCD_EB3__TXCOUNT = 9;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Adjusts the brightness of the backlight.
       :
       :Parameters for macro BacklightBrightness:
       :  Brightness : Range: 0 - 255, 0=Off, 255=Max
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__BacklightBrightness(MX_UINT8 FCL_BRIGHTNESS)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'J';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_BRIGHTNESS;
  FCV_029f1_gLCD_EB3__TXCOUNT = 2;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Checks to see if the screen has been touched.
       :Returns 1 for a new valid touch and 0 for no touch.
       :
       :Parameters for macro TouchReadCoord:
       :  Axis : 0=X, 1=Y
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_029f1_gLCD_EB3__TouchReadCoord(MX_UINT8 FCL_AXIS)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  if (FCL_AXIS < 2)
  {  

    FCR_RETVAL = FCV_029f1_gLCD_EB3__TOUCHCOORDS[FCL_AXIS];

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse object on the display with the center of the ellipse at the location X,Y
       :
       :Parameters for macro DrawEllipse:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  XRadius : Radius of the circle on the X axis specified in pixels
       :  YRadius : Radius of the circle on the Y axis specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawEllipse(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_XRADIUS, MX_UINT16 FCL_YRADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

  FCL_X = FCL_X - FCL_XRADIUS;
  FCL_Y = FCL_Y - FCL_YRADIUS;
  FCL_XRADIUS = FCL_XRADIUS << 1;
  FCL_YRADIUS = FCL_YRADIUS << 1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'y';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_XRADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_XRADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_YRADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_YRADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 11;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Parameters for macro Plot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'z';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__TXCOUNT = 5;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at current pixel location.
       :Not compatible with orientations other than 0.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__FastPlot()
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;


}

/*=----------------------------------------------------------------------=*\
   Use :Draws a bitmap image loaded from the SD card
       :FileInit must be called first to ensure the File System is setup.
       :
       :Parameters for macro DrawQRCode:
       :  X1 : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y1 : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Scaler : Size of each block in pixels: 1=33x33, 2=66x66, 3=99x99, etc
       :  Text[20] : Data to embed into the QR code. e.g. "www.myURL.com"
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawQRCode(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_SCALER, MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '5';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_SCALER;
  FCV_029f1_gLCD_EB3__TXCOUNT = 6;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_TEXT, FCLsz_TEXT);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an arc either as an outline or as a filled object.
       :
       :Parameters for macro DrawArc:
       :  X : Center X coordinate
       :  Y : Center Y coordinate
       :  Radius : Radius, distance of edge from the centre coordinates
       :  StartAngle : Angle to start drawing, in degrees
       :  EndAngle : Angle to end drawing, in degrees
       :  Resolution : Number of lines to draw from the center to the outer edge, 0=Fill
       :  Transparent : Chooses the transparency - 0 = Arc contains background colour, 1 = Arc contains previous pixel data.
       :  Solid : Chooses to fill with colour - 0 = Arc transparency data, 1 = Arc contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawArc(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT16 FCL_STARTANGLE, MX_UINT16 FCL_ENDANGLE, MX_UINT16 FCL_RESOLUTION, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_SINT16 FCL_I;
  MX_SINT16 FCL_J;
  MX_SINT16 FCL_SX;
  MX_SINT16 FCL_SY;
  MX_FLOAT FCL_ANGLESTEP;
  MX_FLOAT FCL_ANGLE;
  MX_SINT16 FCL_OX = (-32768);
  MX_SINT16 FCL_OY = (-32768);


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 's';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_STARTANGLE;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_STARTANGLE >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_ENDANGLE;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_ENDANGLE >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[11] = FCL_RESOLUTION;
  FCV_029f1_gLCD_EB3__COMMANDTX[12] = FCL_RESOLUTION >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[13] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[14] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 15;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Parameters for macro SetDisplayOrientation:
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'K';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_ORIENTATION;
  FCV_029f1_gLCD_EB3__TXCOUNT = 2;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Parameters for macro BPlot:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns the colour to use as the transparent mask. 
       :Anything in this specific colour will not be drawn when the DrawBitmap->Transparent parameter is set.
       :
       :Parameters for macro SetBitmapTransparency:
       :  R : Colour channel. Range: 0 to 255
       :  G : Colour channel. Range: 0 to 255
       :  B : Colour channel. Range: 0 to 255
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetBitmapTransparency(MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'S';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_R;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_G;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_B;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a bitmap image loaded from the SD card
       :FileInit must be called first to ensure the File System is setup.
       :
       :Parameters for macro DrawBitmap:
       :  Filename[20] : Bitmap file to open from current directory on SD card 8.3 format
       :  X1 : X Axis coordinate, specifies the location of the left edge of the bitmap image
       :  Y1 : Y Axis coordinate, specifies the location of the top edge of the bitmap image
       :  Orientation : 0=Normal, 1=90 Degrees CW, 2=180 Degrees, 3=270 Degrees CW
       :  Transparency : 0=Off, 1=On Don't Draw Any Pixels which match the transparent colour
       :  Flip : 0=Normal, 1=FlipWidth, 2=FlipHeight, 3=FlipBoth
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__DrawBitmap(MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_ORIENTATION, MX_UINT8 FCL_TRANSPARENCY, MX_UINT8 FCL_FLIP)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'R';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_ORIENTATION;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_TRANSPARENCY;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_FLIP;
  FCV_029f1_gLCD_EB3__TXCOUNT = 8;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_FILENAME, FCLsz_FILENAME);

  FCR_RETVAL = FCD_01211_RXCB__GetByte();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a floating point number to the Graphical LCD.
       :
       :Parameters for macro PrintFloat:
       :  Number : Floating point number to send to the display.
       :  NumDP : Number of decimal points
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Selects which Font to use Range: 0 to Font Count
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__PrintFloat(MX_FLOAT FCL_NUMBER, MX_UINT8 FCL_NUMDP, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
  //Local variable definitions
  #define FCLsz_TEMP 8
  MX_CHAR FCL_TEMP[FCLsz_TEMP];


  FCI_FLOAT_TO_STRING(FCL_NUMBER, FCL_NUMDP, FCL_TEMP, FCLsz_TEMP);

  FCD_029f1_gLCD_EB3__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

  //Local variable definitions
  #undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SendCommandWithString:
       :  Str[20] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommandWithString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FCD_05481_UART1__SendString(FCL_STR, FCLsz_STR);

  FC_CAL_UART_Send_1('\0');

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro Window:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Window(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
  //Local variable definitions
  MX_UINT16 FCL_TEMP;


}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Parameters for macro Print:
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Selects which Font to use Range: 0 to Font Count
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'G';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_FONT;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = 0;
  FCV_029f1_gLCD_EB3__TXCOUNT = 8;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_STR, FCLsz_STR);

}

/*=----------------------------------------------------------------------=*\
   Use :Checks to see if the screen has been touched.
       :Returns 1 for a new valid touch and 0 for no touch.
       :
       :Returns : MX_BOOL
\*=----------------------------------------------------------------------=*/
MX_BOOL FCD_029f1_gLCD_EB3__TouchCheck()
{
  //Local variable definitions
  #define FCLsz_RX 4
  MX_UINT8 FCL_RX[FCLsz_RX];
  MX_BOOL FCR_RETVAL;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'O';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 4;

  FCD_029f1_gLCD_EB3__SendCommand();

  FCD_01211_RXCB__GetArray(FCL_RX, 4, 4);

  FCV_029f1_gLCD_EB3__TOUCHCOORDS[0] = FCL_RX[0] | (FCL_RX[1] << 8);
  FCV_029f1_gLCD_EB3__TOUCHCOORDS[1] = FCL_RX[2] | (FCL_RX[3] << 8);

  if ((FCV_029f1_gLCD_EB3__TOUCHCOORDS[0] >= 0) && (FCV_029f1_gLCD_EB3__TOUCHCOORDS[1] >= 0))
  {  

    FCR_RETVAL = 1;

  } else {

    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_RX
}

/*=----------------------------------------------------------------------=*\
   Use :This macro overrides the default font with a substitute font file. 
       :The binary font file must be placed onto the SD card inside the Fonts folder.
       :
       :Parameters for macro SetExternalFont:
       :  Font : Selects which Font to override Range: 0 to (Font Count - 1)
       :  Str[13] : Binary font file to use in standard 8.3 file format
       :  CharacterSpacing : Number of pixel columns added in between each character
       :  SpaceWidth : Number of pixel columns used for a space character
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetExternalFont(MX_UINT8 FCL_FONT, MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT8 FCL_CHARACTERSPACING, MX_UINT8 FCL_SPACEWIDTH)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '+';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_FONT;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_CHARACTERSPACING;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_SPACEWIDTH;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithString(FCL_STR, FCLsz_STR);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro SendCommandWithDualString:
       :  Str1[20] : MX_CHAR (by-ref)
       :  Str2[20] : MX_CHAR (by-ref)
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_029f1_gLCD_EB3__SendCommandWithDualString(MX_CHAR *FCL_STR1, MX_UINT16 FCLsz_STR1, MX_CHAR *FCL_STR2, MX_UINT16 FCLsz_STR2)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  //Comment:
  //Send command packet

  FC_CAL_UART_Send_1(':');

  FCD_05481_UART1__SendByteArray(FCV_029f1_gLCD_EB3__COMMANDTX, 20, FCV_029f1_gLCD_EB3__TXCOUNT);

  FCD_05481_UART1__SendString(FCL_STR1, FCLsz_STR1);

  FC_CAL_UART_Send_1('\0');

  FCD_05481_UART1__SendString(FCL_STR2, FCLsz_STR2);

  FC_CAL_UART_Send_1('\0');

  FC_CAL_UART_Send_1(';');

  FC_CAL_UART_Send_1('\n');

  FCR_RETVAL = FCD_029f1_gLCD_EB3__ReceiveReply();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function to transfer the binary scene through to the web mirror.
       :
       :Parameters for macro SendBinaryScene:
       :  Data[2048] : Binary scene data
       :  Length : Number of bytes to send
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SendBinaryScene(MX_UINT8 *FCL_DATA, MX_UINT16 FCLsz_DATA, MX_UINT16 FCL_LENGTH)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = '-';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_LENGTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_LENGTH >> 8;
  FCV_029f1_gLCD_EB3__TXCOUNT = 3;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommandWithArray(FCL_DATA, 2048, FCL_LENGTH);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__ClearDisplay()
{
  //Local variable definitions
  MX_UINT16 FCL_Y = (0x0);
  MX_UINT16 FCL_X = (0x0);
  MX_UINT8 FCL_ORIENTATIONSAVE;


  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'D';
  FCV_029f1_gLCD_EB3__TXCOUNT = 1;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetBackgroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'C';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_RED;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_GREEN;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_BLUE;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle object on the display with the center of the circle at the location X,Y
       :
       :Parameters for macro DrawCircle:
       :  X : X Coordinate for the center of the circle
       :  Y : Y coordinate for the center of the circle
       :  Radius : Radius of the circle specified in pixels
       :  Transparent : 0=Fill inside circle using background colour / 1=Draw outer circle only
       :  Solid : 0=Use Transparent Setting / 1=Fill with foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{

  FCL_X = FCL_X - FCL_RADIUS;
  FCL_Y = FCL_Y - FCL_RADIUS;
  FCL_RADIUS = FCL_RADIUS << 1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'y';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 11;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with rounded corners
       :
       :Parameters for macro DrawRoundedRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Radius : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawRoundedRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_UINT16 FCL_HEIGHT;
  MX_UINT16 FCL_WIDTH;


  FCL_WIDTH = FCL_X2 - FCL_X1;
  FCL_HEIGHT = FCL_Y2 - FCL_Y1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 't';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_WIDTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_WIDTH >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_HEIGHT;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_HEIGHT >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_RADIUS;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_RADIUS >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[11] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[12] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 13;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Parameters for macro SetForegroundColour:
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'B';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_RED;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_GREEN;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_BLUE;
  FCV_029f1_gLCD_EB3__TXCOUNT = 4;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Parameters for macro DrawRectangle:
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
  //Local variable definitions
  MX_UINT16 FCL_WIDTH;
  MX_UINT16 FCL_HEIGHT;


  FCL_WIDTH = FCL_X2 - FCL_X1;
  FCL_HEIGHT = FCL_Y2 - FCL_Y1;

  FCV_029f1_gLCD_EB3__COMMANDTX[0] = 'F';
  FCV_029f1_gLCD_EB3__COMMANDTX[1] = FCL_X1;
  FCV_029f1_gLCD_EB3__COMMANDTX[2] = FCL_X1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[3] = FCL_Y1;
  FCV_029f1_gLCD_EB3__COMMANDTX[4] = FCL_Y1 >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[5] = FCL_WIDTH;
  FCV_029f1_gLCD_EB3__COMMANDTX[6] = FCL_WIDTH >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[7] = FCL_HEIGHT;
  FCV_029f1_gLCD_EB3__COMMANDTX[8] = FCL_HEIGHT >> 8;
  FCV_029f1_gLCD_EB3__COMMANDTX[9] = FCL_TRANSPARENT;
  FCV_029f1_gLCD_EB3__COMMANDTX[10] = FCL_SOLID;
  FCV_029f1_gLCD_EB3__TXCOUNT = 11;
  FCV_029f1_gLCD_EB3__RXCOUNT = 0;

  FCD_029f1_gLCD_EB3__SendCommand();

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_029f1_gLCD_EB3__Initialise()
{
  //Local variable definitions
  MX_UINT8 FCL_IDX;


  FCI_DELAYBYTE_S(2);

  FC_CAL_UART_Init_1();

  FCD_029f1_gLCD_EB3__SetBackgroundColour(16777215, 16777215 >> 8, 16777215 >> 16);

  FCD_029f1_gLCD_EB3__SetForegroundColour(16777215, 16777215 >> 8, 16777215 >> 16);

  FCD_029f1_gLCD_EB3__SetDisplayOrientation(1);

  FCD_029f1_gLCD_EB3__ClearDisplay();

  FCD_029f1_gLCD_EB3__SetExternalFont(0, "AriB24.bin", 11, 001, 5);

  #if (0) // 1 > 1
  //Code has been optimised out by the pre-processor
  // #else
  #endif

  #if (0)
  //Code has been optimised out by the pre-processor
  // #else
  #endif

}


/*========================================================================*\
   Use :User Project
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_VALUE = (0x0);
MX_GLOBAL MX_SINT16 FCV_TOUCHEDOBJECTID = (0);
MX_GLOBAL MX_SINT16 FCV_Y = (0);
MX_GLOBAL MX_SINT16 FCV_X = (0);
MX_GLOBAL MX_UINT8 FCV_TOUCH = (0x0);
MX_GLOBAL MX_FLOAT FCV_VALUE_FLOAT = (0.0);

/*=----------------------------------------------------------------------=*\
   Use :Optional macro called by the DisplayManager::CheckForTouch component macro when the defined area is touched
       :
       :Parameters for macro DC_Touched:
       :  Handle : The handle of the component that was clicked
\*=----------------------------------------------------------------------=*/
void FCM_DC_Touched(MX_UINT32 FCL_HANDLE)
{

  // Switch
  switch (FCL_HANDLE)
  {
    case FCV_GOTOSCREEN1:
    {

      // Component Macro
      FCD_0a401_DisplayManager1__DrawScene(1);

      break;
    }
    case FCV_GOTOSCREEN0:
    {

      // Component Macro
      FCD_0a401_DisplayManager1__DrawScene(0);

      break;
    }
    case FCV_UP:
    {

      // Calculation
      FCV_VALUE = FCV_VALUE + 1;

      // Component Macro
      FCD_05fa1_value_display__SetTextNumber(FCV_VALUE, "", 1);

      break;
    }
    case FCV_DOWN:
    {

      // Calculation
      FCV_VALUE = FCV_VALUE - 1;

      // Component Macro
      FCD_05fa1_value_display__SetTextNumber(FCV_VALUE, "", 1);

      break;
    }
    case FCV_SLIDER:
    {

      // Component Macro
      FCV_VALUE_FLOAT = FCD_077c1_Slider__GetSliderValue();

      // Calculation
      FCV_VALUE = flt_toi(flt_mul(FCV_VALUE_FLOAT, 100.00));

      // Component Macro
      FCD_05fa1_value_display__SetTextNumber(FCV_VALUE, "", 1);

      break;
    }
    // default:

  }

}



/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
	#ifdef INTOSCHELPER
		INTOSCHELPERCODE
	#endif
	//Setup input pins as digital
	ANSELA = 0x00;
	ANSELB = 0x00;
	ANSELD = 0x00;
	ANSELE = 0x00;
	ANSELF = 0x00;
	ANSELG = 0x00;

	//Setup UART Remapping UART2=GLCD, UART5=USB
	RX2PPS = 0x31;
	RG0PPS = 0x0E;
	RX5PPS = 0x33;
	RG2PPS = 0x14;




  // Component Macro
  FCD_029f1_gLCD_EB3__Initialise();

  // Component Macro
  FCD_0a401_DisplayManager1__Initialise();

  // Component Macro
  FCD_0a401_DisplayManager1__DrawScene(0);

  // Loop
  while (1)
  {
    // Check for touch
    FCV_TOUCH = FCD_029f1_gLCD_EB3__TouchCheck();

    // Touch Detected?
    if (FCV_TOUCH)
    {    

      // Component Macro
      FCV_X = FCD_029f1_gLCD_EB3__TouchReadCoord(0);

      // Component Macro
      FCV_Y = FCD_029f1_gLCD_EB3__TouchReadCoord(1);

      // check to see if display is touched
      FCV_TOUCHEDOBJECTID = FCD_0a401_DisplayManager1__CheckForTouch(FCV_X, FCV_Y);

    } else {

      //Comment:
      //Call NoTouch to clear repeat rate counter

      // No touch detected
      FCD_0a401_DisplayManager1__NoTouch();

    }

    // Delay
    FCI_DELAYBYTE_MS(10);

  }

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{
	#ifdef USE_FLOWCODE_ICD3
		ICD_INTERRUPT_HANDLER
	#endif

}




