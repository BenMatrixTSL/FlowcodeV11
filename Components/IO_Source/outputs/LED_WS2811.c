//************************************************************************************
//**  
//**  Source name:   D:\Dev\Flowcode V11\Components\IO_Source\outputs\LED_WS2811.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.16F.16F1937
//**  
//**  Generated by:  Flowcode v11.0.0.8
//**  Date:          Friday, January 16, 2026 10:41:23
//**  Users:         1
//**  Registered to: BenR (82702381)
//**  Licence key: 95CJQR
//**  
//**  
//**  https://www.flowcode.co.uk
//**  
//************************************************************************************


#include "D:\Dev\Flowcode V11\Components\IO_Source\outputs\LED_WS2811.h"

#define FCA_CLONE_MATRIX_2D 0xbf12
#define FCV_CLONE_MATRIX_2D 0x0163
#define FCA_ESP32_RMT1 0x4081
#define FCV_ESP32_RMT1 0x00e3
#define FCA_CLONE_MATRIX_3D 0xbf11
#define FCV_CLONE_MATRIX_3D 0x001f
#define FCA_SHAPE1 0x6f61
#define FCV_SHAPE1 0x001d
#define FCA_SHAPE_SPHERE1 0xf0f1
#define FCV_SHAPE_SPHERE1 0x000d

/*========================================================================*\
   Use :User Project
       :Variable declarations
       :Macro implementations
\*========================================================================*/
#define FCVsz_RGB 32768
#define FCVsz_RGB_1 3
MX_GLOBAL MX_UINT8 FCV_RGB[9][3];
MX_GLOBAL MX_UINT8 FCV_COLSCALE = (0xff);

/*=----------------------------------------------------------------------=*\
   Use :Allows the output colour brightness of the LEDs to be scaled down. For example to save current usage or to reduce brightness in dark environments.
       :
       :Parameters for macro SetBrightness:
       :  Scaler : Range: 0.0 to 1.0 Default: 1.0, 0 = Off, 0.5 = Half Brightness, 1.0 = Full Brightness
\*=----------------------------------------------------------------------=*/
void FCM_SetBrightness(MX_FLOAT FCL_SCALER)
{

  // Decision
  if (flt_gt(FCL_SCALER, 1.0))
  {  

    // Calculation
    FCL_SCALER = 1.0;

  // } else {

  }

  // Decision
  if (flt_lt(FCL_SCALER, 0.0))
  {  

    // Calculation
    FCL_SCALER = 0.0;

  // } else {

  }

  // Calculation
  FCL_SCALER = flt_mul(FCL_SCALER, 255.0);

  // Calculation
  FCV_COLSCALE = flt_toi(FCL_SCALER);

}

/*=----------------------------------------------------------------------=*\
   Use :Initialisation routine for the component once the component is linked to its parent
       :
       :Returns : Non-zero to prevent initialisation
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCM_Ev_Initialise()
{
  //Local variable definitions
  MX_SINT32 FCL_PANELID = (0);
  MX_UINT32 FCL_HANDLE = (0x0);
  MX_UINT32 FCR_RETVAL; // Non-zero to prevent initialisation


  // Simulation
  // ::Component.Property.SetValue(clone_matrix_2d, "x_count", 1)

  // Simulation
  // ::Component.Property.SetValue(clone_matrix_2d, "y_count", 1)

  // Simulation
  // ::Component.Property.SetValue(clone_matrix_2d, "z_count", 1)

  // Simulation
  // ::Component.Property.SetValue(clone_matrix_3d, "x_count", 1)

  // Simulation
  // ::Component.Property.SetValue(clone_matrix_3d, "y_count", 1)

  // Simulation
  // ::Component.Property.SetValue(clone_matrix_3d, "z_count", 1)

  // Built-in Function
  // .PanelID=::Component.GetPanel(this)

  // Legacy panels - 3D mode
  if (FCL_PANELID < 0)
  {  

    // Built-in Function
    // ::Component.Property.SetFilter(this, "LED_Arrangement", "0001D\n0012D\n0023D")

    // Built-in Function
    // ::Component.SetVisible(clone_matrix_2d, 0)

    // Simulation
    // ::Component.SetVisible(shape_sphere1, 1)

    // Simulation
    // ::Component.SetSolid(shape_sphere1, 1)

    // Simulation
    // ::Component.SetInteractive(shape_sphere1, 1)

    // Simulation
    // ::Component.SetVisible(Shape1, 0)

    // Simulation
    // ::Component.SetSolid(Shape1, 0)

    // Simulation
    // ::Component.SetInteractive(Shape1, 0)

    // Component Macro
    // clone_matrix_3d::Update()

  } else {

    // Built-in Function
    // ::Component.Property.SetFilter(this, "LED_Arrangement", "0001D\n0012D")

    // Built-in Function
    // ::Component.SetVisible(clone_matrix_3d, 0)

    // Simulation
    // ::Component.SetVisible(Shape1, 1)

    // Simulation
    // ::Component.SetSolid(Shape1, 1)

    // Simulation
    // ::Component.SetInteractive(Shape1, 1)

    // Simulation
    // ::Component.SetVisible(shape_sphere1, 0)

    // Simulation
    // ::Component.SetSolid(shape_sphere1, 0)

    // Simulation
    // ::Component.SetInteractive(shape_sphere1, 0)

    // Component Macro
    // clone_matrix_2d::Update()

  }

  // User Macro
  FCM_Ev_Property();

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the colour of a single LED in RAM as a 1D array.
       :
       :Parameters for macro GetLEDColour:
       :  LED : LED to change the colour / Range: 0 to (LED Count - 1)
       :  ColIdx : 0 = Red, 1 = Green, 2 = Blue
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCM_GetLEDColour(MX_UINT16 FCL_LED, MX_UINT8 FCL_COLIDX)
{
  //Local variable definitions
  MX_UINT8 FCR_RETVAL;


  // Check LED index is in range
  if ((FCL_LED < 9) && (FCL_COLIDX < 3))
  {  

    // Decision
    if (FCV_COLSCALE < 255)
    {    

      // Calculation
      FCR_RETVAL = (FCV_RGB[FCL_LED][FCL_COLIDX] << 8) / FCV_COLSCALE;

    } else {

      // Calculation
      FCR_RETVAL = FCV_RGB[FCL_LED][FCL_COLIDX];

    }

  } else {

    // Calculation
    FCR_RETVAL = 0;

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sent when a property has been changed by the User
       :
       :Returns : MX_UINT32
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCM_Ev_Property()
{
  //Local variable definitions
  MX_UINT16 FCL_COUNT;
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_FLOAT FCL_CLOCKSPEED;
  #define FCLsz_STR2 20
  MX_CHAR FCL_STR2[FCLsz_STR2];
  MX_SINT16 FCL_SETCOUNT = (10);
  MX_SINT32 FCL_PANELID = (0);
  MX_UINT32 FCR_RETVAL;


  // Built-in Function
  // .PanelID=::Component.GetPanel(this)

  // Switch
  switch (0)
  {
    case 1:
    {

      // Simulation
      // ::Component.Property.SetWritable(this, "LED_Count", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Cols", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Rows", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Layers", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "y_spacing", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "z_spacing", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "sequence", 1)

      // Calculation
      FCL_COUNT = 3 * 3;

      // Simulation
      // ::Component.Property.SetValue(this, "LED_Count", .Count)

      // Legacy panels - 3D mode
      if (FCL_PANELID < 0)
      {      

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "x_count", LED_Cols)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "y_count", LED_Rows)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "z_count", 1)

      } else {

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_2d, "x_count", LED_Cols)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_2d, "y_count", LED_Rows)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_2d, "z_count", 1)

      }

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipX", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipY", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipZ", 0)

      break;
    }
    case 2:
    {

      // Simulation
      // ::Component.Property.SetWritable(this, "LED_Count", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Cols", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Rows", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Layers", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "y_spacing", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "z_spacing", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "sequence", 1)

      // Calculation
      FCL_COUNT = (3 * 3) * 3;

      // Simulation
      // ::Component.Property.SetValue(this, "LED_Count", .Count)

      // Legacy panels - 3D mode
      if (FCL_PANELID < 0)
      {      

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "x_count", LED_Cols)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "y_count", LED_Rows)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "z_count", LED_Layers)

      // } else {

      }

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipX", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipY", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipZ", 1)

      break;
    }
    default:
    {
      // Simulation
      // ::Component.Property.SetWritable(this, "LED_Count", 1)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Cols", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Rows", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "LED_Layers", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "y_spacing", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "z_spacing", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "sequence", 0)

      // Legacy panels - 3D mode
      if (FCL_PANELID < 0)
      {      

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "x_count", LED_Count)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "y_count", 1)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_3d, "z_count", 1)

      } else {

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_2d, "x_count", LED_Count)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_2d, "y_count", 1)

        // Simulation
        // ::Component.Property.SetValue(clone_matrix_2d, "z_count", 1)

      }

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipX", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipY", 0)

      // Simulation
      // ::Component.Property.SetVisible(this, "FlipZ", 0)

    }
  }

  // Legacy panels - 3D mode
  if (FCL_PANELID < 0)
  {  

    // Simulation
    // ::Component.Property.CopyValue(this, clone_matrix_3d, "x_spacing")

    // Simulation
    // ::Component.Property.CopyValue(this, clone_matrix_3d, "y_spacing")

    // Simulation
    // ::Component.Property.CopyValue(this, clone_matrix_3d, "z_spacing")

    // Simulation
    // clone_matrix_3d::Update()

  } else {

    // Simulation
    // ::Component.Property.CopyValue(this, clone_matrix_2d, "x_spacing")

    // Simulation
    // ::Component.Property.CopyValue(this, clone_matrix_2d, "y_spacing")

    // Simulation
    // ::Component.Property.CopyValue(this, clone_matrix_2d, "z_spacing")

    // Simulation
    // clone_matrix_2d::Update()

  }

  // Decision
  if (0 < 5)
  {  

    // Simulation
    // ::Component.Property.SetWritable(this, "Reset_Time", 0)

    // Simulation
    // ::Component.Property.SetWritable(this, "T0H", 0)

    // Simulation
    // ::Component.Property.SetWritable(this, "T1H", 0)

    // Simulation
    // ::Component.Property.SetWritable(this, "T0L", 0)

    // Simulation
    // ::Component.Property.SetWritable(this, "T1L", 0)

  // } else {

  }

  // Switch
  switch (0)
  {
    case 1:
    {

      //Comment:
      //WS2812

      // Simulation
      // ::Component.Property.SetValue(this, "Reset_Time", 50.0)

      // Simulation
      // ::Component.Property.SetValue(this, "T0H", 0.35)

      // Simulation
      // ::Component.Property.SetValue(this, "T1H", 0.7)

      // Simulation
      // ::Component.Property.SetValue(this, "T0L", 0.8)

      // Simulation
      // ::Component.Property.SetValue(this, "T1L", 0.6)

      // Simulation
      // ::Component.Property.SetWritable(this, "DataOrder", 0)

      // Simulation
      // ::Component.Property.SetValue(this, "DataOrder", 1)

      break;
    }
    case 2:
    {

      //Comment:
      //WS2812B

      // Simulation
      // ::Component.Property.SetValue(this, "Reset_Time", 50.0)

      // Simulation
      // ::Component.Property.SetValue(this, "T0H", 0.3)

      // Simulation
      // ::Component.Property.SetValue(this, "T1H", 0.8)

      // Simulation
      // ::Component.Property.SetValue(this, "T0L", 0.85)

      // Simulation
      // ::Component.Property.SetValue(this, "T1L", 0.45)

      // Simulation
      // ::Component.Property.SetWritable(this, "DataOrder", 0)

      // Simulation
      // ::Component.Property.SetValue(this, "DataOrder", 1)

      break;
    }
    case 3:
    {

      //Comment:
      //APA104

      // Simulation
      // ::Component.Property.SetValue(this, "Reset_Time", 50.0)

      // Simulation
      // ::Component.Property.SetValue(this, "T0H", 0.4)

      // Simulation
      // ::Component.Property.SetValue(this, "T1H", 0.8)

      // Simulation
      // ::Component.Property.SetValue(this, "T0L", 0.85)

      // Simulation
      // ::Component.Property.SetValue(this, "T1L", 0.45)

      // Simulation
      // ::Component.Property.SetWritable(this, "DataOrder", 0)

      // Simulation
      // ::Component.Property.SetValue(this, "DataOrder", 0)

      break;
    }
    case 4:
    {

      //Comment:
      //APA106

      // Simulation
      // ::Component.Property.SetValue(this, "Reset_Time", 50.0)

      // Simulation
      // ::Component.Property.SetValue(this, "T0H", 0.35)

      // Simulation
      // ::Component.Property.SetValue(this, "T1H", 1.36)

      // Simulation
      // ::Component.Property.SetValue(this, "T0L", 1.36)

      // Simulation
      // ::Component.Property.SetValue(this, "T1L", 0.35)

      // Simulation
      // ::Component.Property.SetWritable(this, "DataOrder", 0)

      // Simulation
      // ::Component.Property.SetValue(this, "DataOrder", 0)

      break;
    }
    case 5:
    {

      //Comment:
      //Custom

      // Simulation
      // ::Component.Property.SetWritable(this, "Reset_Time", 1)

      // Simulation
      // ::Component.Property.SetWritable(this, "T0H", 1)

      // Simulation
      // ::Component.Property.SetWritable(this, "T1H", 1)

      // Simulation
      // ::Component.Property.SetWritable(this, "T0L", 1)

      // Simulation
      // ::Component.Property.SetWritable(this, "T1L", 1)

      // Simulation
      // ::Component.Property.SetWritable(this, "DataOrder", 1)

      break;
    }
    default:
    {
      //Comment:
      //WS2811

      // Simulation
      // ::Component.Property.SetValue(this, "Reset_Time", 50.0)

      // Simulation
      // ::Component.Property.SetValue(this, "T0H", 0.5)

      // Simulation
      // ::Component.Property.SetValue(this, "T1H", 1.2)

      // Simulation
      // ::Component.Property.SetValue(this, "T0L", 2.0)

      // Simulation
      // ::Component.Property.SetValue(this, "T1L", 1.3)

      // Simulation
      // ::Component.Property.SetWritable(this, "DataOrder", 0)

      // Simulation
      // ::Component.Property.SetValue(this, "DataOrder", 0)

    }
  }

  // Simulation
  // ::Component.Property.SetVisible(this, "RMT_Channel", 0)

  // Simulation
  // .tempstr=::FCD.GetItemValue("device", "cal", "")

  // Simulation
  // ::Component.Property.SetValue(this, "DeviceFamily", .tempstr)

  // Decision
  if (FCI_COMPARE(FCL_TEMPSTR, FCLsz_TEMPSTR, "PIC", 4, 0) == 0)
  {  

    // Simulation
    // ::Component.Property.SetValue(this, "Direct", 1)

  } else {

    // Decision
    if (FCI_COMPARE(FCL_TEMPSTR, FCLsz_TEMPSTR, "PIC16BIT", 9, 0) == 0)
    {    

      // Simulation
      // ::Component.Property.SetValue(this, "Direct", 1)

    } else {

      // Decision
      if (FCI_COMPARE(FCL_TEMPSTR, FCLsz_TEMPSTR, "PIC32BIT", 9, 0) == 0)
      {      

        // Simulation
        // ::Component.Property.SetValue(this, "Direct", 1)

      } else {

        // Decision
        if (FCI_COMPARE(FCL_TEMPSTR, FCLsz_TEMPSTR, "STARM", 6, 0) == 0)
        {        

          // Simulation
          // ::Component.Property.SetValue(this, "Direct", 1)

        } else {

          // Decision
          if (FCI_COMPARE(FCL_TEMPSTR, FCLsz_TEMPSTR, "PICO", 5, 0) == 0)
          {          

            // Simulation
            // ::Component.Property.SetValue(this, "Direct", 0)

          } else {

            // Decision
            if (FCI_COMPARE(FCL_TEMPSTR, FCLsz_TEMPSTR, "ESP", 4, 0) == 0)
            {            

              // Simulation
              // ::Component.Property.SetValue(this, "Direct", 0)

              // Simulation
              // .tempstr=::Component.Property.GetValue(this, "MOSI")

              // Simulation
              // ::Component.Property.SetValue(ESP32_RMT1, "Pin", .tempstr)

              // 2 x 24 bit colour + stop bit
              // ::Component.Property.SetValue(ESP32_RMT1, "BuffSize", 49)

              // Decision
              if (9 & 0x01)
              {              

                // Built-in Function
                // ::Component.Property.SetValue(this, "LED_Count", LED_Count + 1)

              // } else {

              }

            } else {

              // Simulation
              // ::Component.Property.SetValue(this, "Direct", 0)

            }

          }

        }

      }

    }

  }

  // Decision
  if (FCI_COMPARE(FCL_TEMPSTR, FCLsz_TEMPSTR, "STARM", 6, 1) == 0)
  {  

    // Simulation
    // ::Component.Property.SetVisible(this, "InstRate", 1)

    // 10MHz = 0.1uS Resolution
    FCL_CLOCKSPEED = flt_div(180000000, 22.0);

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(0.500000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Decision
    if (FCL_COUNT > 4)
    {    

      // Simulation
      // ::Component.Property.SetValue(this, "T0HNops", .Count - 4)

    } else {

      // Simulation
      // ::Component.Property.SetValue(this, "T0HNops", 0)

    }

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(2.000000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Simulation
    // ::Component.Property.SetValue(this, "T0LNops", .Count)

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(1.200000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Simulation
    // ::Component.Property.SetValue(this, "T1HNops", .Count)

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(1.300000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Simulation
    // ::Component.Property.SetValue(this, "T1LNops", .Count)

  } else {

    // Simulation
    // ::Component.Property.SetVisible(this, "InstRate", 0)

    // Simulation
    // .tempstr=::FCD.GetItemValue("device.clock", "value", "20000000")

    // Calculation
    FCL_CLOCKSPEED = FCI_STRING_TO_FLOAT(FCL_TEMPSTR, FCLsz_TEMPSTR);

    // Simulation
    // .Count=::FCD.GetItemValue("device.clock", "master_divider", "2")

    // Calculation
    FCL_CLOCKSPEED = flt_div(FCL_CLOCKSPEED, flt_fromi(FCL_COUNT));

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(0.500000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Decision
    if (FCL_COUNT > 6)
    {    

      // Simulation
      // ::Component.Property.SetValue(this, "T0HNops", .Count - 6)

    } else {

      // Simulation
      // ::Component.Property.SetValue(this, "T0HNops", 0)

    }

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(2.000000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Simulation
    // ::Component.Property.SetValue(this, "T0LNops", .Count)

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(1.200000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Simulation
    // ::Component.Property.SetValue(this, "T1HNops", .Count)

    // Calculation
    FCL_COUNT = flt_toi(flt_div((flt_div(1.300000, 1000000.0)), (flt_div(1.0, FCL_CLOCKSPEED))));

    // Simulation
    // ::Component.Property.SetValue(this, "T1LNops", .Count)

  }

  // Simulation
  // .Count=::Component.GetInstance(this)

  // Simulation
  // ::Component.Property.SetValue(this, "Instance", .Count)

  // Simulation
  // .tempstr=::Component.Property.GetValue(this, "T0H")

  // Calculation
  FCL_CLOCKSPEED = FCI_STRING_TO_FLOAT(FCL_TEMPSTR, FCLsz_TEMPSTR);
  FCL_CLOCKSPEED = flt_mul(FCL_CLOCKSPEED, 1000.0);

  // Simulation
  // ::Component.Property.SetValue(this, "T0HN", .ClockSpeed)

  // Simulation
  // .tempstr=::Component.Property.GetValue(this, "T0L")

  // Calculation
  FCL_CLOCKSPEED = FCI_STRING_TO_FLOAT(FCL_TEMPSTR, FCLsz_TEMPSTR);
  FCL_CLOCKSPEED = flt_mul(FCL_CLOCKSPEED, 1000.0);

  // Simulation
  // ::Component.Property.SetValue(this, "T0LN", .ClockSpeed)

  // Simulation
  // .tempstr=::Component.Property.GetValue(this, "T1H")

  // Calculation
  FCL_CLOCKSPEED = FCI_STRING_TO_FLOAT(FCL_TEMPSTR, FCLsz_TEMPSTR);
  FCL_CLOCKSPEED = flt_mul(FCL_CLOCKSPEED, 1000.0);

  // Simulation
  // ::Component.Property.SetValue(this, "T1HN", .ClockSpeed)

  // Simulation
  // .tempstr=::Component.Property.GetValue(this, "T1L")

  // Calculation
  FCL_CLOCKSPEED = FCI_STRING_TO_FLOAT(FCL_TEMPSTR, FCLsz_TEMPSTR);
  FCL_CLOCKSPEED = flt_mul(FCL_CLOCKSPEED, 1000.0);

  // Simulation
  // ::Component.Property.SetValue(this, "T1LN", .ClockSpeed)

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TEMPSTR
  #undef FCLsz_STR2
}

/*=----------------------------------------------------------------------=*\
   Use :Allows the output colour brightness of the LEDs to be scaled down. For example to save current usage or to reduce brightness in dark environments.
       :
       :Parameters for macro SetBrightnessByte:
       :  Scaler : Range: 0 to 255 Default: 255, 0 = Off, 128 = Half Brightness, 255 = Full Brightness
\*=----------------------------------------------------------------------=*/
void FCM_SetBrightnessByte(MX_UINT8 FCL_SCALER)
{

  // Calculation
  FCV_COLSCALE = FCL_SCALER;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line on a 2D array of LEDs
       :
       :Parameters for macro DrawLine2D:
       :  X1 : Start X Coordinate
       :  Y1 : Start Y Coordinate
       :  X2 : End X Coordinate
       :  Y2 : End Y Coordinate
       :  R : Red colour channel
       :  G : Green colour channel
       :  B : Blue colour channel
\*=----------------------------------------------------------------------=*/
void FCM_DrawLine2D(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{
  //Local variable definitions
  MX_SINT16 FCL_C1;
  MX_SINT16 FCL_D1 = (0);
  MX_SINT16 FCL_M1;
  MX_SINT16 FCL_PIXELX;
  MX_SINT16 FCL_PIXELY;
  MX_SINT16 FCL_XINC = (1);
  MX_SINT16 FCL_YINC = (1);
  MX_UINT16 FCL_IDX;


  // Calculation
  FCL_PIXELX = FCL_X2 - FCL_X1;
  FCL_PIXELY = FCL_Y2 - FCL_Y1;

  // If negative X direction
  if (FCL_PIXELX < 0)
  {  

    // Calculation
    FCL_XINC = -1;
    FCL_PIXELX = FCL_PIXELX * -1;

  // } else {

  }

  // If negative Y direction
  if (FCL_PIXELY < 0)
  {  

    // Calculation
    FCL_YINC = -1;
    FCL_PIXELY = FCL_PIXELY * -1;

  // } else {

  }

  // Decision
  if (FCL_PIXELY <= FCL_PIXELX)
  {  

    // Calculation
    FCL_C1 = 2 * FCL_PIXELX;
    FCL_M1 = 2 * FCL_PIXELY;

    // Loop
    while (FCL_X1 != FCL_X2)
    {
      // Call Macro
      FCL_IDX = FCM_GetLEDIndex2D(FCL_X1, FCL_Y1);

      // Call Macro
      FCM_SetLEDColour(FCL_IDX, FCL_R, FCL_G, FCL_B);

      // Calculation
      FCL_X1 = FCL_X1 + FCL_XINC;

      // Calculation
      FCL_D1 = FCL_D1 + FCL_M1;

      // Decision
      if (FCL_D1 > FCL_PIXELX)
      {      

        // Calculation
        FCL_Y1 = FCL_Y1 + FCL_YINC;

        // Calculation
        FCL_D1 = FCL_D1 - FCL_C1;

      // } else {

      }

    }

  } else {

    // Calculation
    FCL_C1 = 2 * FCL_PIXELY;
    FCL_M1 = 2 * FCL_PIXELX;

    // Loop
    while (FCL_Y1 != FCL_Y2)
    {
      // Call Macro
      FCL_IDX = FCM_GetLEDIndex2D(FCL_X1, FCL_Y1);

      // Call Macro
      FCM_SetLEDColour(FCL_IDX, FCL_R, FCL_G, FCL_B);

      // Calculation
      FCL_Y1 = FCL_Y1 + FCL_YINC;

      // Calculation
      FCL_D1 = FCL_D1 + FCL_M1;

      // Decision
      if (FCL_D1 > FCL_PIXELY)
      {      

        // Calculation
        FCL_X1 = FCL_X1 + FCL_XINC;

        // Calculation
        FCL_D1 = FCL_D1 - FCL_C1;

      // } else {

      }

    }

  }

  // Call Macro
  FCL_IDX = FCM_GetLEDIndex2D(FCL_X1, FCL_Y1);

  // Call Macro
  FCM_SetLEDColour(FCL_IDX, FCL_R, FCL_G, FCL_B);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the colour of a single LED in RAM as a 1D array.
       :
       :Parameters for macro SetLEDColour:
       :  LED : LED to change the colour / Range: 0 to (LED Count - 1)
       :  R : Red Colour Channel
       :  G : Green Colour Channel
       :  B : Blue Colour Channel
\*=----------------------------------------------------------------------=*/
void FCM_SetLEDColour(MX_UINT16 FCL_LED, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{

  // Check LED index is in range
  if (FCL_LED < 9)
  {  

    // Decision
    if (FCV_COLSCALE < 255)
    {    

      // Calculation
      FCV_RGB[FCL_LED][0] = (FCL_R * FCV_COLSCALE) >> 8;
      FCV_RGB[FCL_LED][1] = (FCL_G * FCV_COLSCALE) >> 8;
      FCV_RGB[FCL_LED][2] = (FCL_B * FCV_COLSCALE) >> 8;

    } else {

      // Assign Colour to LED
      FCV_RGB[FCL_LED][0] = FCL_R;
      FCV_RGB[FCL_LED][1] = FCL_G;
      FCV_RGB[FCL_LED][2] = FCL_B;

    }

  // } else {

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the colour of all the LEDs in RAM
       :
       :Parameters for macro SetAllLEDColour:
       :  R : Red Colour Channel
       :  G : Green Colour Channel
       :  B : Blue Colour Channel
\*=----------------------------------------------------------------------=*/
void FCM_SetAllLEDColour(MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{
  //Local variable definitions
  MX_UINT16 FCL_INDEX = (0x0);


  // Decision
  if (FCV_COLSCALE < 255)
  {  

    // Calculation
    FCL_R = (FCL_R * FCV_COLSCALE) >> 8;
    FCL_G = (FCL_G * FCV_COLSCALE) >> 8;
    FCL_B = (FCL_B * FCV_COLSCALE) >> 8;

  // } else {

  }

  // Loop
  while (FCL_INDEX < 9)
  {
    // Assign Colour to LED
    FCV_RGB[FCL_INDEX][0] = FCL_R;
    FCV_RGB[FCL_INDEX][1] = FCL_G;
    FCV_RGB[FCL_INDEX][2] = FCL_B;

    // Calculation
    FCL_INDEX = FCL_INDEX + 1;

  }

}

/*=----------------------------------------------------------------------=*\
   Use :Sent to a component to allow dynamic amendment of global constant declarations
       :
       :Parameters for macro Ev_AddVar:
       :  VarName[20] : The original Flowcode variable
       :  ExpandName[20] : The expanded variable name
       :  Expansion[20] : The expanded string to inline to the code
       :
       :Returns : Non-zero to include definition - initialised on call
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCM_Ev_AddVar(MX_CHAR *PFCL_VARNAME, MX_CHAR *PFCL_EXPANDNAME, MX_CHAR *FCL_EXPANSION, MX_UINT16 FCLsz_EXPANSION)
{
  //Local variable definitions
  MX_UINT32 FCL_VERSION;
  MX_UINT16 FCL_IDX;
  MX_UINT32 FCR_RETVAL; // Non-zero to include definition - initialised on call

  #define FCLsz_VARNAME 20
  MX_CHAR FCL_VARNAME[FCLsz_VARNAME];
  FCI_CONCATENATE(PFCL_VARNAME,FCLsz_VARNAME,"",0,FCL_VARNAME,FCLsz_VARNAME);
  #define FCLsz_EXPANDNAME 20
  MX_CHAR FCL_EXPANDNAME[FCLsz_EXPANDNAME];
  FCI_CONCATENATE(PFCL_EXPANDNAME,FCLsz_EXPANDNAME,"",0,FCL_EXPANDNAME,FCLsz_EXPANDNAME);


  // Decision
  if (FCI_COMPARE(FCL_VARNAME, FCLsz_VARNAME, "RGB", 4, 1) == 0)
  {  

    // Built-in Function
    // .Version=::System.GetFCVersion()

    // 10.0.3.31
    if (FCL_VERSION >= 655363)
    {    

      // Calculation
      FCL_IDX = FCI_CONTAINS(FCL_EXPANSION, FCLsz_EXPANSION, "[", 2, 0);

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_LEFTSTRING(FCL_EXPANSION, FCLsz_EXPANSION, FCL_IDX, FCL_EXPANSION,20);
      FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "[",2, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "][3];\n",7, FCL_EXPANSION,20);
      }

    } else {

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_LEFTSTRING(FCL_EXPANSION, FCLsz_EXPANSION, FCI_GETLENGTH(FCL_EXPANSION, FCLsz_EXPANSION) - 12, FCL_EXPANSION,20);
      FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "[",2, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "][3];\n",7, FCL_EXPANSION,20);
      }

    }

  // } else {

  }

  // Calculation
  FCR_RETVAL = 1;

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_VARNAME
  #undef FCLsz_EXPANDNAME
}

/*=----------------------------------------------------------------------=*\
   Use :Clocks out the current colour data to the LEDs from the values stored in RAM
\*=----------------------------------------------------------------------=*/
void FCM_Refresh()
{
  //Local variable definitions
  MX_UINT16 FCL_INDEX = (0x0);
  MX_UINT8 FCL_SUBINDEX;
  MX_UINT8 FCL_DATA;
  #define FCLsz_DELAYS 4
  MX_UINT16 FCL_DELAYS[FCLsz_DELAYS];
  MX_BOOL FCL_ONEINQUEUE = (0);


  // C Code
  #if defined(MX_CAL_ESP32)

  // Calculation
  FCL_SUBINDEX = 0;

  // Loop
  while (FCL_INDEX < 9)
  {
    // Decision
    if (0 > 0)
    {    

      // Calculation
      FCL_DATA = 0;

      // Loop
      while (FCL_DATA < 8)
      {
        // Decision
        if (FCV_RGB[FCL_INDEX][1] & (0x80 >> FCL_DATA))
        {        

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T1H, 1, ESP32_T1L, 0}}};

        } else {

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T0H, 1, ESP32_T0L, 0}}};

        }

        // Calculation
        FCL_DATA = FCL_DATA + 1;

      }

      // Calculation
      FCL_DATA = 0;
      FCL_SUBINDEX = FCL_SUBINDEX + 8;

      // Loop
      while (FCL_DATA < 8)
      {
        // Decision
        if (FCV_RGB[FCL_INDEX][0] & (0x80 >> FCL_DATA))
        {        

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T1H, 1, ESP32_T1L, 0}}};

        } else {

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T0H, 1, ESP32_T0L, 0}}};

        }

        // Calculation
        FCL_DATA = FCL_DATA + 1;

      }

      // Calculation
      FCL_DATA = 0;
      FCL_SUBINDEX = FCL_SUBINDEX + 8;

      // Loop
      while (FCL_DATA < 8)
      {
        // Decision
        if (FCV_RGB[FCL_INDEX][2] & (0x80 >> FCL_DATA))
        {        

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T1H, 1, ESP32_T1L, 0}}};

        } else {

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T0H, 1, ESP32_T0L, 0}}};

        }

        // Calculation
        FCL_DATA = FCL_DATA + 1;

      }

    } else {

      // Calculation
      FCL_DATA = 0;

      // Loop
      while (FCL_DATA < 8)
      {
        // Decision
        if (FCV_RGB[FCL_INDEX][0] & (0x80 >> FCL_DATA))
        {        

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T1H, 1, ESP32_T1L, 0}}};

        } else {

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T0H, 1, ESP32_T0L, 0}}};

        }

        // Calculation
        FCL_DATA = FCL_DATA + 1;

      }

      // Calculation
      FCL_DATA = 0;
      FCL_SUBINDEX = FCL_SUBINDEX + 8;

      // Loop
      while (FCL_DATA < 8)
      {
        // Decision
        if (FCV_RGB[FCL_INDEX][1] & (0x80 >> FCL_DATA))
        {        

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T1H, 1, ESP32_T1L, 0}}};

        } else {

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T0H, 1, ESP32_T0L, 0}}};

        }

        // Calculation
        FCL_DATA = FCL_DATA + 1;

      }

      // Calculation
      FCL_DATA = 0;
      FCL_SUBINDEX = FCL_SUBINDEX + 8;

      // Loop
      while (FCL_DATA < 8)
      {
        // Decision
        if (FCV_RGB[FCL_INDEX][2] & (0x80 >> FCL_DATA))
        {        

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T1H, 1, ESP32_T1L, 0}}};

        } else {

          // C Code
          MX_RMT_BUFFER[FCL_SUBINDEX + FCL_DATA] = (rmt_item32_t){{{ESP32_T0H, 1, ESP32_T0L, 0}}};

        }

        // Calculation
        FCL_DATA = FCL_DATA + 1;

      }

    }

    // Calculation
    FCL_SUBINDEX = FCL_SUBINDEX + 8;

    // End of stream flag
    MX_RMT_BUFFER[48] = (rmt_item32_t){{{0}}};

    // Decision
    if (FCL_INDEX & 1)
    {    

      // Decision
      if (FCL_ONEINQUEUE == 0)
      {      

        // Calculation
        FCL_ONEINQUEUE = 1;

      } else {

        // Loop
        while (FC_CAL_RMT_TXBusy_1())
        {
        }

      }

      // Component Macro
      FC_CAL_RMT_TX_1(0);

      // Calculation
      FCL_SUBINDEX = 0;

    // } else {

    }

    // Calculation
    FCL_INDEX = FCL_INDEX + 1;

  }

  // C Code
  #else
  #if defined(MX_CAL_PIC32)

  // Calculation
  FCL_DELAYS[0] = flt_toi(500.000000);
  FCL_DELAYS[1] = flt_toi(2000.000000);
  FCL_DELAYS[2] = flt_toi(1200.000000);
  FCL_DELAYS[3] = flt_toi(1300.000000);

  // Loop
  while (FCL_INDEX < 9)
  {
    // WS2812(B)? - Clocks out data in the format GRB
    if (0 > 0)
    {    

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][1];

      // Loop
      for (FCLV_LOOP4=0; (FCLV_LOOP4)<(8); (FCLV_LOOP4)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[2]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[3]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1L();

#endif // Disabled code

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[0]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[1]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0L();

#endif // Disabled code

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][0];

      // Loop
      for (FCLV_LOOP5=0; (FCLV_LOOP5)<(8); (FCLV_LOOP5)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[2]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[3]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1L();

#endif // Disabled code

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[0]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[1]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0L();

#endif // Disabled code

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][2];

      // Loop
      for (FCLV_LOOP6=0; (FCLV_LOOP6)<(8); (FCLV_LOOP6)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[2]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[3]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1L();

#endif // Disabled code

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[0]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[1]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0L();

#endif // Disabled code

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

    } else {

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][0];

      // Loop
      for (FCLV_LOOP1=0; (FCLV_LOOP1)<(8); (FCLV_LOOP1)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[2]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[3]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1L();

#endif // Disabled code

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[0]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[1]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0L();

#endif // Disabled code

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][1];

      // Loop
      for (FCLV_LOOP2=0; (FCLV_LOOP2)<(8); (FCLV_LOOP2)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[2]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[3]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1L();

#endif // Disabled code

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[0]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[1]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0L();

#endif // Disabled code

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][2];

      // Loop
      for (FCLV_LOOP3=0; (FCLV_LOOP3)<(8); (FCLV_LOOP3)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[2]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[3]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T1L();

#endif // Disabled code

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 1);

          }

          // C Code
          scNsDelay(FCL_DELAYS[0]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0H();

#endif // Disabled code

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Calculation
            SET_PORT_PIN(C, 5, 0);

          }

          // C Code
          scNsDelay(FCL_DELAYS[1]);

#if 0 // Disabled code
          // Call Macro
          FCM_Delay_T0L();

#endif // Disabled code

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

    }

    // Calculation
    FCL_INDEX = FCL_INDEX + 1;

  }

  // C Code
  #else

  // Loop
  while (FCL_INDEX < 9)
  {
    // WS2812(B)? - Clocks out data in the format GRB
    if (0 > 0)
    {    

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][1];

      // Loop
      for (FCLV_LOOP10=0; (FCLV_LOOP10)<(8); (FCLV_LOOP10)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T1H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T1L();

        } else {

          // T0H is the only truly timing critical portion 200-500nS
          #if defined(MX_CAL_PIC16)
          __builtin_disi(0x3FFF); /* disable interrupts */
          #endif

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T0H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // C Code
          #if defined(MX_CAL_PIC16)
          __builtin_disi(0x0000); /* re-enable interrupts */
          #endif

          // Call Macro
          FCM_Delay_T0L();

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][0];

      // Loop
      for (FCLV_LOOP11=0; (FCLV_LOOP11)<(8); (FCLV_LOOP11)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T1H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T1L();

        } else {

          // T0H is the only truly timing critical portion 200-500nS
          #if defined(MX_CAL_PIC16)
          __builtin_disi(0x3FFF); /* disable interrupts */
          #endif

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T0H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // C Code
          #if defined(MX_CAL_PIC16)
          __builtin_disi(0x0000); /* re-enable interrupts */
          #endif

          // Call Macro
          FCM_Delay_T0L();

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][2];

      // Loop
      for (FCLV_LOOP12=0; (FCLV_LOOP12)<(8); (FCLV_LOOP12)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T1H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T1L();

        } else {

          // T0H is the only truly timing critical portion 200-500nS
          #if defined(MX_CAL_PIC16)
          __builtin_disi(0x3FFF); /* disable interrupts */
          #endif

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T0H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // C Code
          #if defined(MX_CAL_PIC16)
          __builtin_disi(0x0000); /* re-enable interrupts */
          #endif

          // Call Macro
          FCM_Delay_T0L();

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

    } else {

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][0];

      // Loop
      for (FCLV_LOOP7=0; (FCLV_LOOP7)<(8); (FCLV_LOOP7)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T1H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T1L();

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T0H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T0L();

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][1];

      // Loop
      for (FCLV_LOOP8=0; (FCLV_LOOP8)<(8); (FCLV_LOOP8)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T1H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T1L();

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T0H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T0L();

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

      // Collect Single RGB LED Data byte
      FCL_DATA = FCV_RGB[FCL_INDEX][2];

      // Loop
      for (FCLV_LOOP9=0; (FCLV_LOOP9)<(8); (FCLV_LOOP9)++)
      {
        // Test the state of the most significant bit
        if (FCL_DATA & 0x80)
        {        

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T1H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T1L();

        } else {

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputHigh();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            }

          }

          // Call Macro
          FCM_Delay_T0H();

          // Decision
          if (1)
          {          

            // Call Macro
            FCM_OutputLow();

          } else {

            // Decision
            if (0)
            {            

              // Calculation
              SET_PORT_PIN(C, 5, 1);

            } else {

              // Calculation
              SET_PORT_PIN(C, 5, 0);

            }

          }

          // Call Macro
          FCM_Delay_T0L();

        }

        // Shift to next data bit
        FCL_DATA = FCL_DATA << 1;

      }

    }

    // Calculation
    FCL_INDEX = FCL_INDEX + 1;

  }

  // C Code
  #endif
  #endif

  //Local variable definitions
  #undef FCLsz_DELAYS
}

/*=----------------------------------------------------------------------=*\
   Use :Shifts the LED colours in 1D and wraps
       :
       :Parameters for macro ShiftLEDs1D:
       :  Direction : 0 = Forwards, 1 = Backwards
       :  DataMode : 0=ResetToZero, 1=WrapAroundDisplay, 2=Smear
\*=----------------------------------------------------------------------=*/
void FCM_ShiftLEDs1D(MX_UINT8 FCL_DIRECTION, MX_UINT8 FCL_DATAMODE)
{
  //Local variable definitions
  MX_UINT16 FCL_INDEX;
  MX_UINT8 FCL_RS;
  MX_UINT8 FCL_GS;
  MX_UINT8 FCL_BS;


  // Forwards or Backwards?
  if (FCL_DIRECTION == 0)
  {  

    // Calculation
    FCL_INDEX = 9 - 1;

    // Decision
    if (FCL_DATAMODE == 1)
    {    

      // Calculation
      FCL_RS = FCV_RGB[FCL_INDEX][0];
      FCL_GS = FCV_RGB[FCL_INDEX][1];
      FCL_BS = FCV_RGB[FCL_INDEX][2];

    // } else {

    }

    // Loop
    while (FCL_INDEX > 0)
    {
      // Calculation
      FCV_RGB[FCL_INDEX][0] = FCV_RGB[FCL_INDEX - 1][0];
      FCV_RGB[FCL_INDEX][1] = FCV_RGB[FCL_INDEX - 1][1];
      FCV_RGB[FCL_INDEX][2] = FCV_RGB[FCL_INDEX - 1][2];

      // Calculation
      FCL_INDEX = FCL_INDEX - 1;

    }

  } else {

    // Calculation
    FCL_INDEX = 0;

    // Decision
    if (FCL_DATAMODE == 1)
    {    

      // Calculation
      FCL_RS = FCV_RGB[FCL_INDEX][0];
      FCL_GS = FCV_RGB[FCL_INDEX][1];
      FCL_BS = FCV_RGB[FCL_INDEX][2];

    // } else {

    }

    // Loop
    while (FCL_INDEX < (9 - 1))
    {
      // Calculation
      FCV_RGB[FCL_INDEX][0] = FCV_RGB[FCL_INDEX + 1][0];
      FCV_RGB[FCL_INDEX][1] = FCV_RGB[FCL_INDEX + 1][1];
      FCV_RGB[FCL_INDEX][2] = FCV_RGB[FCL_INDEX + 1][2];

      // Calculation
      FCL_INDEX = FCL_INDEX + 1;

    }

  }

  // Switch
  switch (FCL_DATAMODE)
  {
    case 1:
    {

      //Comment:
      //Wrap

      // Calculation
      FCV_RGB[FCL_INDEX][0] = FCL_RS;
      FCV_RGB[FCL_INDEX][1] = FCL_GS;
      FCV_RGB[FCL_INDEX][2] = FCL_BS;

      break;
    }
    case 2:
    {

      //Comment:
      //Smear

      break;
    }
    default:
    {
      //Comment:
      //Reset

      // Calculation
      FCV_RGB[FCL_INDEX][0] = 0;
      FCV_RGB[FCL_INDEX][1] = 0;
      FCV_RGB[FCL_INDEX][2] = 0;

    }
  }

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line on a 3D array of LEDs
       :
       :Parameters for macro DrawLine3D:
       :  X1 : Start X Coordinate
       :  Y1 : Start Y Coordinate
       :  Z1 : Start Z Coordinate
       :  X2 : End X Coordinate
       :  Y2 : End Y Coordinate
       :  Z2 : End Z Coordinate
       :  R : Red Colour Channel
       :  G : Green Colour Channel
       :  B : Blue Colour Channel
\*=----------------------------------------------------------------------=*/
void FCM_DrawLine3D(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_Z1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT16 FCL_Z2, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{
  //Local variable definitions
  MX_SINT16 FCL_C1;
  MX_SINT16 FCL_D1 = (0);
  MX_SINT16 FCL_M1;
  MX_SINT16 FCL_PIXELX;
  MX_SINT16 FCL_PIXELY;
  MX_SINT16 FCL_XINC = (1);
  MX_SINT16 FCL_YINC = (1);
  MX_SINT16 FCL_ZINC = (1);
  MX_SINT16 FCL_PIXELZ;
  MX_SINT16 FCL_M2;
  MX_SINT16 FCL_D2 = (0);
  MX_UINT16 FCL_IDX;


  // Calculation
  FCL_PIXELX = FCL_X2 - FCL_X1;
  FCL_PIXELY = FCL_Y2 - FCL_Y1;
  FCL_PIXELZ = FCL_Z2 - FCL_Z1;

  // If negative X direction
  if (FCL_PIXELX < 0)
  {  

    // Calculation
    FCL_XINC = -1;
    FCL_PIXELX = FCL_PIXELX * -1;

  // } else {

  }

  // If negative Y direction
  if (FCL_PIXELY < 0)
  {  

    // Calculation
    FCL_YINC = -1;
    FCL_PIXELY = FCL_PIXELY * -1;

  // } else {

  }

  // If negative Z direction
  if (FCL_PIXELZ < 0)
  {  

    // Calculation
    FCL_ZINC = -1;
    FCL_PIXELZ = FCL_PIXELZ * -1;

  // } else {

  }

  // Decision
  if ((FCL_PIXELY <= FCL_PIXELX) && (FCL_PIXELZ <= FCL_PIXELX))
  {  

    //Comment:
    //X = Bigger than Y and Z

    // Calculation
    FCL_C1 = 2 * FCL_PIXELX;
    FCL_M1 = 2 * FCL_PIXELY;
    FCL_M2 = 2 * FCL_PIXELZ;

    // Loop
    while (FCL_X1 != FCL_X2)
    {
      // Call Macro
      FCL_IDX = FCM_GetLEDIndex3D(FCL_X1, FCL_Y1, FCL_Z1);

      // Call Macro
      FCM_SetLEDColour(FCL_IDX, FCL_R, FCL_G, FCL_B);

      // Calculation
      FCL_X1 = FCL_X1 + FCL_XINC;

      // Calculation
      FCL_D1 = FCL_D1 + FCL_M1;

      // Calculation
      FCL_D2 = FCL_D2 + FCL_M2;

      // Decision
      if (FCL_D1 > FCL_PIXELX)
      {      

        // Calculation
        FCL_Y1 = FCL_Y1 + FCL_YINC;

        // Calculation
        FCL_D1 = FCL_D1 - FCL_C1;

      // } else {

      }

      // Decision
      if (FCL_D2 > FCL_PIXELX)
      {      

        // Calculation
        FCL_Z1 = FCL_Z1 + FCL_ZINC;

        // Calculation
        FCL_D2 = FCL_D2 - FCL_C1;

      // } else {

      }

    }

  } else {

    // Decision
    if ((FCL_PIXELX <= FCL_PIXELY) && (FCL_PIXELZ <= FCL_PIXELY))
    {    

      //Comment:
      //Y = Bigger than X and Z

      // Calculation
      FCL_C1 = 2 * FCL_PIXELY;
      FCL_M1 = 2 * FCL_PIXELX;
      FCL_M2 = 2 * FCL_PIXELZ;

      // Loop
      while (FCL_Y1 != FCL_Y2)
      {
        // Call Macro
        FCL_IDX = FCM_GetLEDIndex3D(FCL_X1, FCL_Y1, FCL_Z1);

        // Call Macro
        FCM_SetLEDColour(FCL_IDX, FCL_R, FCL_G, FCL_B);

        // Calculation
        FCL_Y1 = FCL_Y1 + FCL_YINC;

        // Calculation
        FCL_D1 = FCL_D1 + FCL_M1;

        // Calculation
        FCL_D2 = FCL_D2 + FCL_M2;

        // Decision
        if (FCL_D1 > FCL_PIXELY)
        {        

          // Calculation
          FCL_X1 = FCL_X1 + FCL_XINC;

          // Calculation
          FCL_D1 = FCL_D1 - FCL_C1;

        // } else {

        }

        // Decision
        if (FCL_D2 > FCL_PIXELY)
        {        

          // Calculation
          FCL_Z1 = FCL_Z1 + FCL_ZINC;

          // Calculation
          FCL_D2 = FCL_D2 - FCL_C1;

        // } else {

        }

      }

    } else {

      //Comment:
      //Z = Bigger than X and Y

      // Calculation
      FCL_C1 = 2 * FCL_PIXELZ;
      FCL_M1 = 2 * FCL_PIXELX;
      FCL_M2 = 2 * FCL_PIXELY;

      // Loop
      while (FCL_Z1 != FCL_Z2)
      {
        // Call Macro
        FCL_IDX = FCM_GetLEDIndex3D(FCL_X1, FCL_Y1, FCL_Z1);

        // Call Macro
        FCM_SetLEDColour(FCL_IDX, FCL_R, FCL_G, FCL_B);

        // Calculation
        FCL_Z1 = FCL_Z1 + FCL_ZINC;

        // Calculation
        FCL_D1 = FCL_D1 + FCL_M1;

        // Calculation
        FCL_D2 = FCL_D2 + FCL_M2;

        // Decision
        if (FCL_D1 > FCL_PIXELZ)
        {        

          // Calculation
          FCL_X1 = FCL_X1 + FCL_XINC;

          // Calculation
          FCL_D1 = FCL_D1 - FCL_C1;

        // } else {

        }

        // Decision
        if (FCL_D2 > FCL_PIXELZ)
        {        

          // Calculation
          FCL_Y1 = FCL_Y1 + FCL_YINC;

          // Calculation
          FCL_D2 = FCL_D2 - FCL_C1;

        // } else {

        }

      }

    }

  }

  // Call Macro
  FCL_IDX = FCM_GetLEDIndex3D(FCL_X1, FCL_Y1, FCL_Z1);

  // Call Macro
  FCM_SetLEDColour(FCL_IDX, FCL_R, FCL_G, FCL_B);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the index of a single LED in RAM as a 2D array.
       :
       :Parameters for macro GetLEDIndex2D:
       :  X : LED Column to change the colour / Range: 0 to (LED Column - 1)
       :  Y : LED Row to change the colour / Range: 0 to (LED Row - 1)
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCM_GetLEDIndex2D(MX_UINT16 FCL_X, MX_UINT16 FCL_Y)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  // Decision
  if ((FCL_X >= 3) || (FCL_Y >= 3))
  {  

    // Calculation
    FCR_RETVAL = 9;

  } else {

    // Decision
    if (0)
    {    

      // Test the least significant bit to see which way we are flowing
      if (FCL_Y & 0x01)
      {      

        //Comment:
        //Reversed Direction

        // Decision
        if (0)
        {        

        } else {

          // Calculation
          FCL_X = 3 - FCL_X - 1;

        }

      } else {

        //Comment:
        //Standard Direction

        // Decision
        if (0)
        {        

          // Calculation
          FCL_X = 3 - FCL_X - 1;

        // } else {

        }

      }

    } else {

      //Comment:
      //Standard Direction

      // Decision
      if (0)
      {      

        // Calculation
        FCL_X = 3 - FCL_X - 1;

      // } else {

      }

    }

    // Decision
    if (0)
    {    

      // Calculate index
      FCR_RETVAL = ((3 - FCL_Y - 1) * 3) + FCL_X;

    } else {

      // Calculate index
      FCR_RETVAL = (FCL_Y * 3) + FCL_X;

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a basic 2D rectangle onto the LEDs
       :
       :Parameters for macro DrawRectangle2D:
       :  X1 : MX_UINT8
       :  Y1 : MX_UINT8
       :  X2 : MX_UINT8
       :  Y2 : MX_UINT8
       :  DrawStyle : Sets the draw style - 0=Soild, 1=Edge, 2=Corners
       :  R : MX_UINT8
       :  G : MX_UINT8
       :  B : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCM_DrawRectangle2D(MX_UINT8 FCL_X1, MX_UINT8 FCL_Y1, MX_UINT8 FCL_X2, MX_UINT8 FCL_Y2, MX_UINT8 FCL_DRAWSTYLE, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{
  //Local variable definitions
  MX_UINT8 FCL_YS;
  MX_UINT8 FCL_ZS;
  MX_UINT8 FCL_XS;
  MX_UINT8 FCL_COUNT;
  MX_UINT16 FCL_INDEX;


  // Calculation
  FCL_XS = FCL_X1;
  FCL_YS = FCL_Y1;

  // While X not Complete
  while (1)
  {
    // Calculation
    FCL_Y1 = FCL_YS;

    // While Y Not Complete
    while (1)
    {
      // Switch
      switch (FCL_DRAWSTYLE)
      {
        case 1:
        {

          //Comment:
          //Edge

          // Calculation
          FCL_COUNT = 0;

          // Are we on an edge of at least two axis?
          if ((FCL_X1 == FCL_XS) || (FCL_X1 == FCL_X2))
          {          

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          // } else {

          }

          // Decision
          if ((FCL_Y1 == FCL_YS) || (FCL_Y1 == FCL_Y2))
          {          

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          // } else {

          }

          // On at least 1 Axis?
          if (FCL_COUNT > 0)
          {          

            // Get LED Index
            FCL_INDEX = FCM_GetLEDIndex2D(FCL_X1, FCL_Y1);

            // Colour LED
            FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

          // } else {

          }

          break;
        }
        case 2:
        {

          //Comment:
          //Corners

          // Calculation
          FCL_COUNT = 0;

          // Are we on an edge of at least two axis?
          if ((FCL_X1 == FCL_XS) || (FCL_X1 == FCL_X2))
          {          

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          // } else {

          }

          // Decision
          if ((FCL_Y1 == FCL_YS) || (FCL_Y1 == FCL_Y2))
          {          

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          // } else {

          }

          // On at least 2 Axis?
          if (FCL_COUNT > 1)
          {          

            // Get LED Index
            FCL_INDEX = FCM_GetLEDIndex2D(FCL_X1, FCL_Y1);

            // Colour LED
            FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

          // } else {

          }

          break;
        }
        default:
        {
          //Comment:
          //Solid

          // Get LED Index
          FCL_INDEX = FCM_GetLEDIndex2D(FCL_X1, FCL_Y1);

          // Colour LED
          FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

        }
      }

      // Decision
      if (FCL_Y1 > FCL_Y2)
      {      

        // Calculation
        FCL_Y1 = FCL_Y1 - 1;

      } else {

        // Decision
        if (FCL_Y1 < FCL_Y2)
        {        

          // Calculation
          FCL_Y1 = FCL_Y1 + 1;

        } else {

          // Goto Connection Point
          goto FCC_DrawRectangle2D_B;

        }

      }

    }

    // Connection Point
  FCC_DrawRectangle2D_B:
    ;

    // Decision
    if (FCL_X1 > FCL_X2)
    {    

      // Calculation
      FCL_X1 = FCL_X1 - 1;

    } else {

      // Decision
      if (FCL_X1 < FCL_X2)
      {      

        // Calculation
        FCL_X1 = FCL_X1 + 1;

      } else {

        // Goto Connection Point
        goto FCC_DrawRectangle2D_C;

      }

    }

  }

  // Connection Point
FCC_DrawRectangle2D_C:
  ;

}

/*=----------------------------------------------------------------------=*\
   Use :Sent to a component to allow dynamic amendment of header code
       :
       :Parameters for macro Ev_AddHeader:
       :  HeadCode[20] : Text to amend for header
       :
       :Returns : Non-zero to block header code insertion
\*=----------------------------------------------------------------------=*/
MX_UINT32 FCM_Ev_AddHeader(MX_CHAR *FCL_HEADCODE, MX_UINT16 FCLsz_HEADCODE)
{
  //Local variable definitions
  #define FCLsz_TEMPSTR 20
  MX_CHAR FCL_TEMPSTR[FCLsz_TEMPSTR];
  MX_UINT16 FCL_COUNT;
  #define FCLsz_NAME 20
  MX_CHAR FCL_NAME[FCLsz_NAME];
  #define FCLsz_NSTR 20
  MX_CHAR FCL_NSTR[FCLsz_NSTR];
  #define FCLsz_PSTR 20
  MX_CHAR FCL_PSTR[FCLsz_PSTR];
  #define FCLsz_TSTR 20
  MX_CHAR FCL_TSTR[FCLsz_TSTR];
  #define FCLsz_EXPANSION 20
  MX_CHAR FCL_EXPANSION[FCLsz_EXPANSION];
  MX_UINT32 FCR_RETVAL; // Non-zero to block header code insertion


  // Calculation
  FCR_RETVAL = 0;

  // Simulation
  // .PStr=::Component.Property.GetValue(this, "MOSI")

  // Calculation
  FCL_TSTR[0] = FCL_PSTR[5];
  FCL_TSTR[1] = 0;

  // Calculation
  FCL_NSTR[0] = FCL_PSTR[7];
  FCL_NSTR[1] = FCL_PSTR[8];
  FCL_NSTR[2] = FCL_PSTR[9];

  // Decision
  if (FCI_COMPARE("PIC", 4, "STARM", 6, 1) == 0)
  {  

    // Calculation
    FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\n\nvolatile MX_UINT32 NopCount;\n",32, FCL_TEMPSTR,20);
    FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "volatile MX_UINT32 ST_TIMINGS;\n",32, FCL_TEMPSTR,20);

    // Calculation
    {
    MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
    FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "//WS2811 Bit Timings\n\n//Data 1 High Pulse Timing : ",52, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_FTOS32(1.200000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us\n",4, FCL_TEMPSTR,20);
    }

    // Simulation
    // .Name=::Expand.MacroName("Delay_T1H", this)

    // Decision
    if (5 > 0)
    {    

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() {NopCount = ",16, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(5, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "; while(NopCount--); }\n",24, FCL_TEMPSTR,20);
      }

    } else {

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
      }

    }

    // Calculation
    {
    MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
    FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "//Data 1 Low Pulse Timing : ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_FTOS32(1.300000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us\n",4, FCL_TEMPSTR,20);
    }

    // Simulation
    // .Name=::Expand.MacroName("Delay_T1L", this)

    // Decision
    if (6 > 0)
    {    

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() {NopCount = ",16, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(6, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "; while(NopCount--); }\n",24, FCL_TEMPSTR,20);
      }

    } else {

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
      }

    }

    // Calculation
    {
    MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
    FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "//Data 0 High Pulse Timing : ",30, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_FTOS32(0.500000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us\n",4, FCL_TEMPSTR,20);
    }

    // Simulation
    // .Name=::Expand.MacroName("Delay_T0H", this)

    // Decision
    if (0 > 0)
    {    

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() {NopCount = ",16, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(0, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "; while(NopCount--);}\n",23, FCL_TEMPSTR,20);
      }

    } else {

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
      }

    }

    // Calculation
    {
    MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
    FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "//Data 0 Low Pulse Timing : ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_FTOS32(2.000000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
    FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us\n",4, FCL_TEMPSTR,20);
    }

    // Simulation
    // .Name=::Expand.MacroName("Delay_T0L", this)

    // Decision
    if (9 > 0)
    {    

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() {NopCount = ",16, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "; while(NopCount--);}\n",23, FCL_TEMPSTR,20);
      }

    } else {

      // Calculation
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
      }

    }

    // Calculation
    FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\n\n",3, FCL_TEMPSTR,20);

    // Calculation
    FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_HEADCODE,20);

    // Simulation
    // .Name=::Expand.MacroName("OutputHigh", this)

    // Calculation
    FCI_SHEAD("#define ",9, FCL_NAME,FCLsz_NAME, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "() GPIO_BIT_VAL_DEF(",21, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ", ",3, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ", 1)\n\n",7, FCL_EXPANSION,20);

    // Calculation
    FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

    // Simulation
    // .Name=::Expand.MacroName("OutputLow", this)

    // Calculation
    FCI_SHEAD("#define ",9, FCL_NAME,FCLsz_NAME, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "() GPIO_BIT_VAL_DEF(",21, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ", ",3, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
    FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ", 0)\n\n",7, FCL_EXPANSION,20);

    // Calculation
    FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

  } else {

    // Decision
    if (FCI_COMPARE("PIC", 4, "ESP", 4, 1) == 0)
    {    

      // Odd LED Count?
      if (9 & 1)
      {      

        // Calculation
        FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, "#warning LED Count needs to be an even number on ESP32\n",56, FCL_HEADCODE,20);

      // } else {

      }

      // Get RMT Instance - Channel
      // .count=::Component.GetInstance(ESP32_RMT1)

      // Add channel to buffer definition
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD("#define MX_RMT_BUFFER MX_RMT_Buffer_",37, FCI_UTOS16(FCL_COUNT, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "\n",2, FCL_EXPANSION,20);
      }

      // Calculation
      FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

      // Calculation
      FCL_COUNT = flt_toi((flt_div(0.500000, 0.025)));

      // Add channel to buffer definition
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD("#define ESP32_T0H ",19, FCI_UTOS16(FCL_COUNT, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "\n",2, FCL_EXPANSION,20);
      }

      // Calculation
      FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

      // Calculation
      FCL_COUNT = flt_toi((flt_div(2.000000, 0.025)));

      // Add channel to buffer definition
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD("#define ESP32_T0L ",19, FCI_UTOS16(FCL_COUNT, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "\n",2, FCL_EXPANSION,20);
      }

      // Calculation
      FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

      // Calculation
      FCL_COUNT = flt_toi((flt_div(1.200000, 0.025)));

      // Add channel to buffer definition
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD("#define ESP32_T1H ",19, FCI_UTOS16(FCL_COUNT, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "\n",2, FCL_EXPANSION,20);
      }

      // Calculation
      FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

      // Calculation
      FCL_COUNT = flt_toi((flt_div(1.300000, 0.025)));

      // Add channel to buffer definition
      {
      MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
      FCI_SHEAD("#define ESP32_T1L ",19, FCI_UTOS16(FCL_COUNT, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
      FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "\n",2, FCL_EXPANSION,20);
      }

      // Calculation
      FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

    } else {

      // Decision
      if (FCI_COMPARE("PIC", 4, "PICO", 5, 1) == 0)
      {      

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD("\n\n//WS2811 Bit Timings\n\n//Data 1 High Pulse Timing : ",54, FCI_FTOS32(1.200000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us - ",6, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(5, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, " Instruction cycles\n",21, FCL_TEMPSTR,20);
        }

        // Simulation
        // .Name=::Expand.MacroName("Delay_T1H", this)

        // Decision
        if (5 > 0)
        {        

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() { __asm volatile (\"",23, FCL_TEMPSTR,20);
          }

          // Calculation
          FCL_COUNT = 0;

          // Loop
          while (FCL_COUNT < 5)
          {
            // Calculation
            FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "nop\\n",6, FCL_TEMPSTR,20);

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          }

          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\"); }\n\n",8, FCL_TEMPSTR,20);

        } else {

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
          }

        }

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "//Data 1 Low Pulse Timing : ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_FTOS32(1.300000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us\n",4, FCL_TEMPSTR,20);
        }

        // Simulation
        // .Name=::Expand.MacroName("Delay_T1L", this)

        // Decision
        if (6 > 0)
        {        

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() { __asm volatile (\"",23, FCL_TEMPSTR,20);
          }

          // Calculation
          FCL_COUNT = 0;

          // Loop
          while (FCL_COUNT < 6)
          {
            // Calculation
            FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "nop\\n",6, FCL_TEMPSTR,20);

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          }

          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\"); }\n\n",8, FCL_TEMPSTR,20);

        } else {

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
          }

        }

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "//Data 0 High Pulse Timing : ",30, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_FTOS32(0.500000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us\n",4, FCL_TEMPSTR,20);
        }

        // Simulation
        // .Name=::Expand.MacroName("Delay_T0H", this)

        // Decision
        if (0 > 0)
        {        

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() { __asm volatile (\"",23, FCL_TEMPSTR,20);
          }

          // Calculation
          FCL_COUNT = 0;

          // Loop
          while (FCL_COUNT < 0)
          {
            // Calculation
            FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "nop\\n",6, FCL_TEMPSTR,20);

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          }

          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\"); }\n\n",8, FCL_TEMPSTR,20);

        } else {

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
          }

        }

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "//Data 0 Low Pulse Timing : ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_FTOS32(2.000000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us\n",4, FCL_TEMPSTR,20);
        }

        // Simulation
        // .Name=::Expand.MacroName("Delay_T0L", this)

        // Decision
        if (9 > 0)
        {        

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() { __asm volatile (\"",23, FCL_TEMPSTR,20);
          }

          // Calculation
          FCL_COUNT = 0;

          // Loop
          while (FCL_COUNT < 9)
          {
            // Calculation
            FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "nop\\n",6, FCL_TEMPSTR,20);

            // Calculation
            FCL_COUNT = FCL_COUNT + 1;

          }

          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\"); }\n\n",8, FCL_TEMPSTR,20);

        } else {

          // Calculation
          {
          MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
          FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() \n",5, FCL_TEMPSTR,20);
          }

        }

        // Calculation
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\n\n",3, FCL_TEMPSTR,20);

        // Calculation
        FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_HEADCODE,20);

        // Decision
        if ((5 < 10) || ((6 < 10) || ((0 < 10) || (9 < 10))))
        {        

          // Calculation
          FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, "#warning WS2811 Timings are less than 10 instructions, timing may be incorrect at the current clock speed\n",107, FCL_HEADCODE,20);

        // } else {

        }

        // Calculation
        FCI_SCOPY("PIC",4, FCL_NAME,FCLsz_NAME);
        FCI_LEFTSTRING(FCL_NAME, FCLsz_NAME, 3, FCL_NAME,20);

      } else {

        // Simulation
        // .Name=::Expand.MacroName("Delay_T1H", this)

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD("\n\n//WS2811 Bit Timings\n\n//Data 1 High Pulse Timing : ",54, FCI_FTOS32(1.200000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us - ",6, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(5, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, " Instruction cycles\n#define ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() ",4, FCL_TEMPSTR,20);
        }

        // Calculation
        FCL_COUNT = 0;

        // Loop
        while (FCL_COUNT < 5)
        {
          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, " nop();",8, FCL_TEMPSTR,20);

          // Calculation
          FCL_COUNT = FCL_COUNT + 1;

        }

        // Calculation
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\n\n",3, FCL_TEMPSTR,20);

        // Calculation
        FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_HEADCODE,20);

        // Simulation
        // .Name=::Expand.MacroName("Delay_T1L", this)

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD("//Data 1 Low Pulse Timing : ",29, FCI_FTOS32(1.300000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us - ",6, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(6, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, " Instruction cycles\n#define ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() ",4, FCL_TEMPSTR,20);
        }

        // Calculation
        FCL_COUNT = 0;

        // Loop
        while (FCL_COUNT < 6)
        {
          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, " nop();",8, FCL_TEMPSTR,20);

          // Calculation
          FCL_COUNT = FCL_COUNT + 1;

        }

        // Calculation
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\n\n",3, FCL_TEMPSTR,20);

        // Calculation
        FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_HEADCODE,20);

        // Simulation
        // .Name=::Expand.MacroName("Delay_T0H", this)

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD("//Data 0 High Pulse Timing : ",30, FCI_FTOS32(0.500000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us - ",6, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(0, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, " Instruction cycles\n#define ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() ",4, FCL_TEMPSTR,20);
        }

        // Calculation
        FCL_COUNT = 0;

        // Loop
        while (FCL_COUNT < 0)
        {
          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, " nop();",8, FCL_TEMPSTR,20);

          // Calculation
          FCL_COUNT = FCL_COUNT + 1;

        }

        // Calculation
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\n\n",3, FCL_TEMPSTR,20);

        // Calculation
        FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_HEADCODE,20);

        // Simulation
        // .Name=::Expand.MacroName("Delay_T0L", this)

        // Calculation
        {
        MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
        FCI_SHEAD("//Data 0 Low Pulse Timing : ",29, FCI_FTOS32(2.000000, FCV_PRECISION, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "us - ",6, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCI_ITOS32(9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE),20, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, " Instruction cycles\n#define ",29, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
        FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() ",4, FCL_TEMPSTR,20);
        }

        // Calculation
        FCL_COUNT = 0;

        // Loop
        while (FCL_COUNT < 9)
        {
          // Calculation
          FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, " nop();",8, FCL_TEMPSTR,20);

          // Calculation
          FCL_COUNT = FCL_COUNT + 1;

        }

        // Calculation
        FCI_SHEAD(FCL_TEMPSTR,FCLsz_TEMPSTR, "\n\n",3, FCL_TEMPSTR,20);

        // Calculation
        FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_TEMPSTR,FCLsz_TEMPSTR, FCL_HEADCODE,20);

        // Decision
        if ((5 < 10) || ((6 < 10) || ((0 < 10) || (9 < 10))))
        {        

          // Calculation
          FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, "#warning WS2811 Timings are less than 10 instructions, timing may be incorrect at the current clock speed\n",107, FCL_HEADCODE,20);

        // } else {

        }

        // Calculation
        FCI_SCOPY("PIC",4, FCL_NAME,FCLsz_NAME);
        FCI_LEFTSTRING(FCL_NAME, FCLsz_NAME, 3, FCL_NAME,20);

        // Decision
        if (FCI_COMPARE(FCL_NAME, FCLsz_NAME, "PIC", 4, 0) == 0)
        {        

          // Simulation
          // .Name=::Expand.MacroName("OutputHigh", this)

          // Decision
          if (0)
          {          

            // Calculation
            {
            MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
            FCI_SCOPY("//Data Output High\n",20, FCL_EXPANSION,FCLsz_EXPANSION);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#if defined(_LAT",17, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ") || defined(_LAT",18, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_LAT",5, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_POSITION",10, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ")\n",3, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() LAT",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.LAT",9, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 0\n#else\n",12, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() PORT",8, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.R",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 0\n#endif\n",13, FCL_EXPANSION,20);
            }

          } else {

            // Calculation
            {
            MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
            FCI_SCOPY("//Data Output High\n",20, FCL_EXPANSION,FCLsz_EXPANSION);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#if defined(_LAT",17, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ") || defined(_LAT",18, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_LAT",5, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_POSITION",10, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ")\n",3, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() LAT",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.LAT",9, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 1\n#else\n",12, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() PORT",8, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.R",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 1\n#endif\n",13, FCL_EXPANSION,20);
            }

          }

          // Calculation
          FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

          // Simulation
          // .Name=::Expand.MacroName("OutputLow", this)

          // Decision
          if (0)
          {          

            // Calculation
            {
            MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
            FCI_SCOPY("//Data Output Low\n",19, FCL_EXPANSION,FCLsz_EXPANSION);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#if defined(_LAT",17, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ") || defined(_LAT",18, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_LAT",5, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_POSITION",10, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ")\n",3, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() LAT",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.LAT",9, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 1\n#else\n",12, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() PORT",8, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.R",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 1\n#endif\n",13, FCL_EXPANSION,20);
            }

          } else {

            // Calculation
            {
            MX_CHAR FCI_TMP_STR[MX_MAX_TMPSTR_SIZE];
            FCI_SCOPY("//Data Output Low\n",19, FCL_EXPANSION,FCLsz_EXPANSION);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#if defined(_LAT",17, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ") || defined(_LAT",18, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_LAT",5, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "_POSITION",10, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, ")\n",3, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() LAT",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.LAT",9, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 0\n#else\n",12, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "#define ",9, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, FCL_NAME,FCLsz_NAME, FCI_TMP_STR,MX_MAX_TMPSTR_SIZE);
            FCI_SHEAD(FCI_TMP_STR,MX_MAX_TMPSTR_SIZE, "() PORT",8, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, "bits.R",7, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_TSTR,FCLsz_TSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, FCL_NSTR,FCLsz_NSTR, FCL_EXPANSION,20);
            FCI_SHEAD(FCL_EXPANSION,FCLsz_EXPANSION, " = 0\n#endif\n",13, FCL_EXPANSION,20);
            }

          }

          // Calculation
          FCI_SHEAD(FCL_HEADCODE,FCLsz_HEADCODE, FCL_EXPANSION,FCLsz_EXPANSION, FCL_HEADCODE,20);

        // } else {

        }

      }

    }

  }

  return (FCR_RETVAL);

  //Local variable definitions
  #undef FCLsz_TEMPSTR
  #undef FCLsz_NAME
  #undef FCLsz_NSTR
  #undef FCLsz_PSTR
  #undef FCLsz_TSTR
  #undef FCLsz_EXPANSION
}

/*=----------------------------------------------------------------------=*\
   Use :Shifts the contents of the display by the number of vertices specified
       :***Please Note that Wrap mode is currently unavailable***
       :
       :Parameters for macro ShiftLEDs2D:
       :  X : Number of pixels to shift the display -1 to 1 / 0 = No Shift
       :  Y : Number of pixels to shift the display -1 to 1 / 0 = No Shift
       :  DataMode : 0=ResetToZero, 1=WrapAroundDisplay, 2=Smear
\*=----------------------------------------------------------------------=*/
void FCM_ShiftLEDs2D(MX_SINT16 FCL_X, MX_SINT16 FCL_Y, MX_UINT8 FCL_DATAMODE)
{
  //Local variable definitions
  #define FCLsz_START 2
  MX_UINT8 FCL_START[FCLsz_START];
  #define FCLsz_END 2
  MX_UINT8 FCL_END[FCLsz_END];
  #define FCLsz_CURRENTCOORD 2
  MX_UINT8 FCL_CURRENTCOORD[FCLsz_CURRENTCOORD];
  #define FCLsz_NEWCOORD 2
  MX_SINT16 FCL_NEWCOORD[FCLsz_NEWCOORD];
  MX_UINT16 FCL_INDEX;
  MX_UINT8 FCL_R;
  MX_UINT8 FCL_G;
  MX_UINT8 FCL_B;


  // If X is negative
  if (FCL_X < 0)
  {  

    // 
    FCL_START[0] = 0;
    FCL_END[0] = (3 - 1);

  } else {

    // 
    FCL_START[0] = (3 - 1);
    FCL_END[0] = 0;

  }

  // If Y is negative
  if (FCL_Y < 0)
  {  

    // 
    FCL_START[1] = 0;
    FCL_END[1] = (3 - 1);

  } else {

    // 
    FCL_START[1] = (3 - 1);
    FCL_END[1] = 0;

  }

  // Calculation
  FCL_CURRENTCOORD[0] = FCL_START[0];
  FCL_CURRENTCOORD[1] = FCL_START[1];

  // Loop
  while (1)
  {
    // Calculation
    FCL_CURRENTCOORD[1] = FCL_START[1];

    // Loop
    while (1)
    {
      // Switch
      switch (FCL_DATAMODE)
      {
        case 1:
        {

          // Calculation
          FCL_INDEX = 0;

          break;
        }
        case 2:
        {

          // Calculation
          FCL_NEWCOORD[0] = FCL_CURRENTCOORD[0] + FCL_X;
          FCL_NEWCOORD[1] = FCL_CURRENTCOORD[1] + FCL_Y;

          // Decision
          if ((FCL_NEWCOORD[0] < 3) && (FCL_NEWCOORD[0] >= 0))
          {          

            // Decision
            if ((FCL_NEWCOORD[1] < 3) && (FCL_NEWCOORD[1] >= 0))
            {            

              // Get LED Index
              FCL_INDEX = FCM_GetLEDIndex2D(FCL_CURRENTCOORD[0], FCL_CURRENTCOORD[1]);

              // Calculation
              FCL_R = FCV_RGB[FCL_INDEX][0];
              FCL_G = FCV_RGB[FCL_INDEX][1];
              FCL_B = FCV_RGB[FCL_INDEX][2];

#if 0 // Disabled code
              // Colour LED
              FCL_R = FCM_GetLEDColour(FCL_INDEX, 0);

#endif // Disabled code

#if 0 // Disabled code
              // Colour LED
              FCL_G = FCM_GetLEDColour(FCL_INDEX, 1);

#endif // Disabled code

#if 0 // Disabled code
              // Colour LED
              FCL_B = FCM_GetLEDColour(FCL_INDEX, 2);

#endif // Disabled code

              // Get LED Index
              FCL_INDEX = FCM_GetLEDIndex2D(FCL_NEWCOORD[0], FCL_NEWCOORD[1]);

              // Calculation
              FCV_RGB[FCL_INDEX][0] = FCL_R;
              FCV_RGB[FCL_INDEX][1] = FCL_G;
              FCV_RGB[FCL_INDEX][2] = FCL_B;

#if 0 // Disabled code
              // Colour LED
              FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

#endif // Disabled code

            // } else {

            }

          // } else {

          }

          break;
        }
        default:
        {
          // Calculation
          FCL_NEWCOORD[0] = FCL_CURRENTCOORD[0] + FCL_X;
          FCL_NEWCOORD[1] = FCL_CURRENTCOORD[1] + FCL_Y;

          // Decision
          if ((FCL_NEWCOORD[0] < 3) && (FCL_NEWCOORD[0] >= 0))
          {          

            // Decision
            if ((FCL_NEWCOORD[1] < 3) && (FCL_NEWCOORD[1] >= 0))
            {            

              // Get LED Index
              FCL_INDEX = FCM_GetLEDIndex2D(FCL_CURRENTCOORD[0], FCL_CURRENTCOORD[1]);

              // Calculation
              FCL_R = FCV_RGB[FCL_INDEX][0];
              FCL_G = FCV_RGB[FCL_INDEX][1];
              FCL_B = FCV_RGB[FCL_INDEX][2];

#if 0 // Disabled code
              // Colour LED
              FCL_R = FCM_GetLEDColour(FCL_INDEX, 0);

#endif // Disabled code

#if 0 // Disabled code
              // Colour LED
              FCL_G = FCM_GetLEDColour(FCL_INDEX, 1);

#endif // Disabled code

#if 0 // Disabled code
              // Colour LED
              FCL_B = FCM_GetLEDColour(FCL_INDEX, 2);

#endif // Disabled code

              // Get LED Index
              FCL_INDEX = FCM_GetLEDIndex2D(FCL_NEWCOORD[0], FCL_NEWCOORD[1]);

              // Calculation
              FCV_RGB[FCL_INDEX][0] = FCL_R;
              FCV_RGB[FCL_INDEX][1] = FCL_G;
              FCV_RGB[FCL_INDEX][2] = FCL_B;

#if 0 // Disabled code
              // Colour LED
              FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

#endif // Disabled code

            // } else {

            }

          // } else {

          }

          // Get LED Index
          FCL_INDEX = FCM_GetLEDIndex2D(FCL_CURRENTCOORD[0], FCL_CURRENTCOORD[1]);

          // Colour LED
          FCM_SetLEDColour(FCL_INDEX, 0, 0, 0);

        }
      }

      // Decision
      if (FCL_CURRENTCOORD[1] > FCL_END[1])
      {      

        // Calculation
        FCL_CURRENTCOORD[1] = FCL_CURRENTCOORD[1] - 1;

      } else {

        // Decision
        if (FCL_CURRENTCOORD[1] < FCL_END[1])
        {        

          // Calculation
          FCL_CURRENTCOORD[1] = FCL_CURRENTCOORD[1] + 1;

        } else {

          // Goto Connection Point
          goto FCC_ShiftLEDs2D_B;

        }

      }

    }

    // Connection Point
  FCC_ShiftLEDs2D_B:
    ;

    // Decision
    if (FCL_CURRENTCOORD[0] > FCL_END[0])
    {    

      // Calculation
      FCL_CURRENTCOORD[0] = FCL_CURRENTCOORD[0] - 1;

    } else {

      // Decision
      if (FCL_CURRENTCOORD[0] < FCL_END[0])
      {      

        // Calculation
        FCL_CURRENTCOORD[0] = FCL_CURRENTCOORD[0] + 1;

      } else {

        // Goto Connection Point
        goto FCC_ShiftLEDs2D_C;

      }

    }

  }

  // Connection Point
FCC_ShiftLEDs2D_C:
  ;

  //Local variable definitions
  #undef FCLsz_START
  #undef FCLsz_END
  #undef FCLsz_CURRENTCOORD
  #undef FCLsz_NEWCOORD
}

/*=----------------------------------------------------------------------=*\
   Use :Gets the index of a single LED in RAM as a 3D array.
       :
       :Parameters for macro GetLEDIndex3D:
       :  X : LED Column to change the colour / Range: 0 to (LED Column - 1)
       :  Y : LED Row to change the colour / Range: 0 to (LED Row - 1)
       :  Z : LED Layer to change the colour / Range: 0 to (LED Layer - 1)
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCM_GetLEDIndex3D(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_Z)
{
  //Local variable definitions
  MX_UINT16 FCR_RETVAL;


  // Decision
  if ((FCL_X >= 3) || (FCL_Y >= 3) || (FCL_Z >= 3))
  {  

    // Calculation
    FCR_RETVAL = 9;

  } else {

    // Decision
    if (0)
    {    

      // Test the least significant bit to see which way we are flowing
      if (((FCL_Z * 3) + FCL_Y) & 0x01)
      {      

        //Comment:
        //Reversed Direction

        // Decision
        if (0)
        {        

        } else {

          // Calculation
          FCL_X = 3 - FCL_X - 1;

        }

      } else {

        //Comment:
        //Standard Direction

        // Decision
        if (0)
        {        

          // Calculation
          FCL_X = 3 - FCL_X - 1;

        // } else {

        }

      }

    } else {

      //Comment:
      //Standard Direction

      // Decision
      if (0)
      {      

        // Calculation
        FCL_X = 3 - FCL_X - 1;

      // } else {

      }

    }

    // Decision
    if (0)
    {    

      // Decision
      if (0)
      {      

        // Calculate index
        FCR_RETVAL = ((3 - FCL_Z - 1) * (3 * 3)) + ((3 - FCL_Y - 1) * 3) + FCL_X;

      } else {

        // Calculate index
        FCR_RETVAL = (FCL_Z * (3 * 3)) + ((3 - FCL_Y - 1) * 3) + FCL_X;

      }

    } else {

      // Decision
      if (0)
      {      

        // Calculate index
        FCR_RETVAL = ((3 - FCL_Z - 1) * (3 * 3)) + (FCL_Y * 3) + FCL_X;

      } else {

        // Calculate index
        FCR_RETVAL = (FCL_Z * (3 * 3)) + (FCL_Y * 3) + FCL_X;

      }

    }

  }

  return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Clocks out the current colour data to the LEDs from the values stored in RAM
\*=----------------------------------------------------------------------=*/
void FCM_RefreshSim()
{
  //Local variable definitions
  MX_UINT16 FCL_INDEX = (0x0);
  MX_UINT32 FCL_HANDLE;
  MX_UINT8 FCL_DIR = (0x0);
  MX_UINT16 FCL_OFFSET;
  MX_UINT16 FCL_STARTIDX;
  MX_SINT32 FCL_PANELID = (0);


  // Built-in Function
  // .PanelID=::Component.GetPanel(this)

  // Switch
  switch (0)
  {
    case 1:
    {

      //Comment:
      //2D

      // Loop
      while (FCL_INDEX < 9)
      {
        // Decision
        if (FCL_DIR == 1)
        {        

          // Legacy panels - 3D mode
          if (FCL_PANELID < 0)
          {          

            // Simulation
            // .Handle=clone_matrix_3d::GetHandleFor(.StartIdx + .Offset)

          } else {

            // Simulation
            // .Handle=clone_matrix_2d::GetHandleFor(.StartIdx + .Offset)

          }

          // Calculation
          FCL_OFFSET = FCL_OFFSET - 1;

        } else {

          // Legacy panels - 3D mode
          if (FCL_PANELID < 0)
          {          

            // Simulation
            // .Handle=clone_matrix_3d::GetHandleFor(.Index)

          } else {

            // Simulation
            // .Handle=clone_matrix_2d::GetHandleFor(.Index)

          }

        }

        // Simulation
        // ::Component.Property.SetColor(.Handle, RGB[.Index][0], RGB[.Index][1], RGB[.Index][2])

        // Calculation
        FCL_INDEX = FCL_INDEX + 1;

        // Decision
        if (0)
        {        

          // Decision
          if ((FCL_INDEX % 3) == 0)
          {          

            // Calculation
            FCL_DIR = (FCL_DIR + 1) & 1;

            // Calculation
            FCL_OFFSET = 3 - 1;

            // Calculation
            FCL_STARTIDX = FCL_INDEX;

          // } else {

          }

        // } else {

        }

      }

      break;
    }
    case 2:
    {

      //Comment:
      //3D - Not right yet
      //When we move to the second layer we might have to count backwards for the entire layer

      // Loop
      while (FCL_INDEX < 9)
      {
        // Decision
        if (FCL_DIR == 1)
        {        

          // Legacy panels - 3D mode
          if (FCL_PANELID < 0)
          {          

            // Simulation
            // .Handle=clone_matrix_3d::GetHandleFor(.StartIdx + .Offset)

          } else {

            // Simulation
            // .Handle=clone_matrix_2d::GetHandleFor(.StartIdx + .Offset)

          }

          // Calculation
          FCL_OFFSET = FCL_OFFSET - 1;

        } else {

          // Legacy panels - 3D mode
          if (FCL_PANELID < 0)
          {          

            // Simulation
            // .Handle=clone_matrix_3d::GetHandleFor(.Index)

          } else {

            // Simulation
            // .Handle=clone_matrix_2d::GetHandleFor(.Index)

          }

        }

        // Simulation
        // ::Component.Property.SetColor(.Handle, RGB[.Index][0], RGB[.Index][1], RGB[.Index][2])

        // Calculation
        FCL_INDEX = FCL_INDEX + 1;

        // Decision
        if (0)
        {        

          // Decision
          if ((FCL_INDEX % 3) == 0)
          {          

            // Calculation
            FCL_DIR = (FCL_DIR + 1) & 1;

            // Calculation
            FCL_OFFSET = 3 - 1;

            // Calculation
            FCL_STARTIDX = FCL_INDEX;

          // } else {

          }

        // } else {

        }

      }

      break;
    }
    default:
    {
      //Comment:
      //1D

      // Loop
      while (FCL_INDEX < 9)
      {
        // Legacy panels - 3D mode
        if (FCL_PANELID < 0)
        {        

          // Simulation
          // .Handle=clone_matrix_3d::GetHandleFor(.Index)

        } else {

          // Simulation
          // .Handle=clone_matrix_2d::GetHandleFor(.Index)

        }

        // Simulation
        // ::Component.Property.SetColor(.Handle, RGB[.Index][0], RGB[.Index][1], RGB[.Index][2])

        // Calculation
        FCL_INDEX = FCL_INDEX + 1;

      }

    }
  }

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a basic 3D cuboid onto the LEDs
       :
       :Parameters for macro DrawCuboid3D:
       :  X1 : Start X pixel coordinate
       :  Y1 : Start Y pixel coordinate
       :  Z1 : Start Z pixel coordinate
       :  X2 : End X pixel coordinate
       :  Y2 : End Y pixel coordinate
       :  Z2 : End Z pixel coordinate
       :  DrawStyle : Sets the draw style - 0=Soild, 1=Edge, 2=Corners
       :  R : Red Colour Channel
       :  G : Green Colour Channel
       :  B : White Colour Channel
\*=----------------------------------------------------------------------=*/
void FCM_DrawCuboid3D(MX_UINT8 FCL_X1, MX_UINT8 FCL_Y1, MX_UINT8 FCL_Z1, MX_UINT8 FCL_X2, MX_UINT8 FCL_Y2, MX_UINT8 FCL_Z2, MX_UINT8 FCL_DRAWSTYLE, MX_UINT8 FCL_R, MX_UINT8 FCL_G, MX_UINT8 FCL_B)
{
  //Local variable definitions
  MX_UINT8 FCL_YS;
  MX_UINT8 FCL_ZS;
  MX_UINT8 FCL_XS;
  MX_UINT8 FCL_COUNT;
  MX_UINT16 FCL_INDEX;


  // Calculation
  FCL_XS = FCL_X1;
  FCL_YS = FCL_Y1;
  FCL_ZS = FCL_Z1;

  // While X not Complete
  while (1)
  {
    // Calculation
    FCL_Y1 = FCL_YS;

    // While Y Not Complete
    while (1)
    {
      // Calculation
      FCL_Z1 = FCL_ZS;

      // While Z Not Complete
      while (1)
      {
        // Switch
        switch (FCL_DRAWSTYLE)
        {
          case 1:
          {

            //Comment:
            //Edge

            // Calculation
            FCL_COUNT = 0;

            // Are we on an edge of at least two axis?
            if ((FCL_X1 == FCL_XS) || (FCL_X1 == FCL_X2))
            {            

              // Calculation
              FCL_COUNT = FCL_COUNT + 1;

            // } else {

            }

            // Decision
            if ((FCL_Y1 == FCL_YS) || (FCL_Y1 == FCL_Y2))
            {            

              // Calculation
              FCL_COUNT = FCL_COUNT + 1;

            // } else {

            }

            // Decision
            if ((FCL_Z1 == FCL_ZS) || (FCL_Z1 == FCL_Z2))
            {            

              // Calculation
              FCL_COUNT = FCL_COUNT + 1;

            // } else {

            }

            // On at least 2 Axis?
            if (FCL_COUNT > 1)
            {            

              // Get LED Index
              FCL_INDEX = FCM_GetLEDIndex3D(FCL_X1, FCL_Y1, FCL_Z1);

              // Colour LED
              FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

            // } else {

            }

            break;
          }
          case 2:
          {

            //Comment:
            //Corners

            // Calculation
            FCL_COUNT = 0;

            // Are we on an edge of at least two axis?
            if ((FCL_X1 == FCL_XS) || (FCL_X1 == FCL_X2))
            {            

              // Calculation
              FCL_COUNT = FCL_COUNT + 1;

            // } else {

            }

            // Decision
            if ((FCL_Y1 == FCL_YS) || (FCL_Y1 == FCL_Y2))
            {            

              // Calculation
              FCL_COUNT = FCL_COUNT + 1;

            // } else {

            }

            // Decision
            if ((FCL_Z1 == FCL_ZS) || (FCL_Z1 == FCL_Z2))
            {            

              // Calculation
              FCL_COUNT = FCL_COUNT + 1;

            // } else {

            }

            // On at least 3 Axis?
            if (FCL_COUNT > 2)
            {            

              // Get LED Index
              FCL_INDEX = FCM_GetLEDIndex3D(FCL_X1, FCL_Y1, FCL_Z1);

              // Colour LED
              FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

            // } else {

            }

            break;
          }
          default:
          {
            //Comment:
            //Solid

            // Get LED Index
            FCL_INDEX = FCM_GetLEDIndex3D(FCL_X1, FCL_Y1, FCL_Z1);

            // Colour LED
            FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

          }
        }

        // Decision
        if (FCL_Z1 > FCL_Z2)
        {        

          // Calculation
          FCL_Z1 = FCL_Z1 - 1;

        } else {

          // Decision
          if (FCL_Z1 < FCL_Z2)
          {          

            // Calculation
            FCL_Z1 = FCL_Z1 + 1;

          } else {

            // Goto Connection Point
            goto FCC_DrawCuboid3D_A;

          }

        }

      }

      // Connection Point
    FCC_DrawCuboid3D_A:
      ;

      // Decision
      if (FCL_Y1 > FCL_Y2)
      {      

        // Calculation
        FCL_Y1 = FCL_Y1 - 1;

      } else {

        // Decision
        if (FCL_Y1 < FCL_Y2)
        {        

          // Calculation
          FCL_Y1 = FCL_Y1 + 1;

        } else {

          // Goto Connection Point
          goto FCC_DrawCuboid3D_B;

        }

      }

    }

    // Connection Point
  FCC_DrawCuboid3D_B:
    ;

    // Decision
    if (FCL_X1 > FCL_X2)
    {    

      // Calculation
      FCL_X1 = FCL_X1 - 1;

    } else {

      // Decision
      if (FCL_X1 < FCL_X2)
      {      

        // Calculation
        FCL_X1 = FCL_X1 + 1;

      } else {

        // Goto Connection Point
        goto FCC_DrawCuboid3D_C;

      }

    }

  }

  // Connection Point
FCC_DrawCuboid3D_C:
  ;

}

/*=----------------------------------------------------------------------=*\
   Use :Inisialises the RGB colour RAM to 0,0,0 = LED Off and clocks out the data to 
       :initialise all the LED ICs in the chain.
\*=----------------------------------------------------------------------=*/
void FCM_Initialise()
{

  // C Code
  #if defined (MX_CAL_ESP32)

  // Component Macro
  FC_CAL_RMT_Init_1();

  // C Code
  #else

  // Decision
  if (0)
  {  

    // Calculation
    SET_PORT_PIN(C, 5, 1);

  } else {

    // Calculation
    SET_PORT_PIN(C, 5, 0);

  }

  // Delay
  FCI_DELAYBYTE_MS(1);

  // C Code
  #endif

  // Call Macro
  FCM_SetAllLEDColour(0, 0, 0);

  // Call Macro
  FCM_Refresh();

}

/*=----------------------------------------------------------------------=*\
   Use :Shifts the contents of the display by the number of vertices specified
       :***Please Note that Wrap mode is currently unavailable***
       :
       :Parameters for macro ShiftLEDs3D:
       :  X : Number of pixels to shift the display -1 to 1 / 0 = No Shift
       :  Y : Number of pixels to shift the display -1 to 1 / 0 = No Shift
       :  Z : Number of pixels to shift the display -1 to 1 / 0 = No Shift
       :  DataMode : 0=ResetToZero, 1=WrapAroundDisplay, 2=Smear
\*=----------------------------------------------------------------------=*/
void FCM_ShiftLEDs3D(MX_SINT16 FCL_X, MX_SINT16 FCL_Y, MX_SINT16 FCL_Z, MX_UINT8 FCL_DATAMODE)
{
  //Local variable definitions
  #define FCLsz_START 3
  MX_UINT8 FCL_START[FCLsz_START];
  #define FCLsz_END 3
  MX_UINT8 FCL_END[FCLsz_END];
  #define FCLsz_CURRENTCOORD 3
  MX_UINT8 FCL_CURRENTCOORD[FCLsz_CURRENTCOORD];
  #define FCLsz_NEWCOORD 3
  MX_SINT16 FCL_NEWCOORD[FCLsz_NEWCOORD];
  MX_UINT16 FCL_INDEX;
  MX_UINT8 FCL_R;
  MX_UINT8 FCL_G;
  MX_UINT8 FCL_B;


  // If X is negative
  if (FCL_X < 0)
  {  

    // 
    FCL_START[0] = 0;
    FCL_END[0] = (3 - 1);

  } else {

    // 
    FCL_START[0] = (3 - 1);
    FCL_END[0] = 0;

  }

  // If Y is negative
  if (FCL_Y < 0)
  {  

    // 
    FCL_START[1] = 0;
    FCL_END[1] = (3 - 1);

  } else {

    // 
    FCL_START[1] = (3 - 1);
    FCL_END[1] = 0;

  }

  // If z is negative
  if (FCL_Z < 0)
  {  

    // 
    FCL_START[2] = 0;
    FCL_END[2] = (3 - 1);

  } else {

    // 
    FCL_START[2] = (3 - 1);
    FCL_END[2] = 0;

  }

  // Calculation
  FCL_CURRENTCOORD[0] = FCL_START[0];
  FCL_CURRENTCOORD[1] = FCL_START[1];
  FCL_CURRENTCOORD[2] = FCL_START[2];

  // Loop
  while (1)
  {
    // Calculation
    FCL_CURRENTCOORD[1] = FCL_START[1];

    // Loop
    while (1)
    {
      // Calculation
      FCL_CURRENTCOORD[2] = FCL_START[2];

      // Loop
      while (1)
      {
        // Switch
        switch (FCL_DATAMODE)
        {
          case 1:
          {

            // Calculation
            FCL_INDEX = 0;

            break;
          }
          case 2:
          {

            // Calculation
            FCL_NEWCOORD[0] = FCL_CURRENTCOORD[0] + FCL_X;
            FCL_NEWCOORD[1] = FCL_CURRENTCOORD[1] + FCL_Y;
            FCL_NEWCOORD[2] = FCL_CURRENTCOORD[2] + FCL_Z;

            // Decision
            if ((FCL_NEWCOORD[0] < 3) && (FCL_NEWCOORD[0] >= 0))
            {            

              // Decision
              if ((FCL_NEWCOORD[1] < 3) && (FCL_NEWCOORD[1] >= 0))
              {              

                // Decision
                if ((FCL_NEWCOORD[2] < 3) && (FCL_NEWCOORD[2] >= 0))
                {                

                  // Get LED Index
                  FCL_INDEX = FCM_GetLEDIndex3D(FCL_CURRENTCOORD[0], FCL_CURRENTCOORD[1], FCL_CURRENTCOORD[2]);

                  // Calculation
                  FCL_R = FCV_RGB[FCL_INDEX][0];
                  FCL_G = FCV_RGB[FCL_INDEX][1];
                  FCL_B = FCV_RGB[FCL_INDEX][2];

#if 0 // Disabled code
                  // Colour LED
                  FCL_R = FCM_GetLEDColour(FCL_INDEX, 0);

#endif // Disabled code

#if 0 // Disabled code
                  // Colour LED
                  FCL_G = FCM_GetLEDColour(FCL_INDEX, 1);

#endif // Disabled code

#if 0 // Disabled code
                  // Colour LED
                  FCL_B = FCM_GetLEDColour(FCL_INDEX, 2);

#endif // Disabled code

                  // Get LED Index
                  FCL_INDEX = FCM_GetLEDIndex3D(FCL_NEWCOORD[0], FCL_NEWCOORD[1], FCL_NEWCOORD[2]);

                  // Calculation
                  FCV_RGB[FCL_INDEX][0] = FCL_R;
                  FCV_RGB[FCL_INDEX][1] = FCL_G;
                  FCV_RGB[FCL_INDEX][2] = FCL_B;

#if 0 // Disabled code
                  // Colour LED
                  FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

#endif // Disabled code

                // } else {

                }

              // } else {

              }

            // } else {

            }

            break;
          }
          default:
          {
            // Calculation
            FCL_NEWCOORD[0] = FCL_CURRENTCOORD[0] + FCL_X;
            FCL_NEWCOORD[1] = FCL_CURRENTCOORD[1] + FCL_Y;
            FCL_NEWCOORD[2] = FCL_CURRENTCOORD[2] + FCL_Z;

            // Decision
            if ((FCL_NEWCOORD[0] < 3) && (FCL_NEWCOORD[0] >= 0))
            {            

              // Decision
              if ((FCL_NEWCOORD[1] < 3) && (FCL_NEWCOORD[1] >= 0))
              {              

                // Decision
                if ((FCL_NEWCOORD[2] < 3) && (FCL_NEWCOORD[2] >= 0))
                {                

                  // Get LED Index
                  FCL_INDEX = FCM_GetLEDIndex3D(FCL_CURRENTCOORD[0], FCL_CURRENTCOORD[1], FCL_CURRENTCOORD[2]);

                  // Calculation
                  FCL_R = FCV_RGB[FCL_INDEX][0];
                  FCL_G = FCV_RGB[FCL_INDEX][1];
                  FCL_B = FCV_RGB[FCL_INDEX][2];

#if 0 // Disabled code
                  // Colour LED
                  FCL_R = FCM_GetLEDColour(FCL_INDEX, 0);

#endif // Disabled code

#if 0 // Disabled code
                  // Colour LED
                  FCL_G = FCM_GetLEDColour(FCL_INDEX, 1);

#endif // Disabled code

#if 0 // Disabled code
                  // Colour LED
                  FCL_B = FCM_GetLEDColour(FCL_INDEX, 2);

#endif // Disabled code

                  // Get LED Index
                  FCL_INDEX = FCM_GetLEDIndex3D(FCL_NEWCOORD[0], FCL_NEWCOORD[1], FCL_NEWCOORD[2]);

                  // Calculation
                  FCV_RGB[FCL_INDEX][0] = FCL_R;
                  FCV_RGB[FCL_INDEX][1] = FCL_G;
                  FCV_RGB[FCL_INDEX][2] = FCL_B;

#if 0 // Disabled code
                  // Colour LED
                  FCM_SetLEDColour(FCL_INDEX, FCL_R, FCL_G, FCL_B);

#endif // Disabled code

                // } else {

                }

              // } else {

              }

            // } else {

            }

            // Get LED Index
            FCL_INDEX = FCM_GetLEDIndex3D(FCL_CURRENTCOORD[0], FCL_CURRENTCOORD[1], FCL_CURRENTCOORD[2]);

            // Colour LED
            FCM_SetLEDColour(FCL_INDEX, 0, 0, 0);

          }
        }

        // Decision
        if (FCL_CURRENTCOORD[2] > FCL_END[2])
        {        

          // Calculation
          FCL_CURRENTCOORD[2] = FCL_CURRENTCOORD[2] - 1;

        } else {

          // Decision
          if (FCL_CURRENTCOORD[2] < FCL_END[2])
          {          

            // Calculation
            FCL_CURRENTCOORD[2] = FCL_CURRENTCOORD[2] + 1;

          } else {

            // Goto Connection Point
            goto FCC_ShiftLEDs3D_A;

          }

        }

      }

      // Connection Point
    FCC_ShiftLEDs3D_A:
      ;

      // Decision
      if (FCL_CURRENTCOORD[1] > FCL_END[1])
      {      

        // Calculation
        FCL_CURRENTCOORD[1] = FCL_CURRENTCOORD[1] - 1;

      } else {

        // Decision
        if (FCL_CURRENTCOORD[1] < FCL_END[1])
        {        

          // Calculation
          FCL_CURRENTCOORD[1] = FCL_CURRENTCOORD[1] + 1;

        } else {

          // Goto Connection Point
          goto FCC_ShiftLEDs3D_B;

        }

      }

    }

    // Connection Point
  FCC_ShiftLEDs3D_B:
    ;

    // Decision
    if (FCL_CURRENTCOORD[0] > FCL_END[0])
    {    

      // Calculation
      FCL_CURRENTCOORD[0] = FCL_CURRENTCOORD[0] - 1;

    } else {

      // Decision
      if (FCL_CURRENTCOORD[0] < FCL_END[0])
      {      

        // Calculation
        FCL_CURRENTCOORD[0] = FCL_CURRENTCOORD[0] + 1;

      } else {

        // Goto Connection Point
        goto FCC_ShiftLEDs3D_C;

      }

    }

  }

  // Connection Point
FCC_ShiftLEDs3D_C:
  ;

  //Local variable definitions
  #undef FCLsz_START
  #undef FCLsz_END
  #undef FCLsz_CURRENTCOORD
  #undef FCLsz_NEWCOORD
}

/*=----------------------------------------------------------------------=*\
   Use :Supplementary implementations
\*=----------------------------------------------------------------------=*/




/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
	#ifdef INTOSCHELPER
		INTOSCHELPERCODE
	#endif
  //Local variable definitions
  MX_UINT32 FCL_VERSION;

ANSELA = 0x00;
ANSELB = 0x00;
ANSELD = 0x00;
ANSELE = 0x00;

OPTION_REG = 0xC0;


  // Built-in Function
  // .Version=::System.GetFCVersion()

  // Built-in Function
  // ::Debug.Print(.Version)

  // Call Macro
  FCM_Initialise();

#if 0 // Disabled code
  // Call Macro
  FCM_DrawLine2D(0, 0, 0, 9, 255, 0, 0);

#endif // Disabled code

#if 0 // Disabled code
  // Call Macro
  FCM_RefreshSim();

#endif // Disabled code

#if 0 // Disabled code
  // Loop
  for (FCLV_LOOP13=0; (FCLV_LOOP13)<(10); (FCLV_LOOP13)++)
  {
#if 0 // Disabled code
    // Delay
    FCI_DELAYBYTE_S(1);

#endif // Disabled code

#if 0 // Disabled code
    // Call Macro
    FCM_ShiftLEDs2D(1, 0, 2);

#endif // Disabled code

#if 0 // Disabled code
    // Call Macro
    FCM_RefreshSim();

#endif // Disabled code

  }

#endif // Disabled code

  // Call Macro
  FCM_Initialise();

  // Call Macro
  FCM_DrawLine2D(0, 0, 9, 0, 255, 0, 0);

  // Call Macro
  FCM_RefreshSim();

  // Loop
  for (FCLV_LOOP14=0; (FCLV_LOOP14)<(10); (FCLV_LOOP14)++)
  {
    // Delay
    FCI_DELAYBYTE_S(1);

    // Call Macro
    FCM_ShiftLEDs2D(0, 1, 0);

    // Call Macro
    FCM_RefreshSim();

  }

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void interrupt MX_INTERRUPT_MACRO(void)
{

}




